/* workspaceselector.c generated by valac, the Vala compiler
 * generated from workspaceselector.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <gdk/gdk.h>
#include <gtk/gtk.h>
#include <libwnck/libwnck.h>
#include <gdk/gdkx.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xregion.h>
#include <glib/gi18n-lib.h>
#include <float.h>
#include <math.h>


#define TYPE_WORKSPACE_SELECTOR (workspace_selector_get_type ())
#define WORKSPACE_SELECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WORKSPACE_SELECTOR, WorkspaceSelector))
#define WORKSPACE_SELECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WORKSPACE_SELECTOR, WorkspaceSelectorClass))
#define IS_WORKSPACE_SELECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WORKSPACE_SELECTOR))
#define IS_WORKSPACE_SELECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WORKSPACE_SELECTOR))
#define WORKSPACE_SELECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WORKSPACE_SELECTOR, WorkspaceSelectorClass))

typedef struct _WorkspaceSelector WorkspaceSelector;
typedef struct _WorkspaceSelectorClass WorkspaceSelectorClass;
typedef struct _WorkspaceSelectorPrivate WorkspaceSelectorPrivate;

#define TYPE_WORKSPACE_ITEM (workspace_item_get_type ())
#define WORKSPACE_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WORKSPACE_ITEM, WorkspaceItem))
#define WORKSPACE_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WORKSPACE_ITEM, WorkspaceItemClass))
#define IS_WORKSPACE_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WORKSPACE_ITEM))
#define IS_WORKSPACE_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WORKSPACE_ITEM))
#define WORKSPACE_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WORKSPACE_ITEM, WorkspaceItemClass))

typedef struct _WorkspaceItem WorkspaceItem;
typedef struct _WorkspaceItemClass WorkspaceItemClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_object_unref (var), NULL)))
typedef struct _WorkspaceItemPrivate WorkspaceItemPrivate;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))

struct _WorkspaceSelector {
	GtkWindow parent_instance;
	WorkspaceSelectorPrivate * priv;
};

struct _WorkspaceSelectorClass {
	GtkWindowClass parent_class;
};

struct _WorkspaceSelectorPrivate {
	WnckWindow* target;
	GList* workspaces;
	GtkCheckButton* follow;
	guint iid;
};

struct _WorkspaceItem {
	GtkEventBox parent_instance;
	WorkspaceItemPrivate * priv;
	gint viewport_x;
	gint viewport_y;
};

struct _WorkspaceItemClass {
	GtkEventBoxClass parent_class;
};

struct _WorkspaceItemPrivate {
	GtkImage* _image;
	gint _margin;
	gboolean _selected;
	gboolean _current;
};


static gpointer workspace_selector_parent_class = NULL;
static gpointer workspace_item_parent_class = NULL;

GdkPixbuf* _wnck_gdk_pixbuf_get_from_pixmap (GdkPixbuf* dest, GdkPixmap* xpixmap, gint src_x, gint src_y, gint dest_x, gint dest_y, gint width, gint height);
GdkPixbuf* gdk_pixbuf_get_from_drawable (GdkPixbuf* dest, GdkDrawable* src, GdkColormap* cmap, gint src_x, gint src_y, gint dest_x, gint dest_y, gint width, gint height);
GType workspace_selector_get_type (void) G_GNUC_CONST;
GType workspace_item_get_type (void) G_GNUC_CONST;
#define WORKSPACE_SELECTOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_WORKSPACE_SELECTOR, WorkspaceSelectorPrivate))
enum  {
	WORKSPACE_SELECTOR_DUMMY_PROPERTY,
	WORKSPACE_SELECTOR_NROWS,
	WORKSPACE_SELECTOR_NCOLS,
	WORKSPACE_SELECTOR_SCREEN_WIDTH,
	WORKSPACE_SELECTOR_SCREEN_HEIGHT,
	WORKSPACE_SELECTOR_WORKSPACE_WIDTH,
	WORKSPACE_SELECTOR_WORKSPACE_HEIGHT,
	WORKSPACE_SELECTOR_CURRENT_COLUMN,
	WORKSPACE_SELECTOR_CURRENT_ROW,
	WORKSPACE_SELECTOR_SELECTED_ITEM
};
static void _g_list_free_g_object_unref (GList* self);
#define WORKSPACE_SELECTOR_WIDTH 128
#define WORKSPACE_SELECTOR_ICON_SCALE_RATIO 6
#define WORKSPACE_SELECTOR_ICON_ALPHA 255
static void workspace_selector_do_menu (WorkspaceSelector* self);
WorkspaceSelector* workspace_selector_new (WnckWindow* window);
WorkspaceSelector* workspace_selector_construct (GType object_type, WnckWindow* window);
static void workspace_selector_real_dispose (GObject* base);
static gboolean workspace_selector_on_leave_notify (WorkspaceSelector* self, WorkspaceSelector* wss, GdkEventCrossing* event);
static gboolean workspace_selector_on_button_press (WorkspaceSelector* self, WorkspaceSelector* wss, GdkEventButton* event);
WorkspaceItem* workspace_selector_get_selected_item (WorkspaceSelector* self);
static gboolean workspace_selector_on_viewport_moved (WorkspaceSelector* self);
static gboolean _workspace_selector_on_viewport_moved_gsource_func (gpointer self);
static gboolean workspace_selector_on_button_release (WorkspaceSelector* self, WorkspaceSelector* wss, GdkEventButton* event);
gint workspace_selector_get_nrows (WorkspaceSelector* self);
gint workspace_selector_get_ncols (WorkspaceSelector* self);
WorkspaceItem* workspace_item_new_with_pixbuf (GdkPixbuf* pixbuf);
WorkspaceItem* workspace_item_construct_with_pixbuf (GType object_type, GdkPixbuf* pixbuf);
static GdkPixbuf* workspace_selector_get_mini_screenshot (WorkspaceSelector* self, gint col, gint row);
gint workspace_selector_get_screen_width (WorkspaceSelector* self);
gint workspace_selector_get_screen_height (WorkspaceSelector* self);
gint workspace_selector_get_current_row (WorkspaceSelector* self);
gint workspace_selector_get_current_column (WorkspaceSelector* self);
void workspace_item_set_current (WorkspaceItem* self, gboolean value);
static gboolean workspace_selector_window_visible_on_desktop (WorkspaceSelector* self, WnckWindow* window, gint col, gint row);
static void workspace_selector_get_window_abs_geometry (WorkspaceSelector* self, WnckWindow* window, gint* x, gint* y, gint* w, gint* h);
gint workspace_selector_get_workspace_height (WorkspaceSelector* self);
gint workspace_selector_get_workspace_width (WorkspaceSelector* self);
gboolean workspace_item_get_selected (WorkspaceItem* self);
static gboolean _workspace_selector_on_leave_notify_gtk_widget_leave_notify_event (WorkspaceSelector* _sender, GdkEventCrossing* event, gpointer self);
static gboolean _workspace_selector_on_button_press_gtk_widget_button_press_event (WorkspaceSelector* _sender, GdkEventButton* event, gpointer self);
static gboolean _workspace_selector_on_button_release_gtk_widget_button_release_event (WorkspaceSelector* _sender, GdkEventButton* event, gpointer self);
static GObject * workspace_selector_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void workspace_selector_finalize (GObject* obj);
static void workspace_selector_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
#define WORKSPACE_ITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_WORKSPACE_ITEM, WorkspaceItemPrivate))
enum  {
	WORKSPACE_ITEM_DUMMY_PROPERTY,
	WORKSPACE_ITEM_IMAGE,
	WORKSPACE_ITEM_MARGIN,
	WORKSPACE_ITEM_SELECTED,
	WORKSPACE_ITEM_CURRENT
};
WorkspaceItem* workspace_item_new (void);
WorkspaceItem* workspace_item_construct (GType object_type);
void workspace_item_set_image (WorkspaceItem* self, GtkImage* value);
GtkImage* workspace_item_get_image (WorkspaceItem* self);
gint workspace_item_get_margin (WorkspaceItem* self);
static void workspace_item_update (WorkspaceItem* self);
void workspace_item_set_selected (WorkspaceItem* self, gboolean value);
static gboolean workspace_item_on_leave_notify (WorkspaceItem* self, WorkspaceItem* wi, GdkEventCrossing* event);
static gboolean workspace_item_on_enter_notify (WorkspaceItem* self, WorkspaceItem* wi, GdkEventCrossing* event);
void workspace_item_set_margin (WorkspaceItem* self, gint value);
gboolean workspace_item_get_current (WorkspaceItem* self);
static gboolean _workspace_item_on_leave_notify_gtk_widget_leave_notify_event (WorkspaceItem* _sender, GdkEventCrossing* event, gpointer self);
static gboolean _workspace_item_on_enter_notify_gtk_widget_enter_notify_event (WorkspaceItem* _sender, GdkEventCrossing* event, gpointer self);
static GObject * workspace_item_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void workspace_item_finalize (GObject* obj);
static void workspace_item_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void workspace_item_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);



static void _g_list_free_g_object_unref (GList* self) {
	g_list_foreach (self, (GFunc) g_object_unref, NULL);
	g_list_free (self);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


WorkspaceSelector* workspace_selector_construct (GType object_type, WnckWindow* window) {
	WorkspaceSelector * self;
	WnckWindow* _tmp0_;
	self = g_object_newv (object_type, 0, NULL);
	self->priv->target = (_tmp0_ = _g_object_ref0 (window), _g_object_unref0 (self->priv->target), _tmp0_);
	workspace_selector_do_menu (self);
	return self;
}


WorkspaceSelector* workspace_selector_new (WnckWindow* window) {
	return workspace_selector_construct (TYPE_WORKSPACE_SELECTOR, window);
}


static void workspace_selector_real_dispose (GObject* base) {
	WorkspaceSelector * self;
	WnckWindow* _tmp0_;
	self = (WorkspaceSelector*) base;
	self->priv->target = (_tmp0_ = NULL, _g_object_unref0 (self->priv->target), _tmp0_);
	G_OBJECT_CLASS (workspace_selector_parent_class)->dispose ((GObject*) GTK_WINDOW (self));
}


static gboolean workspace_selector_on_leave_notify (WorkspaceSelector* self, WorkspaceSelector* wss, GdkEventCrossing* event) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (wss != NULL, FALSE);
	if (self->priv->iid != 0) {
		result = FALSE;
		return result;
	}
	if ((*event).state == 0) {
		gtk_object_destroy ((GtkObject*) self);
	}
	result = FALSE;
	return result;
}


static gboolean workspace_selector_on_button_press (WorkspaceSelector* self, WorkspaceSelector* wss, GdkEventButton* event) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (wss != NULL, FALSE);
	result = FALSE;
	return result;
}


static gboolean _workspace_selector_on_viewport_moved_gsource_func (gpointer self) {
	gboolean result;
	result = workspace_selector_on_viewport_moved (self);
	return result;
}


static gboolean workspace_selector_on_button_release (WorkspaceSelector* self, WorkspaceSelector* wss, GdkEventButton* event) {
	gboolean result = FALSE;
	GdkWindow* window;
	gint x = 0;
	gint y = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (wss != NULL, FALSE);
	if (workspace_selector_get_selected_item (self) == NULL) {
		result = FALSE;
		return result;
	}
	window = _g_object_ref0 (GDK_WINDOW (gdk_xid_table_lookup ((XID) ((guint32) wnck_window_get_xid (self->priv->target)))));
	if (window == NULL) {
		result = FALSE;
		_g_object_unref0 (window);
		return result;
	}
	gdk_window_get_root_origin (window, &x, &y);
	x = x + (workspace_selector_get_selected_item (self)->viewport_x - wnck_workspace_get_viewport_x (wnck_window_get_workspace (self->priv->target)));
	y = y + (workspace_selector_get_selected_item (self)->viewport_y - wnck_workspace_get_viewport_y (wnck_window_get_workspace (self->priv->target)));
	gdk_window_move (window, x, y);
	if (gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->follow)) {
		wnck_screen_move_viewport (wnck_window_get_screen (self->priv->target), workspace_selector_get_selected_item (self)->viewport_x, workspace_selector_get_selected_item (self)->viewport_y);
		self->priv->iid = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 1000, _workspace_selector_on_viewport_moved_gsource_func, g_object_ref (self), g_object_unref);
	} else {
		gtk_object_destroy ((GtkObject*) self);
	}
	result = FALSE;
	_g_object_unref0 (window);
	return result;
}


static gboolean workspace_selector_on_viewport_moved (WorkspaceSelector* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	wnck_window_activate (self->priv->target, gtk_get_current_event_time ());
	gtk_object_destroy ((GtkObject*) self);
	result = FALSE;
	return result;
}


static void workspace_selector_do_menu (WorkspaceSelector* self) {
	GtkVBox* rows;
	GtkHBox* row;
	GtkCheckButton* _tmp6_;
	GtkMenuItem* _tmp7_;
	g_return_if_fail (self != NULL);
	rows = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
	row = NULL;
	{
		gint nrow;
		nrow = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				GtkHBox* _tmp1_;
				if (!_tmp0_) {
					nrow++;
				}
				_tmp0_ = FALSE;
				if (!(nrow < workspace_selector_get_nrows (self))) {
					break;
				}
				row = (_tmp1_ = g_object_ref_sink ((GtkHBox*) gtk_hbox_new (TRUE, 0)), _g_object_unref0 (row), _tmp1_);
				gtk_box_pack_start ((GtkBox*) rows, (GtkWidget*) row, TRUE, TRUE, (guint) 0);
				{
					gint ncol;
					ncol = 0;
					{
						gboolean _tmp2_;
						_tmp2_ = TRUE;
						while (TRUE) {
							GdkPixbuf* _tmp3_;
							WorkspaceItem* _tmp4_;
							WorkspaceItem* wi;
							gboolean _tmp5_ = FALSE;
							if (!_tmp2_) {
								ncol++;
							}
							_tmp2_ = FALSE;
							if (!(ncol < workspace_selector_get_ncols (self))) {
								break;
							}
							wi = (_tmp4_ = g_object_ref_sink (workspace_item_new_with_pixbuf (_tmp3_ = workspace_selector_get_mini_screenshot (self, ncol, nrow))), _g_object_unref0 (_tmp3_), _tmp4_);
							gtk_box_pack_start ((GtkBox*) row, (GtkWidget*) wi, TRUE, TRUE, (guint) 0);
							wi->viewport_x = ncol * workspace_selector_get_screen_width (self);
							wi->viewport_y = nrow * workspace_selector_get_screen_height (self);
							if (workspace_selector_get_current_row (self) == nrow) {
								_tmp5_ = workspace_selector_get_current_column (self) == ncol;
							} else {
								_tmp5_ = FALSE;
							}
							workspace_item_set_current (wi, _tmp5_);
							self->priv->workspaces = g_list_append (self->priv->workspaces, _g_object_ref0 (wi));
							_g_object_unref0 (wi);
						}
					}
				}
			}
		}
	}
	self->priv->follow = (_tmp6_ = g_object_ref_sink ((GtkCheckButton*) gtk_check_button_new_with_label (_ ("Follow the window"))), _g_object_unref0 (self->priv->follow), _tmp6_);
	gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->follow, TRUE);
	gtk_box_pack_start ((GtkBox*) rows, (GtkWidget*) self->priv->follow, TRUE, TRUE, (guint) 0);
	gtk_widget_set_style ((GtkWidget*) self->priv->follow, gtk_rc_get_style ((GtkWidget*) (_tmp7_ = g_object_ref_sink ((GtkMenuItem*) gtk_menu_item_new ()))));
	_g_object_unref0 (_tmp7_);
	{
		GList* w_collection;
		GList* w_it;
		w_collection = gtk_container_get_children ((GtkContainer*) self->priv->follow);
		for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
			GtkWidget* w;
			w = (GtkWidget*) w_it->data;
			{
				if (G_TYPE_FROM_INSTANCE ((GObject*) w) == GTK_TYPE_LABEL) {
					gtk_widget_set_style (w, gtk_widget_get_style ((GtkWidget*) self->priv->follow));
				}
			}
		}
		_g_list_free0 (w_collection);
	}
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) rows);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (row);
	_g_object_unref0 (rows);
}


static GdkPixbuf* workspace_selector_get_mini_screenshot (WorkspaceSelector* self, gint col, gint row) {
	GdkPixbuf* result = NULL;
	GdkPixmap* p;
	GdkPixbuf* ss;
	GList* windows;
	GdkPixbuf* pb;
	double ratio;
	g_return_val_if_fail (self != NULL, NULL);
	p = (GdkPixmap*) wnck_screen_get_background_pixmap (wnck_window_get_screen (self->priv->target));
	ss = _wnck_gdk_pixbuf_get_from_pixmap (NULL, p, 0, 0, 0, 0, -1, -1);
	windows = wnck_screen_get_windows (wnck_screen_get_default ());
	{
		GList* window_collection;
		GList* window_it;
		window_collection = windows;
		for (window_it = window_collection; window_it != NULL; window_it = window_it->next) {
			WnckWindow* window;
			window = (WnckWindow*) window_it->data;
			{
				gboolean _tmp0_ = FALSE;
				if (workspace_selector_window_visible_on_desktop (self, window, col, row)) {
					_tmp0_ = !wnck_window_is_skip_pager (window);
				} else {
					_tmp0_ = FALSE;
				}
				if (_tmp0_) {
					GdkPixbuf* mi;
					gint x = 0;
					gint y = 0;
					gint w = 0;
					gint h = 0;
					GdkWindow* gwindow;
					GdkPixbuf* wi;
					mi = _g_object_ref0 (wnck_window_get_icon (window));
					workspace_selector_get_window_abs_geometry (self, window, &x, &y, &w, &h);
					x = x - (col * workspace_selector_get_screen_width (self));
					y = y - (row * workspace_selector_get_screen_height (self));
					gwindow = _g_object_ref0 (GDK_WINDOW (gdk_xid_table_lookup ((XID) ((guint32) wnck_window_get_xid (window)))));
					wi = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, w, h);
					gdk_pixbuf_fill (wi, (guint32) 0x0000007f);
					gdk_pixbuf_composite (mi, wi, 0, 0, gdk_pixbuf_get_width (mi) * WORKSPACE_SELECTOR_ICON_SCALE_RATIO, gdk_pixbuf_get_height (mi) * WORKSPACE_SELECTOR_ICON_SCALE_RATIO, (double) 0, (double) 0, (double) WORKSPACE_SELECTOR_ICON_SCALE_RATIO, (double) WORKSPACE_SELECTOR_ICON_SCALE_RATIO, GDK_INTERP_NEAREST, WORKSPACE_SELECTOR_ICON_ALPHA);
					gdk_pixbuf_composite (wi, ss, x, y, w, h, (double) x, (double) y, (double) 1, (double) 1, GDK_INTERP_NEAREST, 255);
					_g_object_unref0 (wi);
					_g_object_unref0 (gwindow);
					_g_object_unref0 (mi);
				}
			}
		}
	}
	pb = gdk_pixbuf_new (GDK_COLORSPACE_RGB, FALSE, 8, WORKSPACE_SELECTOR_WIDTH, (gint) ((((double) WORKSPACE_SELECTOR_WIDTH) / ((double) workspace_selector_get_screen_width (self))) * workspace_selector_get_screen_height (self)));
	ratio = ((double) gdk_pixbuf_get_width (pb)) / ((double) gdk_pixbuf_get_width (ss));
	gdk_pixbuf_scale (ss, pb, 0, 0, gdk_pixbuf_get_width (pb), gdk_pixbuf_get_height (pb), (double) 0, (double) 0, ratio, ratio, GDK_INTERP_BILINEAR);
	result = pb;
	_g_object_unref0 (ss);
	return result;
}


static void workspace_selector_get_window_abs_geometry (WorkspaceSelector* self, WnckWindow* window, gint* x, gint* y, gint* w, gint* h) {
	WnckWorkspace* workspace;
	g_return_if_fail (self != NULL);
	g_return_if_fail (window != NULL);
	wnck_window_get_geometry (window, x, y, w, h);
	workspace = _g_object_ref0 (wnck_window_get_workspace (window));
	if (workspace != NULL) {
		*x = (*x) + wnck_workspace_get_viewport_x (workspace);
		*y = (*y) + wnck_workspace_get_viewport_y (workspace);
	}
	_g_object_unref0 (workspace);
}


static gboolean workspace_selector_window_visible_on_desktop (WorkspaceSelector* self, WnckWindow* window, gint col, gint row) {
	gboolean result = FALSE;
	gint x = 0;
	gint y = 0;
	gint w = 0;
	gint h = 0;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (window != NULL, FALSE);
	if (wnck_window_is_minimized (window)) {
		result = FALSE;
		return result;
	}
	workspace_selector_get_window_abs_geometry (self, window, &x, &y, &w, &h);
	if (x >= (col * workspace_selector_get_screen_width (self))) {
		_tmp2_ = x < ((col + 1) * workspace_selector_get_screen_width (self));
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		_tmp1_ = y >= (row * workspace_selector_get_screen_height (self));
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = y < ((row + 1) * workspace_selector_get_screen_height (self));
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


gint workspace_selector_get_nrows (WorkspaceSelector* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = workspace_selector_get_workspace_height (self) / workspace_selector_get_screen_height (self);
	return result;
}


gint workspace_selector_get_ncols (WorkspaceSelector* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = workspace_selector_get_workspace_width (self) / workspace_selector_get_screen_width (self);
	return result;
}


gint workspace_selector_get_screen_width (WorkspaceSelector* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = wnck_screen_get_width (wnck_window_get_screen (self->priv->target));
	return result;
}


gint workspace_selector_get_screen_height (WorkspaceSelector* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = wnck_screen_get_height (wnck_window_get_screen (self->priv->target));
	return result;
}


gint workspace_selector_get_workspace_width (WorkspaceSelector* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = wnck_workspace_get_width (wnck_window_get_workspace (self->priv->target));
	return result;
}


gint workspace_selector_get_workspace_height (WorkspaceSelector* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = wnck_workspace_get_height (wnck_window_get_workspace (self->priv->target));
	return result;
}


gint workspace_selector_get_current_column (WorkspaceSelector* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = wnck_workspace_get_viewport_x (wnck_window_get_workspace (self->priv->target)) / workspace_selector_get_screen_width (self);
	return result;
}


gint workspace_selector_get_current_row (WorkspaceSelector* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = wnck_workspace_get_viewport_y (wnck_window_get_workspace (self->priv->target)) / workspace_selector_get_screen_height (self);
	return result;
}


WorkspaceItem* workspace_selector_get_selected_item (WorkspaceSelector* self) {
	WorkspaceItem* result;
	g_return_val_if_fail (self != NULL, NULL);
	{
		GList* wi_collection;
		GList* wi_it;
		wi_collection = self->priv->workspaces;
		for (wi_it = wi_collection; wi_it != NULL; wi_it = wi_it->next) {
			WorkspaceItem* wi;
			wi = (WorkspaceItem*) wi_it->data;
			{
				if (workspace_item_get_selected (wi)) {
					result = wi;
					return result;
				}
			}
		}
	}
	result = NULL;
	return result;
}


static gboolean _workspace_selector_on_leave_notify_gtk_widget_leave_notify_event (WorkspaceSelector* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = workspace_selector_on_leave_notify (self, _sender, event);
	return result;
}


static gboolean _workspace_selector_on_button_press_gtk_widget_button_press_event (WorkspaceSelector* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = workspace_selector_on_button_press (self, _sender, event);
	return result;
}


static gboolean _workspace_selector_on_button_release_gtk_widget_button_release_event (WorkspaceSelector* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = workspace_selector_on_button_release (self, _sender, event);
	return result;
}


static GObject * workspace_selector_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	WorkspaceSelector * self;
	parent_class = G_OBJECT_CLASS (workspace_selector_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = WORKSPACE_SELECTOR (obj);
	{
		GtkMenu* _tmp0_;
		gtk_widget_set_name ((GtkWidget*) self, "WorkspaceSelector");
		gtk_window_set_type_hint ((GtkWindow*) self, GDK_WINDOW_TYPE_HINT_MENU);
		g_object_set ((GtkWindow*) self, "window-position", GTK_WIN_POS_CENTER_ALWAYS, NULL);
		gtk_window_set_resizable ((GtkWindow*) self, FALSE);
		g_object_set ((GtkWindow*) self, "allow-grow", FALSE, NULL);
		gtk_window_set_decorated ((GtkWindow*) self, FALSE);
		gtk_window_set_skip_pager_hint ((GtkWindow*) self, TRUE);
		gtk_window_set_skip_taskbar_hint ((GtkWindow*) self, TRUE);
		if (((GtkBin*) self)->child != NULL) {
			gtk_widget_show_all (((GtkBin*) self)->child);
		}
		g_object_set ((GtkWindow*) self, "default-width", 100, NULL);
		g_object_set ((GtkWindow*) self, "default-height", 100, NULL);
		g_signal_connect_object ((GtkWidget*) self, "leave-notify-event", (GCallback) _workspace_selector_on_leave_notify_gtk_widget_leave_notify_event, self, 0);
		g_signal_connect_object ((GtkWidget*) self, "button-press-event", (GCallback) _workspace_selector_on_button_press_gtk_widget_button_press_event, self, 0);
		g_signal_connect_object ((GtkWidget*) self, "button-release-event", (GCallback) _workspace_selector_on_button_release_gtk_widget_button_release_event, self, 0);
		gtk_widget_set_style ((GtkWidget*) self, gtk_rc_get_style ((GtkWidget*) (_tmp0_ = g_object_ref_sink ((GtkMenu*) gtk_menu_new ()))));
		_g_object_unref0 (_tmp0_);
	}
	return obj;
}


static void workspace_selector_class_init (WorkspaceSelectorClass * klass) {
	workspace_selector_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (WorkspaceSelectorPrivate));
	G_OBJECT_CLASS (klass)->dispose = workspace_selector_real_dispose;
	G_OBJECT_CLASS (klass)->get_property = workspace_selector_get_property;
	G_OBJECT_CLASS (klass)->constructor = workspace_selector_constructor;
	G_OBJECT_CLASS (klass)->finalize = workspace_selector_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_SELECTOR_NROWS, g_param_spec_int ("nrows", "nrows", "nrows", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_SELECTOR_NCOLS, g_param_spec_int ("ncols", "ncols", "ncols", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_SELECTOR_SCREEN_WIDTH, g_param_spec_int ("screen-width", "screen-width", "screen-width", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_SELECTOR_SCREEN_HEIGHT, g_param_spec_int ("screen-height", "screen-height", "screen-height", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_SELECTOR_WORKSPACE_WIDTH, g_param_spec_int ("workspace-width", "workspace-width", "workspace-width", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_SELECTOR_WORKSPACE_HEIGHT, g_param_spec_int ("workspace-height", "workspace-height", "workspace-height", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_SELECTOR_CURRENT_COLUMN, g_param_spec_int ("current-column", "current-column", "current-column", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_SELECTOR_CURRENT_ROW, g_param_spec_int ("current-row", "current-row", "current-row", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_SELECTOR_SELECTED_ITEM, g_param_spec_object ("selected-item", "selected-item", "selected-item", TYPE_WORKSPACE_ITEM, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void workspace_selector_instance_init (WorkspaceSelector * self) {
	self->priv = WORKSPACE_SELECTOR_GET_PRIVATE (self);
	self->priv->iid = (guint) 0;
}


static void workspace_selector_finalize (GObject* obj) {
	WorkspaceSelector * self;
	self = WORKSPACE_SELECTOR (obj);
	_g_object_unref0 (self->priv->target);
	__g_list_free_g_object_unref0 (self->priv->workspaces);
	_g_object_unref0 (self->priv->follow);
	G_OBJECT_CLASS (workspace_selector_parent_class)->finalize (obj);
}


GType workspace_selector_get_type (void) {
	static volatile gsize workspace_selector_type_id__volatile = 0;
	if (g_once_init_enter (&workspace_selector_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (WorkspaceSelectorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) workspace_selector_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (WorkspaceSelector), 0, (GInstanceInitFunc) workspace_selector_instance_init, NULL };
		GType workspace_selector_type_id;
		workspace_selector_type_id = g_type_register_static (GTK_TYPE_WINDOW, "WorkspaceSelector", &g_define_type_info, 0);
		g_once_init_leave (&workspace_selector_type_id__volatile, workspace_selector_type_id);
	}
	return workspace_selector_type_id__volatile;
}


static void workspace_selector_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	WorkspaceSelector * self;
	self = WORKSPACE_SELECTOR (object);
	switch (property_id) {
		case WORKSPACE_SELECTOR_NROWS:
		g_value_set_int (value, workspace_selector_get_nrows (self));
		break;
		case WORKSPACE_SELECTOR_NCOLS:
		g_value_set_int (value, workspace_selector_get_ncols (self));
		break;
		case WORKSPACE_SELECTOR_SCREEN_WIDTH:
		g_value_set_int (value, workspace_selector_get_screen_width (self));
		break;
		case WORKSPACE_SELECTOR_SCREEN_HEIGHT:
		g_value_set_int (value, workspace_selector_get_screen_height (self));
		break;
		case WORKSPACE_SELECTOR_WORKSPACE_WIDTH:
		g_value_set_int (value, workspace_selector_get_workspace_width (self));
		break;
		case WORKSPACE_SELECTOR_WORKSPACE_HEIGHT:
		g_value_set_int (value, workspace_selector_get_workspace_height (self));
		break;
		case WORKSPACE_SELECTOR_CURRENT_COLUMN:
		g_value_set_int (value, workspace_selector_get_current_column (self));
		break;
		case WORKSPACE_SELECTOR_CURRENT_ROW:
		g_value_set_int (value, workspace_selector_get_current_row (self));
		break;
		case WORKSPACE_SELECTOR_SELECTED_ITEM:
		g_value_set_object (value, workspace_selector_get_selected_item (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


WorkspaceItem* workspace_item_construct (GType object_type) {
	WorkspaceItem * self;
	GtkImage* _tmp0_;
	self = g_object_newv (object_type, 0, NULL);
	self->priv->_image = (_tmp0_ = NULL, _g_object_unref0 (self->priv->_image), _tmp0_);
	gtk_widget_show ((GtkWidget*) self);
	return self;
}


WorkspaceItem* workspace_item_new (void) {
	return workspace_item_construct (TYPE_WORKSPACE_ITEM);
}


WorkspaceItem* workspace_item_construct_with_pixbuf (GType object_type, GdkPixbuf* pixbuf) {
	WorkspaceItem * self;
	GtkImage* _tmp0_;
	g_return_val_if_fail (pixbuf != NULL, NULL);
	self = g_object_newv (object_type, 0, NULL);
	workspace_item_set_image (self, _tmp0_ = g_object_ref_sink ((GtkImage*) gtk_image_new_from_pixbuf (pixbuf)));
	_g_object_unref0 (_tmp0_);
	gtk_widget_show_all ((GtkWidget*) self);
	return self;
}


WorkspaceItem* workspace_item_new_with_pixbuf (GdkPixbuf* pixbuf) {
	return workspace_item_construct_with_pixbuf (TYPE_WORKSPACE_ITEM, pixbuf);
}


static void workspace_item_update (WorkspaceItem* self) {
	GdkPixbuf* _tmp1_;
	GdkPixbuf* _tmp0_ = NULL;
	GdkPixbuf* _tmp3_;
	GdkPixbuf* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	if (workspace_item_get_image (self) == NULL) {
		return;
	}
	g_object_set ((GtkWidget*) self, "width-request", gdk_pixbuf_get_width (_tmp1_ = (g_object_get (workspace_item_get_image (self), "pixbuf", &_tmp0_, NULL), _tmp0_)) + (workspace_item_get_margin (self) * 2), NULL);
	_g_object_unref0 (_tmp1_);
	g_object_set ((GtkWidget*) self, "height-request", gdk_pixbuf_get_height (_tmp3_ = (g_object_get (workspace_item_get_image (self), "pixbuf", &_tmp2_, NULL), _tmp2_)) + (workspace_item_get_margin (self) * 2), NULL);
	_g_object_unref0 (_tmp3_);
}


static gboolean workspace_item_on_leave_notify (WorkspaceItem* self, WorkspaceItem* wi, GdkEventCrossing* event) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (wi != NULL, FALSE);
	if ((*event).state == 0) {
		workspace_item_set_selected (self, FALSE);
	}
	result = FALSE;
	return result;
}


static gboolean workspace_item_on_enter_notify (WorkspaceItem* self, WorkspaceItem* wi, GdkEventCrossing* event) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (wi != NULL, FALSE);
	workspace_item_set_selected (self, TRUE);
	result = FALSE;
	return result;
}


GtkImage* workspace_item_get_image (WorkspaceItem* self) {
	GtkImage* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_image;
	return result;
}


void workspace_item_set_image (WorkspaceItem* self, GtkImage* value) {
	GtkImage* _tmp0_;
	g_return_if_fail (self != NULL);
	if (self->priv->_image != NULL) {
		gtk_container_remove ((GtkContainer*) self, (GtkWidget*) self->priv->_image);
	}
	self->priv->_image = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_image), _tmp0_);
	if (self->priv->_image != NULL) {
		gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->_image);
	}
	workspace_item_update (self);
	g_object_notify ((GObject *) self, "image");
}


gint workspace_item_get_margin (WorkspaceItem* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_margin;
	return result;
}


void workspace_item_set_margin (WorkspaceItem* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_margin = value;
	workspace_item_update (self);
	g_object_notify ((GObject *) self, "margin");
}


gboolean workspace_item_get_selected (WorkspaceItem* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_selected;
	return result;
}


void workspace_item_set_selected (WorkspaceItem* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_selected = value;
	if (self->priv->_selected) {
		gtk_widget_set_state ((GtkWidget*) self, GTK_STATE_SELECTED);
	} else {
		if (!workspace_item_get_current (self)) {
			gtk_widget_set_state ((GtkWidget*) self, GTK_STATE_NORMAL);
		}
	}
	g_object_notify ((GObject *) self, "selected");
}


gboolean workspace_item_get_current (WorkspaceItem* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_current;
	return result;
}


void workspace_item_set_current (WorkspaceItem* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_current = value;
	if (self->priv->_current) {
		gtk_widget_set_state ((GtkWidget*) self, GTK_STATE_SELECTED);
	}
	g_object_notify ((GObject *) self, "current");
}


static gboolean _workspace_item_on_leave_notify_gtk_widget_leave_notify_event (WorkspaceItem* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = workspace_item_on_leave_notify (self, _sender, event);
	return result;
}


static gboolean _workspace_item_on_enter_notify_gtk_widget_enter_notify_event (WorkspaceItem* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = workspace_item_on_enter_notify (self, _sender, event);
	return result;
}


static GObject * workspace_item_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	WorkspaceItem * self;
	parent_class = G_OBJECT_CLASS (workspace_item_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = WORKSPACE_ITEM (obj);
	{
		GtkMenuItem* _tmp1_;
		gtk_widget_set_style ((GtkWidget*) self, gtk_rc_get_style ((GtkWidget*) (_tmp1_ = g_object_ref_sink ((GtkMenuItem*) gtk_menu_item_new ()))));
		_g_object_unref0 (_tmp1_);
		g_signal_connect_object ((GtkWidget*) self, "leave-notify-event", (GCallback) _workspace_item_on_leave_notify_gtk_widget_leave_notify_event, self, 0);
		g_signal_connect_object ((GtkWidget*) self, "enter-notify-event", (GCallback) _workspace_item_on_enter_notify_gtk_widget_enter_notify_event, self, 0);
	}
	return obj;
}


static void workspace_item_class_init (WorkspaceItemClass * klass) {
	workspace_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (WorkspaceItemPrivate));
	G_OBJECT_CLASS (klass)->get_property = workspace_item_get_property;
	G_OBJECT_CLASS (klass)->set_property = workspace_item_set_property;
	G_OBJECT_CLASS (klass)->constructor = workspace_item_constructor;
	G_OBJECT_CLASS (klass)->finalize = workspace_item_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_ITEM_IMAGE, g_param_spec_object ("image", "image", "image", GTK_TYPE_IMAGE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_ITEM_MARGIN, g_param_spec_int ("margin", "margin", "margin", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_ITEM_SELECTED, g_param_spec_boolean ("selected", "selected", "selected", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), WORKSPACE_ITEM_CURRENT, g_param_spec_boolean ("current", "current", "current", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void workspace_item_instance_init (WorkspaceItem * self) {
	self->priv = WORKSPACE_ITEM_GET_PRIVATE (self);
	self->priv->_margin = 6;
	self->priv->_selected = FALSE;
	self->priv->_current = FALSE;
}


static void workspace_item_finalize (GObject* obj) {
	WorkspaceItem * self;
	self = WORKSPACE_ITEM (obj);
	_g_object_unref0 (self->priv->_image);
	G_OBJECT_CLASS (workspace_item_parent_class)->finalize (obj);
}


GType workspace_item_get_type (void) {
	static volatile gsize workspace_item_type_id__volatile = 0;
	if (g_once_init_enter (&workspace_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (WorkspaceItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) workspace_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (WorkspaceItem), 0, (GInstanceInitFunc) workspace_item_instance_init, NULL };
		GType workspace_item_type_id;
		workspace_item_type_id = g_type_register_static (GTK_TYPE_EVENT_BOX, "WorkspaceItem", &g_define_type_info, 0);
		g_once_init_leave (&workspace_item_type_id__volatile, workspace_item_type_id);
	}
	return workspace_item_type_id__volatile;
}


static void workspace_item_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	WorkspaceItem * self;
	self = WORKSPACE_ITEM (object);
	switch (property_id) {
		case WORKSPACE_ITEM_IMAGE:
		g_value_set_object (value, workspace_item_get_image (self));
		break;
		case WORKSPACE_ITEM_MARGIN:
		g_value_set_int (value, workspace_item_get_margin (self));
		break;
		case WORKSPACE_ITEM_SELECTED:
		g_value_set_boolean (value, workspace_item_get_selected (self));
		break;
		case WORKSPACE_ITEM_CURRENT:
		g_value_set_boolean (value, workspace_item_get_current (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void workspace_item_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	WorkspaceItem * self;
	self = WORKSPACE_ITEM (object);
	switch (property_id) {
		case WORKSPACE_ITEM_IMAGE:
		workspace_item_set_image (self, g_value_get_object (value));
		break;
		case WORKSPACE_ITEM_MARGIN:
		workspace_item_set_margin (self, g_value_get_int (value));
		break;
		case WORKSPACE_ITEM_SELECTED:
		workspace_item_set_selected (self, g_value_get_boolean (value));
		break;
		case WORKSPACE_ITEM_CURRENT:
		workspace_item_set_current (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}




