/* gtkextra-gconfdialog.c generated by valac, the Vala compiler
 * generated from gtkextra-gconfdialog.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gconf/gconf-client.h>
#include <stdlib.h>
#include <string.h>
#include <gconf/gconf.h>
#include <float.h>
#include <math.h>
#include <glib/gi18n-lib.h>


#define TYPE_GCONF_DIALOG (gconf_dialog_get_type ())
#define GCONF_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GCONF_DIALOG, GConfDialog))
#define GCONF_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GCONF_DIALOG, GConfDialogClass))
#define IS_GCONF_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GCONF_DIALOG))
#define IS_GCONF_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GCONF_DIALOG))
#define GCONF_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GCONF_DIALOG, GConfDialogClass))

typedef struct _GConfDialog GConfDialog;
typedef struct _GConfDialogClass GConfDialogClass;
typedef struct _GConfDialogPrivate GConfDialogPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _gconf_schema_free0(var) ((var == NULL) ? NULL : (var = (gconf_schema_free (var), NULL)))
#define _gconf_entry_unref0(var) ((var == NULL) ? NULL : (var = (gconf_entry_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _GConfDialog {
	GtkDialog parent_instance;
	GConfDialogPrivate * priv;
};

struct _GConfDialogClass {
	GtkDialogClass parent_class;
};

struct _GConfDialogPrivate {
	GConfClient* _default_client;
	GtkNotebook* notebook;
};


static gpointer gconf_dialog_parent_class = NULL;

GType gconf_dialog_get_type (void) G_GNUC_CONST;
#define GCONF_DIALOG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GCONF_DIALOG, GConfDialogPrivate))
enum  {
	GCONF_DIALOG_DUMMY_PROPERTY
};
GConfDialog* gconf_dialog_new (const char* dialog_title);
GConfDialog* gconf_dialog_construct (GType object_type, const char* dialog_title);
static GtkWidget* gconf_dialog_create_proxy_widget (GConfDialog* self, const char* key, GError** error);
void gconf_dialog_add_key_group (GConfDialog* self, const char* group_name, char** keys, int keys_length1);
static GConfSchema* gconf_dialog_safely_get_schema (GConfDialog* self, GConfEntry* entry);
static void gconf_dialog_onCheckButtonActivated (GConfDialog* self, GtkCheckButton* widget);
static void _gconf_dialog_onCheckButtonActivated_gtk_button_clicked (GtkCheckButton* _sender, gpointer self);
static void gconf_dialog_onSpinButtonValueChanged (GConfDialog* self, GtkSpinButton* widget);
static void _gconf_dialog_onSpinButtonValueChanged_gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self);
static void gconf_dialog_onResetButtonPressed (GConfDialog* self, GtkButton* widget);
static void _gconf_dialog_onResetButtonPressed_gtk_button_clicked (GtkButton* _sender, gpointer self);
static GObject * gconf_dialog_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void gconf_dialog_finalize (GObject* obj);



GConfDialog* gconf_dialog_construct (GType object_type, const char* dialog_title) {
	GConfDialog * self;
	g_return_val_if_fail (dialog_title != NULL, NULL);
	self = g_object_newv (object_type, 0, NULL);
	gtk_window_set_title ((GtkWindow*) self, dialog_title);
	gtk_window_set_icon_name ((GtkWindow*) self, "gtk-preferences");
	return self;
}


GConfDialog* gconf_dialog_new (const char* dialog_title) {
	return gconf_dialog_construct (TYPE_GCONF_DIALOG, dialog_title);
}


void gconf_dialog_add_key_group (GConfDialog* self, const char* group_name, char** keys, int keys_length1) {
	GError * _inner_error_;
	GtkAlignment* alignment;
	GtkVBox* box;
	GtkLabel* label_widget;
	g_return_if_fail (self != NULL);
	g_return_if_fail (group_name != NULL);
	_inner_error_ = NULL;
	alignment = g_object_ref_sink ((GtkAlignment*) gtk_alignment_new (0.0f, 0.0f, 1.0f, 1.0f));
	box = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
	label_widget = g_object_ref_sink ((GtkLabel*) gtk_label_new (group_name));
	g_object_set (alignment, "left-padding", (guint) 10, NULL);
	{
		char** key_collection;
		int key_collection_length1;
		int key_it;
		key_collection = keys;
		key_collection_length1 = keys_length1;
		for (key_it = 0; key_it < keys_length1; key_it = key_it + 1) {
			const char* key;
			key = key_collection[key_it];
			{
				{
					GtkWidget* widget;
					widget = gconf_dialog_create_proxy_widget (self, key, &_inner_error_);
					if (_inner_error_ != NULL) {
						goto __catch21_g_error;
					}
					gtk_box_pack_start ((GtkBox*) box, widget, FALSE, FALSE, (guint) 5);
					_g_object_unref0 (widget);
				}
				goto __finally21;
				__catch21_g_error:
				{
					GError * e;
					e = _inner_error_;
					_inner_error_ = NULL;
					{
						g_warning ("gtkextra-gconfdialog.vala:57: %s", e->message);
						_g_error_free0 (e);
					}
				}
				__finally21:
				if (_inner_error_ != NULL) {
					_g_object_unref0 (label_widget);
					_g_object_unref0 (box);
					_g_object_unref0 (alignment);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
	gtk_container_add ((GtkContainer*) alignment, (GtkWidget*) box);
	gtk_widget_show_all ((GtkWidget*) alignment);
	gtk_widget_show_all ((GtkWidget*) label_widget);
	gtk_notebook_append_page (self->priv->notebook, (GtkWidget*) alignment, (GtkWidget*) label_widget);
	_g_object_unref0 (label_widget);
	_g_object_unref0 (box);
	_g_object_unref0 (alignment);
}


static void _gconf_dialog_onCheckButtonActivated_gtk_button_clicked (GtkCheckButton* _sender, gpointer self) {
	gconf_dialog_onCheckButtonActivated (self, _sender);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _gconf_dialog_onSpinButtonValueChanged_gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self) {
	gconf_dialog_onSpinButtonValueChanged (self, _sender);
}


static void _gconf_dialog_onResetButtonPressed_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	gconf_dialog_onResetButtonPressed (self, _sender);
}


static GtkWidget* gconf_dialog_create_proxy_widget (GConfDialog* self, const char* key, GError** error) {
	GtkWidget* result = NULL;
	GError * _inner_error_;
	GConfEntry* entry;
	GConfSchema* schema;
	const char* tooltip;
	GtkBox* row;
	GtkLabel* label;
	GtkWidget* action_widget;
	GtkWidget* render_widget;
	GConfEntry* _tmp10_;
	GtkButton* reset;
	GConfEntry* _tmp11_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	_inner_error_ = NULL;
	entry = gconf_client_get_entry (self->priv->_default_client, key, NULL, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return NULL;
	}
	schema = gconf_dialog_safely_get_schema (self, entry);
	tooltip = gconf_schema_get_long_desc (schema);
	row = (GtkBox*) g_object_ref_sink ((GtkHBox*) gtk_hbox_new (FALSE, 0));
	label = g_object_ref_sink ((GtkLabel*) gtk_label_new (gconf_schema_get_short_desc (schema)));
	gtk_label_set_justify (label, GTK_JUSTIFY_LEFT);
	gtk_widget_set_tooltip_text ((GtkWidget*) label, tooltip);
	action_widget = NULL;
	render_widget = NULL;
	switch (gconf_schema_get_type (schema)) {
		case GCONF_VALUE_BOOL:
		{
			GtkCheckButton* checkbox;
			gboolean _tmp0_;
			GtkWidget* _tmp1_;
			GtkWidget* _tmp2_;
			checkbox = g_object_ref_sink ((GtkCheckButton*) gtk_check_button_new ());
			_tmp0_ = gconf_client_get_bool (self->priv->_default_client, entry->key, &_inner_error_);
			if (_inner_error_ != NULL) {
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (checkbox);
				_g_object_unref0 (render_widget);
				_g_object_unref0 (action_widget);
				_g_object_unref0 (label);
				_g_object_unref0 (row);
				_gconf_schema_free0 (schema);
				_gconf_entry_unref0 (entry);
				return NULL;
			}
			gtk_toggle_button_set_active ((GtkToggleButton*) checkbox, _tmp0_);
			g_signal_connect_object ((GtkButton*) checkbox, "clicked", (GCallback) _gconf_dialog_onCheckButtonActivated_gtk_button_clicked, self, 0);
			gtk_container_add ((GtkContainer*) checkbox, (GtkWidget*) label);
			render_widget = (_tmp1_ = _g_object_ref0 ((GtkWidget*) checkbox), _g_object_unref0 (render_widget), _tmp1_);
			action_widget = (_tmp2_ = _g_object_ref0 (render_widget), _g_object_unref0 (action_widget), _tmp2_);
			_g_object_unref0 (checkbox);
			break;
		}
		case GCONF_VALUE_STRING:
		{
			GtkEntry* entrybox;
			GtkHBox* box;
			char* _tmp3_;
			char* _tmp4_;
			GtkWidget* _tmp5_;
			GtkWidget* _tmp6_;
			entrybox = g_object_ref_sink ((GtkEntry*) gtk_entry_new ());
			box = g_object_ref_sink ((GtkHBox*) gtk_hbox_new (FALSE, 0));
			_tmp3_ = gconf_client_get_string (self->priv->_default_client, entry->key, &_inner_error_);
			if (_inner_error_ != NULL) {
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (box);
				_g_object_unref0 (entrybox);
				_g_object_unref0 (render_widget);
				_g_object_unref0 (action_widget);
				_g_object_unref0 (label);
				_g_object_unref0 (row);
				_gconf_schema_free0 (schema);
				_gconf_entry_unref0 (entry);
				return NULL;
			}
			gtk_entry_set_text (entrybox, _tmp4_ = _tmp3_);
			_g_free0 (_tmp4_);
			gtk_box_pack_start ((GtkBox*) box, (GtkWidget*) label, FALSE, FALSE, (guint) 2);
			gtk_box_pack_start ((GtkBox*) box, (GtkWidget*) entrybox, FALSE, FALSE, (guint) 2);
			action_widget = (_tmp5_ = _g_object_ref0 ((GtkWidget*) entrybox), _g_object_unref0 (action_widget), _tmp5_);
			render_widget = (_tmp6_ = _g_object_ref0 ((GtkWidget*) box), _g_object_unref0 (render_widget), _tmp6_);
			_g_object_unref0 (box);
			_g_object_unref0 (entrybox);
			break;
		}
		case GCONF_VALUE_INT:
		{
			GtkHBox* box;
			GtkSpinButton* spin;
			gint _tmp7_;
			GtkWidget* _tmp8_;
			GtkWidget* _tmp9_;
			box = g_object_ref_sink ((GtkHBox*) gtk_hbox_new (FALSE, 0));
			spin = g_object_ref_sink ((GtkSpinButton*) gtk_spin_button_new_with_range ((double) (-100), (double) 200, (double) 1));
			_tmp7_ = gconf_client_get_int (self->priv->_default_client, entry->key, &_inner_error_);
			if (_inner_error_ != NULL) {
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (spin);
				_g_object_unref0 (box);
				_g_object_unref0 (render_widget);
				_g_object_unref0 (action_widget);
				_g_object_unref0 (label);
				_g_object_unref0 (row);
				_gconf_schema_free0 (schema);
				_gconf_entry_unref0 (entry);
				return NULL;
			}
			gtk_spin_button_set_value (spin, (double) _tmp7_);
			g_signal_connect_object (spin, "value-changed", (GCallback) _gconf_dialog_onSpinButtonValueChanged_gtk_spin_button_value_changed, self, 0);
			gtk_box_pack_start ((GtkBox*) box, (GtkWidget*) label, FALSE, FALSE, (guint) 2);
			gtk_box_pack_start ((GtkBox*) box, (GtkWidget*) spin, FALSE, FALSE, (guint) 2);
			action_widget = (_tmp8_ = _g_object_ref0 ((GtkWidget*) spin), _g_object_unref0 (action_widget), _tmp8_);
			render_widget = (_tmp9_ = _g_object_ref0 ((GtkWidget*) box), _g_object_unref0 (render_widget), _tmp9_);
			_g_object_unref0 (spin);
			_g_object_unref0 (box);
			break;
		}
		default:
		{
			result = (GtkWidget*) g_object_ref_sink ((GtkEventBox*) gtk_event_box_new ());
			_g_object_unref0 (render_widget);
			_g_object_unref0 (action_widget);
			_g_object_unref0 (label);
			_g_object_unref0 (row);
			_gconf_schema_free0 (schema);
			_gconf_entry_unref0 (entry);
			return result;
		}
	}
	gtk_widget_set_tooltip_text (action_widget, tooltip);
	g_object_set_data_full ((GObject*) action_widget, "gconf-entry", (_tmp10_ = entry, (_tmp10_ == NULL) ? NULL : gconf_entry_ref (_tmp10_), _tmp10_), gconf_entry_unref);
	g_object_set_data_full ((GObject*) action_widget, "gconf-schema", gconf_schema_copy (schema), gconf_schema_free);
	reset = g_object_ref_sink ((GtkButton*) gtk_button_new_from_stock (GTK_STOCK_CLEAR));
	gtk_widget_set_tooltip_text ((GtkWidget*) reset, _ ("Reset to the default value"));
	g_object_set_data_full ((GObject*) reset, "gconf-entry", (_tmp11_ = entry, (_tmp11_ == NULL) ? NULL : gconf_entry_ref (_tmp11_), _tmp11_), gconf_entry_unref);
	g_object_set_data_full ((GObject*) reset, "gconf-schema", gconf_schema_copy (schema), gconf_schema_free);
	g_object_set_data_full ((GObject*) reset, "target", _g_object_ref0 (action_widget), g_object_unref);
	g_signal_connect_object (reset, "clicked", (GCallback) _gconf_dialog_onResetButtonPressed_gtk_button_clicked, self, 0);
	gtk_box_pack_start (row, render_widget, FALSE, FALSE, (guint) 2);
	gtk_box_pack_end (row, (GtkWidget*) reset, FALSE, FALSE, (guint) 2);
	result = (GtkWidget*) row;
	_g_object_unref0 (reset);
	_g_object_unref0 (render_widget);
	_g_object_unref0 (action_widget);
	_g_object_unref0 (label);
	_gconf_schema_free0 (schema);
	_gconf_entry_unref0 (entry);
	return result;
}


static void gconf_dialog_onCheckButtonActivated (GConfDialog* self, GtkCheckButton* widget) {
	GError * _inner_error_;
	GConfEntry* _tmp0_;
	GConfEntry* entry;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	_inner_error_ = NULL;
	entry = (_tmp0_ = (GConfEntry*) g_object_get_data ((GObject*) widget, "gconf-entry"), (_tmp0_ == NULL) ? NULL : gconf_entry_ref (_tmp0_), _tmp0_);
	{
		gconf_client_set_bool (self->priv->_default_client, entry->key, gtk_toggle_button_get_active ((GtkToggleButton*) widget), &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch22_g_error;
		}
	}
	goto __finally22;
	__catch22_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("gtkextra-gconfdialog.vala:135: %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally22:
	if (_inner_error_ != NULL) {
		_gconf_entry_unref0 (entry);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_gconf_entry_unref0 (entry);
}


static void gconf_dialog_onSpinButtonValueChanged (GConfDialog* self, GtkSpinButton* widget) {
	GError * _inner_error_;
	GConfEntry* _tmp0_;
	GConfEntry* entry;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	_inner_error_ = NULL;
	entry = (_tmp0_ = (GConfEntry*) g_object_get_data ((GObject*) widget, "gconf-entry"), (_tmp0_ == NULL) ? NULL : gconf_entry_ref (_tmp0_), _tmp0_);
	{
		gconf_client_set_int (self->priv->_default_client, entry->key, (gint) gtk_spin_button_get_value (widget), &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch23_g_error;
		}
	}
	goto __finally23;
	__catch23_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("gtkextra-gconfdialog.vala:144: %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally23:
	if (_inner_error_ != NULL) {
		_gconf_entry_unref0 (entry);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_gconf_entry_unref0 (entry);
}


static GConfSchema* gconf_dialog_safely_get_schema (GConfDialog* self, GConfEntry* entry) {
	GConfSchema* result = NULL;
	GError * _inner_error_;
	const char* schema_name;
	GConfSchema* rt;
	GConfSchema* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (entry != NULL, NULL);
	_inner_error_ = NULL;
	schema_name = gconf_entry_get_schema_name (entry);
	rt = NULL;
	if (schema_name != NULL) {
		{
			GConfSchema* _tmp0_;
			GConfSchema* _tmp2_;
			GConfSchema* _tmp1_;
			_tmp0_ = gconf_client_get_schema (self->priv->_default_client, schema_name, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch24_g_error;
			}
			rt = (_tmp2_ = gconf_schema_copy (_tmp1_ = _tmp0_), _gconf_schema_free0 (rt), _tmp2_);
			_gconf_schema_free0 (_tmp1_);
			result = rt;
			return result;
		}
		goto __finally24;
		__catch24_g_error:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				_g_error_free0 (e);
			}
		}
		__finally24:
		if (_inner_error_ != NULL) {
			_gconf_schema_free0 (rt);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	g_critical ("gtkextra-gconfdialog.vala:161: schema not found for entry %s", gconf_entry_get_key (entry));
	rt = (_tmp3_ = gconf_schema_new (), _gconf_schema_free0 (rt), _tmp3_);
	gconf_schema_set_short_desc (rt, gconf_entry_get_key (entry));
	gconf_schema_set_long_desc (rt, "This key lacks a schema");
	gconf_schema_set_type (rt, GCONF_VALUE_STRING);
	result = rt;
	return result;
}


static void gconf_dialog_onResetButtonPressed (GConfDialog* self, GtkButton* widget) {
	GConfSchema* schema;
	GConfValue* default_value;
	GtkWidget* target;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	schema = (GConfSchema*) g_object_get_data ((GObject*) widget, "gconf-schema");
	default_value = gconf_schema_get_default_value (schema);
	target = _g_object_ref0 ((GtkWidget*) g_object_get_data ((GObject*) widget, "target"));
	switch (gconf_schema_get_type (schema)) {
		case GCONF_VALUE_BOOL:
		{
			GtkWidget* _tmp0_;
			GtkCheckButton* checkbutton;
			checkbutton = _g_object_ref0 ((_tmp0_ = target, GTK_IS_CHECK_BUTTON (_tmp0_) ? ((GtkCheckButton*) _tmp0_) : NULL));
			gtk_toggle_button_set_active ((GtkToggleButton*) checkbutton, gconf_value_get_bool (default_value));
			_g_object_unref0 (checkbutton);
			break;
		}
		case GCONF_VALUE_STRING:
		{
			GtkWidget* _tmp1_;
			GtkEntry* entrybox;
			entrybox = _g_object_ref0 ((_tmp1_ = target, GTK_IS_ENTRY (_tmp1_) ? ((GtkEntry*) _tmp1_) : NULL));
			gtk_entry_set_text (entrybox, gconf_value_get_string (default_value));
			_g_object_unref0 (entrybox);
			break;
		}
		case GCONF_VALUE_INT:
		{
			GtkWidget* _tmp2_;
			GtkSpinButton* spin;
			spin = _g_object_ref0 ((_tmp2_ = target, GTK_IS_SPIN_BUTTON (_tmp2_) ? ((GtkSpinButton*) _tmp2_) : NULL));
			gtk_spin_button_set_value (spin, (double) gconf_value_get_int (default_value));
			_g_object_unref0 (spin);
			break;
		}
	}
	_g_object_unref0 (target);
}


static GObject * gconf_dialog_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	GConfDialog * self;
	parent_class = G_OBJECT_CLASS (gconf_dialog_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = GCONF_DIALOG (obj);
	{
		GConfClient* _tmp0_;
		self->priv->_default_client = (_tmp0_ = _g_object_ref0 (gconf_client_get_default ()), _g_object_unref0 (self->priv->_default_client), _tmp0_);
		gtk_dialog_add_button ((GtkDialog*) self, GTK_STOCK_CLOSE, (gint) GTK_RESPONSE_CLOSE);
		gtk_dialog_add_button ((GtkDialog*) self, GTK_STOCK_HELP, (gint) GTK_RESPONSE_HELP);
		gtk_container_add ((GtkContainer*) ((GtkDialog*) self)->vbox, (GtkWidget*) self->priv->notebook);
		gtk_widget_show ((GtkWidget*) self->priv->notebook);
	}
	return obj;
}


static void gconf_dialog_class_init (GConfDialogClass * klass) {
	gconf_dialog_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GConfDialogPrivate));
	G_OBJECT_CLASS (klass)->constructor = gconf_dialog_constructor;
	G_OBJECT_CLASS (klass)->finalize = gconf_dialog_finalize;
}


static void gconf_dialog_instance_init (GConfDialog * self) {
	self->priv = GCONF_DIALOG_GET_PRIVATE (self);
	self->priv->notebook = g_object_ref_sink ((GtkNotebook*) gtk_notebook_new ());
}


static void gconf_dialog_finalize (GObject* obj) {
	GConfDialog * self;
	self = GCONF_DIALOG (obj);
	_g_object_unref0 (self->priv->_default_client);
	_g_object_unref0 (self->priv->notebook);
	G_OBJECT_CLASS (gconf_dialog_parent_class)->finalize (obj);
}


GType gconf_dialog_get_type (void) {
	static volatile gsize gconf_dialog_type_id__volatile = 0;
	if (g_once_init_enter (&gconf_dialog_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GConfDialogClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gconf_dialog_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GConfDialog), 0, (GInstanceInitFunc) gconf_dialog_instance_init, NULL };
		GType gconf_dialog_type_id;
		gconf_dialog_type_id = g_type_register_static (GTK_TYPE_DIALOG, "GConfDialog", &g_define_type_info, 0);
		g_once_init_leave (&gconf_dialog_type_id__volatile, gconf_dialog_type_id);
	}
	return gconf_dialog_type_id__volatile;
}




