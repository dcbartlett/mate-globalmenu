/* serializer.c generated by valac, the Vala compiler
 * generated from serializer.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <gdk/gdkx.h>
#include <gdk/gdk.h>
#include <gobject/gvaluecollector.h>


#define TYPE_SERIALIZER (serializer_get_type ())
#define SERIALIZER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SERIALIZER, Serializer))
#define SERIALIZER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SERIALIZER, SerializerClass))
#define IS_SERIALIZER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SERIALIZER))
#define IS_SERIALIZER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SERIALIZER))
#define SERIALIZER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SERIALIZER, SerializerClass))

typedef struct _Serializer Serializer;
typedef struct _SerializerClass SerializerClass;
typedef struct _SerializerPrivate SerializerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _ParamSpecSerializer ParamSpecSerializer;

struct _Serializer {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SerializerPrivate * priv;
	gboolean disable_pixbuf;
	gboolean pretty_print;
};

struct _SerializerClass {
	GTypeClass parent_class;
	void (*finalize) (Serializer *self);
};

struct _SerializerPrivate {
	gboolean hybrid;
	GtkMenuBar* menubar;
	GString* sb;
	GString* label_sb;
	gboolean last_item_empty;
	const char* guessed_type;
	gint level;
	gboolean newline;
};

struct _ParamSpecSerializer {
	GParamSpec parent_instance;
};


static gpointer serializer_parent_class = NULL;

gpointer serializer_ref (gpointer instance);
void serializer_unref (gpointer instance);
GParamSpec* param_spec_serializer (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_serializer (GValue* value, gpointer v_object);
void value_take_serializer (GValue* value, gpointer v_object);
gpointer value_get_serializer (const GValue* value);
GType serializer_get_type (void) G_GNUC_CONST;
#define SERIALIZER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SERIALIZER, SerializerPrivate))
enum  {
	SERIALIZER_DUMMY_PROPERTY
};
Serializer* serializer_new (void);
Serializer* serializer_construct (GType object_type);
static void serializer_visit (Serializer* self, GtkWidget* widget);
char* serializer_to_string (Serializer* self, GtkMenuBar* menubar);
static void serializer_visit_menubar (Serializer* self, GtkMenuBar* menubar);
static void serializer_visit_menu (Serializer* self, GtkMenu* menu);
static void serializer_visit_menuitem (Serializer* self, GtkMenuItem* menuitem);
static void serializer_visit_label (Serializer* self, GtkLabel* label);
static void serializer_visit_image (Serializer* self, GtkImage* image);
static void serializer_visit_container (Serializer* self, GtkContainer* container);
static void serializer_indent (Serializer* self);
static void serializer_linebreak (Serializer* self);
static void serializer_append_icon_attribute (Serializer* self, GtkImage* image);
static char* serializer_pixbuf_encode_b64 (Serializer* self, GdkPixbuf* pixbuf);
static void serializer_finalize (Serializer* obj);
static int _vala_strcmp0 (const char * str1, const char * str2);



Serializer* serializer_construct (GType object_type) {
	Serializer* self;
	self = (Serializer*) g_type_create_instance (object_type);
	return self;
}


Serializer* serializer_new (void) {
	return serializer_construct (TYPE_SERIALIZER);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


char* serializer_to_string (Serializer* self, GtkMenuBar* menubar) {
	char* result = NULL;
	GTimer* timer;
	GtkMenuBar* _tmp0_;
	GString* _tmp1_;
	GString* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (menubar != NULL, NULL);
	timer = g_timer_new ();
	self->priv->menubar = (_tmp0_ = _g_object_ref0 (menubar), _g_object_unref0 (self->priv->menubar), _tmp0_);
	self->priv->sb = (_tmp1_ = g_string_new (""), _g_string_free0 (self->priv->sb), _tmp1_);
	self->priv->label_sb = (_tmp2_ = g_string_new (""), _g_string_free0 (self->priv->label_sb), _tmp2_);
	serializer_visit (self, (GtkWidget*) menubar);
	g_debug ("serializer.vala:13: Serializer consumption = %lf", g_timer_elapsed (timer, NULL));
	result = g_strdup (self->priv->sb->str);
	_g_timer_destroy0 (timer);
	return result;
}


static void serializer_visit (Serializer* self, GtkWidget* widget) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	if (GTK_IS_MENU_BAR (widget)) {
		GtkWidget* _tmp0_;
		serializer_visit_menubar (self, (_tmp0_ = widget, GTK_IS_MENU_BAR (_tmp0_) ? ((GtkMenuBar*) _tmp0_) : NULL));
	} else {
		if (GTK_IS_MENU (widget)) {
			GtkWidget* _tmp1_;
			serializer_visit_menu (self, (_tmp1_ = widget, GTK_IS_MENU (_tmp1_) ? ((GtkMenu*) _tmp1_) : NULL));
		} else {
			if (GTK_IS_MENU_ITEM (widget)) {
				GtkWidget* _tmp2_;
				serializer_visit_menuitem (self, (_tmp2_ = widget, GTK_IS_MENU_ITEM (_tmp2_) ? ((GtkMenuItem*) _tmp2_) : NULL));
			} else {
				if (GTK_IS_LABEL (widget)) {
					GtkWidget* _tmp3_;
					serializer_visit_label (self, (_tmp3_ = widget, GTK_IS_LABEL (_tmp3_) ? ((GtkLabel*) _tmp3_) : NULL));
				} else {
					if (GTK_IS_IMAGE (widget)) {
						GtkWidget* _tmp4_;
						serializer_visit_image (self, (_tmp4_ = widget, GTK_IS_IMAGE (_tmp4_) ? ((GtkImage*) _tmp4_) : NULL));
					} else {
						if (GTK_IS_CONTAINER (widget)) {
							GtkWidget* _tmp5_;
							serializer_visit_container (self, (_tmp5_ = widget, GTK_IS_CONTAINER (_tmp5_) ? ((GtkContainer*) _tmp5_) : NULL));
						}
					}
				}
			}
		}
	}
}


static void serializer_visit_container (Serializer* self, GtkContainer* container) {
	GList* children;
	g_return_if_fail (self != NULL);
	g_return_if_fail (container != NULL);
	children = gtk_container_get_children (container);
	g_debug ("serializer.vala:31: %p has %u children", container, g_list_length (children));
	{
		GList* child_collection;
		GList* child_it;
		child_collection = children;
		for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
			GtkWidget* child;
			child = (GtkWidget*) child_it->data;
			{
				serializer_visit (self, child);
			}
		}
	}
	_g_list_free0 (children);
}


static void serializer_visit_menubar (Serializer* self, GtkMenuBar* menubar) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (menubar != NULL);
	serializer_indent (self);
	g_string_append (self->priv->sb, "<menu>");
	serializer_linebreak (self);
	self->priv->level++;
	serializer_visit_container (self, (GtkContainer*) menubar);
	self->priv->level--;
	serializer_indent (self);
	g_string_append (self->priv->sb, "</menu>");
	serializer_linebreak (self);
}


static void serializer_visit_menu (Serializer* self, GtkMenu* menu) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (menu != NULL);
	serializer_indent (self);
	g_string_append (self->priv->sb, "<menu>");
	serializer_linebreak (self);
	serializer_visit_container (self, (GtkContainer*) menu);
	serializer_indent (self);
	g_string_append (self->priv->sb, "</menu>");
	serializer_linebreak (self);
}


static void serializer_visit_menuitem (Serializer* self, GtkMenuItem* menuitem) {
	char* _tmp0_;
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (menuitem != NULL);
	if (GTK_IS_TEAROFF_MENU_ITEM (menuitem)) {
		return;
	}
	serializer_indent (self);
	g_string_append (self->priv->sb, "<item");
	g_string_append (self->priv->sb, _tmp0_ = g_markup_printf_escaped (" id=\"W%lu\"", (gulong) menuitem));
	_g_free0 (_tmp0_);
	if (self->priv->hybrid) {
		g_string_append (self->priv->sb, " client-side=\"1\"");
	}
	g_string_erase (self->priv->label_sb, (gssize) 0, (gssize) (-1));
	self->priv->last_item_empty = TRUE;
	self->priv->guessed_type = NULL;
	serializer_visit_container (self, (GtkContainer*) menuitem);
	if (self->priv->label_sb->len > 0) {
		char* _tmp1_;
		g_string_append (self->priv->sb, _tmp1_ = g_markup_printf_escaped (" label=\"%s\"", self->priv->label_sb->str));
		_g_free0 (_tmp1_);
		self->priv->last_item_empty = FALSE;
	}
	if (GTK_IS_SEPARATOR_MENU_ITEM (menuitem)) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = gtk_bin_get_child ((GtkBin*) menuitem) == NULL;
	}
	if (_tmp2_) {
		self->priv->guessed_type = "s";
		self->priv->last_item_empty = FALSE;
	}
	if (GTK_IS_IMAGE_MENU_ITEM (menuitem)) {
		GtkMenuItem* _tmp3_;
		GtkWidget* _tmp4_;
		GtkImage* image;
		image = _g_object_ref0 ((_tmp4_ = gtk_image_menu_item_get_image ((_tmp3_ = menuitem, GTK_IS_IMAGE_MENU_ITEM (_tmp3_) ? ((GtkImageMenuItem*) _tmp3_) : NULL)), GTK_IS_IMAGE (_tmp4_) ? ((GtkImage*) _tmp4_) : NULL));
		if (image != NULL) {
			self->priv->guessed_type = "i";
			serializer_append_icon_attribute (self, image);
			self->priv->last_item_empty = FALSE;
		}
		_g_object_unref0 (image);
	}
	if (GTK_IS_CHECK_MENU_ITEM (menuitem)) {
		GtkMenuItem* _tmp5_;
		GtkCheckMenuItem* checkmenuitem;
		checkmenuitem = _g_object_ref0 ((_tmp5_ = menuitem, GTK_IS_CHECK_MENU_ITEM (_tmp5_) ? ((GtkCheckMenuItem*) _tmp5_) : NULL));
		if (gtk_check_menu_item_get_draw_as_radio (checkmenuitem)) {
			self->priv->guessed_type = "r";
		} else {
			self->priv->guessed_type = "c";
		}
		if (!gtk_check_menu_item_get_inconsistent (checkmenuitem)) {
			if (gtk_check_menu_item_get_active (checkmenuitem)) {
				g_string_append (self->priv->sb, " state=\"1\"");
			} else {
				g_string_append (self->priv->sb, " state=\"0\"");
			}
		}
		self->priv->last_item_empty = FALSE;
		_g_object_unref0 (checkmenuitem);
	}
	if (gtk_widget_get_visible ((GtkWidget*) menuitem) == FALSE) {
		g_string_append (self->priv->sb, " visible=\"0\"");
		self->priv->last_item_empty = FALSE;
	}
	if (gtk_widget_get_sensitive ((GtkWidget*) menuitem) == FALSE) {
		g_string_append (self->priv->sb, " sensitive=\"0\"");
	}
	if (self->priv->last_item_empty) {
		g_string_append (self->priv->sb, " visible=\"0\"");
	}
	if (self->priv->guessed_type != NULL) {
		g_string_append_printf (self->priv->sb, " type=\"%s\"", self->priv->guessed_type);
	}
	if (gtk_menu_item_get_submenu (menuitem) == NULL) {
		g_string_append (self->priv->sb, "/>");
		serializer_linebreak (self);
	} else {
		g_string_append_c (self->priv->sb, '>');
		serializer_linebreak (self);
		self->priv->level++;
		if (gtk_menu_item_get_submenu (menuitem) != NULL) {
			serializer_visit_menu (self, gtk_menu_item_get_submenu (menuitem));
		}
		self->priv->level--;
		serializer_indent (self);
		g_string_append (self->priv->sb, "</item>");
		serializer_linebreak (self);
	}
}


static char* string_strip (const char* self) {
	char* result = NULL;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, -1);
	return result;
}


static void serializer_visit_label (Serializer* self, GtkLabel* label) {
	char* label_text;
	g_return_if_fail (self != NULL);
	g_return_if_fail (label != NULL);
	label_text = g_strdup (gtk_label_get_label (label));
	g_string_append (self->priv->label_sb, label_text);
	g_debug ("serializer.vala:143: append text = %s", label_text);
	if (GTK_IS_ACCEL_LABEL (label)) {
		GtkLabel* _tmp0_;
		GtkLabel* _tmp1_;
		char* accel_string;
		gboolean _tmp2_ = FALSE;
		gtk_accel_label_refetch ((_tmp0_ = label, GTK_IS_ACCEL_LABEL (_tmp0_) ? ((GtkAccelLabel*) _tmp0_) : NULL));
		accel_string = string_strip ((_tmp1_ = label, GTK_IS_ACCEL_LABEL (_tmp1_) ? ((GtkAccelLabel*) _tmp1_) : NULL)->accel_string);
		if (string_get_length (accel_string) > 0) {
			_tmp2_ = _vala_strcmp0 (accel_string, "-/-") != 0;
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			char* _tmp3_;
			g_string_append (self->priv->sb, _tmp3_ = g_markup_printf_escaped (" accel=\"%s\"", accel_string));
			_g_free0 (_tmp3_);
		}
		_g_free0 (accel_string);
	}
	_g_free0 (label_text);
}


static void serializer_visit_image (Serializer* self, GtkImage* image) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (image != NULL);
	if (GTK_IS_IMAGE_MENU_ITEM (gtk_widget_get_parent ((GtkWidget*) image))) {
		return;
	}
	self->priv->guessed_type = "i";
	serializer_append_icon_attribute (self, image);
}


static char* serializer_pixbuf_encode_b64 (Serializer* self, GdkPixbuf* pixbuf) {
	char* result = NULL;
	GdkPixdata _tmp0_ = {0};
	GdkPixdata pixdata;
	void* pixel_data;
	guchar* _tmp3_;
	gint _tmp2__length1;
	guchar* _tmp2_;
	gint _tmp1_;
	char* _tmp4_;
	char* rt;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (pixbuf != NULL, NULL);
	pixdata = (_tmp0_.magic = (guint32) 0, _tmp0_);
	pixel_data = gdk_pixdata_from_pixbuf (&pixdata, pixbuf, TRUE);
	rt = (_tmp4_ = (_tmp3_ = (_tmp2_ = gdk_pixdata_serialize (&pixdata, &_tmp1_), _tmp2__length1 = _tmp1_, _tmp2_), g_base64_encode (_tmp3_, _tmp1_)), _tmp2_ = (g_free (_tmp2_), NULL), _tmp4_);
	g_free (pixel_data);
	result = rt;
	return result;
}


static void serializer_append_icon_attribute (Serializer* self, GtkImage* image) {
	char* _tmp1_;
	char* _tmp0_ = NULL;
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (image != NULL);
	if ((_tmp2_ = (_tmp1_ = (g_object_get (image, "file", &_tmp0_, NULL), _tmp0_)) != NULL, _g_free0 (_tmp1_), _tmp2_)) {
		char* _tmp5_;
		char* _tmp4_;
		char* _tmp3_ = NULL;
		g_string_append (self->priv->sb, _tmp5_ = g_markup_printf_escaped (" icon=\"file:%s\"", _tmp4_ = (g_object_get (image, "file", &_tmp3_, NULL), _tmp3_)));
		_g_free0 (_tmp5_);
		_g_free0 (_tmp4_);
	} else {
		if (gtk_image_get_storage_type (image) == GTK_IMAGE_STOCK) {
			char* _tmp6_ = NULL;
			char* stock;
			stock = (g_object_get (image, "stock", &_tmp6_, NULL), _tmp6_);
			if (g_str_has_prefix (stock, "gtk")) {
				char* _tmp7_;
				g_string_append (self->priv->sb, _tmp7_ = g_markup_printf_escaped (" icon=\"%s\"", stock));
				_g_free0 (_tmp7_);
			} else {
				if (!self->disable_pixbuf) {
					char* _tmp9_;
					char* _tmp8_ = NULL;
					GdkPixbuf* _tmp10_;
					GdkPixbuf* pixbuf;
					pixbuf = (_tmp10_ = gtk_widget_render_icon ((GtkWidget*) image, _tmp9_ = (g_object_get (image, "stock", &_tmp8_, NULL), _tmp8_), GTK_ICON_SIZE_MENU, NULL), _g_free0 (_tmp9_), _tmp10_);
					if (pixbuf != NULL) {
						char* _tmp12_;
						char* _tmp11_;
						g_string_append (self->priv->sb, _tmp12_ = g_markup_printf_escaped (" icon=\"pixbuf:%s\"", _tmp11_ = serializer_pixbuf_encode_b64 (self, pixbuf)));
						_g_free0 (_tmp12_);
						_g_free0 (_tmp11_);
					}
					_g_object_unref0 (pixbuf);
				}
			}
			_g_free0 (stock);
		}
		if (gtk_image_get_storage_type (image) == GTK_IMAGE_ICON_NAME) {
			char* _tmp15_;
			char* _tmp14_;
			char* _tmp13_ = NULL;
			g_string_append (self->priv->sb, _tmp15_ = g_markup_printf_escaped (" icon=\"theme:%s\"", _tmp14_ = (g_object_get (image, "icon-name", &_tmp13_, NULL), _tmp13_)));
			_g_free0 (_tmp15_);
			_g_free0 (_tmp14_);
		}
		if (gtk_image_get_storage_type (image) == GTK_IMAGE_PIXBUF) {
			if (!self->disable_pixbuf) {
				GdkPixbuf* _tmp17_;
				GdkPixbuf* _tmp16_ = NULL;
				gboolean _tmp18_;
				if ((_tmp18_ = (_tmp17_ = (g_object_get (image, "pixbuf", &_tmp16_, NULL), _tmp16_)) != NULL, _g_object_unref0 (_tmp17_), _tmp18_)) {
					char* _tmp22_;
					char* _tmp21_;
					GdkPixbuf* _tmp20_;
					GdkPixbuf* _tmp19_ = NULL;
					g_string_append (self->priv->sb, _tmp22_ = g_markup_printf_escaped (" icon=\"pixbuf:%s\"", _tmp21_ = serializer_pixbuf_encode_b64 (self, _tmp20_ = (g_object_get (image, "pixbuf", &_tmp19_, NULL), _tmp19_))));
					_g_free0 (_tmp22_);
					_g_free0 (_tmp21_);
					_g_object_unref0 (_tmp20_);
				}
			}
		}
		if (gtk_image_get_storage_type (image) == GTK_IMAGE_PIXMAP) {
			gulong pixmap_xid;
			gulong mask_xid;
			GdkPixmap* _tmp24_;
			GdkPixmap* _tmp23_ = NULL;
			gboolean _tmp25_;
			GdkPixmap* _tmp29_;
			GdkPixmap* _tmp28_ = NULL;
			gboolean _tmp30_;
			char* _tmp33_;
			pixmap_xid = (gulong) 0;
			mask_xid = (gulong) 0;
			if ((_tmp25_ = (_tmp24_ = (g_object_get (image, "pixmap", &_tmp23_, NULL), _tmp23_)) != NULL, _g_object_unref0 (_tmp24_), _tmp25_)) {
				GdkPixmap* _tmp27_;
				GdkPixmap* _tmp26_ = NULL;
				pixmap_xid = (gulong) gdk_x11_drawable_get_xid ((GdkDrawable*) (_tmp27_ = (g_object_get (image, "pixmap", &_tmp26_, NULL), _tmp26_)));
				_g_object_unref0 (_tmp27_);
			}
			if ((_tmp30_ = (_tmp29_ = (g_object_get (image, "mask", &_tmp28_, NULL), _tmp28_)) != NULL, _g_object_unref0 (_tmp29_), _tmp30_)) {
				GdkPixmap* _tmp32_;
				GdkPixmap* _tmp31_ = NULL;
				mask_xid = (gulong) gdk_x11_drawable_get_xid ((GdkDrawable*) (_tmp32_ = (g_object_get (image, "mask", &_tmp31_, NULL), _tmp31_)));
				_g_object_unref0 (_tmp32_);
			}
			g_string_append (self->priv->sb, _tmp33_ = g_markup_printf_escaped (" icon=\"pixmap:%lu,%lu\"", pixmap_xid, mask_xid));
			_g_free0 (_tmp33_);
		}
	}
}


static void serializer_indent (Serializer* self) {
	g_return_if_fail (self != NULL);
	if (!self->pretty_print) {
		return;
	}
	if (!self->priv->newline) {
		return;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->level)) {
					break;
				}
				g_string_append_c (self->priv->sb, ' ');
			}
		}
	}
	self->priv->newline = FALSE;
}


static void serializer_linebreak (Serializer* self) {
	g_return_if_fail (self != NULL);
	if (!self->pretty_print) {
		return;
	}
	g_string_append_c (self->priv->sb, '\n');
	self->priv->newline = TRUE;
}


static void value_serializer_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_serializer_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		serializer_unref (value->data[0].v_pointer);
	}
}


static void value_serializer_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = serializer_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_serializer_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_serializer_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Serializer* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = serializer_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_serializer_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Serializer** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = serializer_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_serializer (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSerializer* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SERIALIZER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_serializer (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SERIALIZER), NULL);
	return value->data[0].v_pointer;
}


void value_set_serializer (GValue* value, gpointer v_object) {
	Serializer* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SERIALIZER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SERIALIZER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		serializer_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		serializer_unref (old);
	}
}


void value_take_serializer (GValue* value, gpointer v_object) {
	Serializer* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SERIALIZER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SERIALIZER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		serializer_unref (old);
	}
}


static void serializer_class_init (SerializerClass * klass) {
	serializer_parent_class = g_type_class_peek_parent (klass);
	SERIALIZER_CLASS (klass)->finalize = serializer_finalize;
	g_type_class_add_private (klass, sizeof (SerializerPrivate));
}


static void serializer_instance_init (Serializer * self) {
	self->priv = SERIALIZER_GET_PRIVATE (self);
	self->disable_pixbuf = FALSE;
	self->pretty_print = FALSE;
	self->priv->hybrid = FALSE;
	self->ref_count = 1;
}


static void serializer_finalize (Serializer* obj) {
	Serializer * self;
	self = SERIALIZER (obj);
	_g_object_unref0 (self->priv->menubar);
	_g_string_free0 (self->priv->sb);
	_g_string_free0 (self->priv->label_sb);
}


GType serializer_get_type (void) {
	static volatile gsize serializer_type_id__volatile = 0;
	if (g_once_init_enter (&serializer_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_serializer_init, value_serializer_free_value, value_serializer_copy_value, value_serializer_peek_pointer, "p", value_serializer_collect_value, "p", value_serializer_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SerializerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) serializer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Serializer), 0, (GInstanceInitFunc) serializer_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType serializer_type_id;
		serializer_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Serializer", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&serializer_type_id__volatile, serializer_type_id);
	}
	return serializer_type_id__volatile;
}


gpointer serializer_ref (gpointer instance) {
	Serializer* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void serializer_unref (gpointer instance) {
	Serializer* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SERIALIZER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




