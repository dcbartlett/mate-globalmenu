/* item.c generated by valac, the Vala compiler
 * generated from item.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define GNOMENU_TYPE_ITEM_TYPE (gnomenu_item_type_get_type ())

#define GNOMENU_TYPE_ITEM_STATE (gnomenu_item_state_get_type ())

#define GNOMENU_TYPE_ITEM (gnomenu_item_get_type ())
#define GNOMENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_ITEM, GnomenuItem))
#define GNOMENU_IS_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_ITEM))
#define GNOMENU_ITEM_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GNOMENU_TYPE_ITEM, GnomenuItemIface))

typedef struct _GnomenuItem GnomenuItem;
typedef struct _GnomenuItemIface GnomenuItemIface;

#define GNOMENU_TYPE_SHELL (gnomenu_shell_get_type ())
#define GNOMENU_SHELL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_SHELL, GnomenuShell))
#define GNOMENU_IS_SHELL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_SHELL))
#define GNOMENU_SHELL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GNOMENU_TYPE_SHELL, GnomenuShellIface))

typedef struct _GnomenuShell GnomenuShell;
typedef struct _GnomenuShellIface GnomenuShellIface;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

typedef enum  {
	GNOMENU_ITEM_TYPE_NORMAL = 0,
	GNOMENU_ITEM_TYPE_CHECK = 1,
	GNOMENU_ITEM_TYPE_RADIO = 2,
	GNOMENU_ITEM_TYPE_IMAGE = 3,
	GNOMENU_ITEM_TYPE_SEPARATOR = 4,
	GNOMENU_ITEM_TYPE_ARROW = 5,
	GNOMENU_ITEM_TYPE_ICON = 6
} GnomenuItemType;

typedef enum  {
	GNOMENU_ITEM_STATE_UNTOGGLED = 0,
	GNOMENU_ITEM_STATE_TOGGLED = 1,
	GNOMENU_ITEM_STATE_TRISTATE = 2
} GnomenuItemState;

struct _GnomenuShellIface {
	GTypeInterface parent_iface;
	GnomenuItem* (*get_item) (GnomenuShell* self, gint position);
	GnomenuItem* (*get_item_by_id) (GnomenuShell* self, const char* id);
	gint (*get_item_position) (GnomenuShell* self, GnomenuItem* item);
	GnomenuItem* (*get_owner) (GnomenuShell* self);
	gint (*get_length) (GnomenuShell* self);
	void (*set_length) (GnomenuShell* self, gint value);
};

struct _GnomenuItemIface {
	GTypeInterface parent_iface;
	GnomenuShell* (*get_shell) (GnomenuItem* self);
	GnomenuShell* (*get_sub_shell) (GnomenuItem* self);
	gboolean (*get_has_sub_shell) (GnomenuItem* self);
	void (*set_has_sub_shell) (GnomenuItem* self, gboolean value);
	gboolean (*get_client_side_sub_shell) (GnomenuItem* self);
	void (*set_client_side_sub_shell) (GnomenuItem* self, gboolean value);
	const char* (*get_item_id) (GnomenuItem* self);
	void (*set_item_id) (GnomenuItem* self, const char* value);
	GnomenuItemType (*get_item_type) (GnomenuItem* self);
	void (*set_item_type) (GnomenuItem* self, GnomenuItemType value);
	gboolean (*get_item_use_underline) (GnomenuItem* self);
	void (*set_item_use_underline) (GnomenuItem* self, gboolean value);
	gboolean (*get_item_sensitive) (GnomenuItem* self);
	void (*set_item_sensitive) (GnomenuItem* self, gboolean value);
	gboolean (*get_item_visible) (GnomenuItem* self);
	void (*set_item_visible) (GnomenuItem* self, gboolean value);
	GnomenuItemState (*get_item_state) (GnomenuItem* self);
	void (*set_item_state) (GnomenuItem* self, GnomenuItemState value);
	const char* (*get_item_label) (GnomenuItem* self);
	void (*set_item_label) (GnomenuItem* self, const char* value);
	const char* (*get_item_icon) (GnomenuItem* self);
	void (*set_item_icon) (GnomenuItem* self, const char* value);
	const char* (*get_item_accel_text) (GnomenuItem* self);
	void (*set_item_accel_text) (GnomenuItem* self, const char* value);
	const char* (*get_item_font) (GnomenuItem* self);
	void (*set_item_font) (GnomenuItem* self, const char* value);
};



GType gnomenu_item_type_get_type (void) G_GNUC_CONST;
GType gnomenu_item_state_get_type (void) G_GNUC_CONST;
GType gnomenu_shell_get_type (void) G_GNUC_CONST;
GType gnomenu_item_get_type (void) G_GNUC_CONST;
GnomenuShell* gnomenu_item_get_shell (GnomenuItem* self);
GnomenuItem* gnomenu_shell_get_owner (GnomenuShell* self);
gboolean gnomenu_item_is_child_of (GnomenuItem* self, GnomenuItem* possible_parent);
GnomenuItemState gnomenu_item_state_from_string (const char* str);
const char* gnomenu_item_state_to_string (GnomenuItemState state);
GnomenuItemType gnomenu_item_type_from_string (const char* str);
gboolean gnomenu_item_type_has_label (GnomenuItemType type);
const char* gnomenu_item_type_to_string (GnomenuItemType type);
GnomenuShell* gnomenu_item_get_sub_shell (GnomenuItem* self);
gboolean gnomenu_item_get_has_sub_shell (GnomenuItem* self);
void gnomenu_item_set_has_sub_shell (GnomenuItem* self, gboolean value);
gboolean gnomenu_item_get_client_side_sub_shell (GnomenuItem* self);
void gnomenu_item_set_client_side_sub_shell (GnomenuItem* self, gboolean value);
GnomenuShell* gnomenu_shell_get_topmost_shell (GnomenuShell* self);
GnomenuShell* gnomenu_item_get_topmost_shell (GnomenuItem* self);
gint gnomenu_shell_get_item_position (GnomenuShell* self, GnomenuItem* item);
gint gnomenu_item_get_item_position (GnomenuItem* self);
const char* gnomenu_item_get_item_id (GnomenuItem* self);
void gnomenu_item_set_item_id (GnomenuItem* self, const char* value);
GnomenuItemType gnomenu_item_get_item_type (GnomenuItem* self);
void gnomenu_item_set_item_type (GnomenuItem* self, GnomenuItemType value);
gboolean gnomenu_item_get_item_use_underline (GnomenuItem* self);
void gnomenu_item_set_item_use_underline (GnomenuItem* self, gboolean value);
gboolean gnomenu_item_get_item_sensitive (GnomenuItem* self);
void gnomenu_item_set_item_sensitive (GnomenuItem* self, gboolean value);
gboolean gnomenu_item_get_item_visible (GnomenuItem* self);
void gnomenu_item_set_item_visible (GnomenuItem* self, gboolean value);
GnomenuItemState gnomenu_item_get_item_state (GnomenuItem* self);
void gnomenu_item_set_item_state (GnomenuItem* self, GnomenuItemState value);
const char* gnomenu_item_get_item_label (GnomenuItem* self);
void gnomenu_item_set_item_label (GnomenuItem* self, const char* value);
const char* gnomenu_item_get_item_icon (GnomenuItem* self);
void gnomenu_item_set_item_icon (GnomenuItem* self, const char* value);
const char* gnomenu_item_get_item_accel_text (GnomenuItem* self);
void gnomenu_item_set_item_accel_text (GnomenuItem* self, const char* value);
const char* gnomenu_item_get_item_font (GnomenuItem* self);
void gnomenu_item_set_item_font (GnomenuItem* self, const char* value);
char* gnomenu_item_get_item_path_name (GnomenuItem* self);
char* gnomenu_item_get_item_path (GnomenuItem* self);



GType gnomenu_item_type_get_type (void) {
	static volatile gsize gnomenu_item_type_type_id__volatile = 0;
	if (g_once_init_enter (&gnomenu_item_type_type_id__volatile)) {
		static const GEnumValue values[] = {{GNOMENU_ITEM_TYPE_NORMAL, "GNOMENU_ITEM_TYPE_NORMAL", "normal"}, {GNOMENU_ITEM_TYPE_CHECK, "GNOMENU_ITEM_TYPE_CHECK", "check"}, {GNOMENU_ITEM_TYPE_RADIO, "GNOMENU_ITEM_TYPE_RADIO", "radio"}, {GNOMENU_ITEM_TYPE_IMAGE, "GNOMENU_ITEM_TYPE_IMAGE", "image"}, {GNOMENU_ITEM_TYPE_SEPARATOR, "GNOMENU_ITEM_TYPE_SEPARATOR", "separator"}, {GNOMENU_ITEM_TYPE_ARROW, "GNOMENU_ITEM_TYPE_ARROW", "arrow"}, {GNOMENU_ITEM_TYPE_ICON, "GNOMENU_ITEM_TYPE_ICON", "icon"}, {0, NULL, NULL}};
		GType gnomenu_item_type_type_id;
		gnomenu_item_type_type_id = g_enum_register_static ("GnomenuItemType", values);
		g_once_init_leave (&gnomenu_item_type_type_id__volatile, gnomenu_item_type_type_id);
	}
	return gnomenu_item_type_type_id__volatile;
}


GType gnomenu_item_state_get_type (void) {
	static volatile gsize gnomenu_item_state_type_id__volatile = 0;
	if (g_once_init_enter (&gnomenu_item_state_type_id__volatile)) {
		static const GEnumValue values[] = {{GNOMENU_ITEM_STATE_UNTOGGLED, "GNOMENU_ITEM_STATE_UNTOGGLED", "untoggled"}, {GNOMENU_ITEM_STATE_TOGGLED, "GNOMENU_ITEM_STATE_TOGGLED", "toggled"}, {GNOMENU_ITEM_STATE_TRISTATE, "GNOMENU_ITEM_STATE_TRISTATE", "tristate"}, {0, NULL, NULL}};
		GType gnomenu_item_state_type_id;
		gnomenu_item_state_type_id = g_enum_register_static ("GnomenuItemState", values);
		g_once_init_leave (&gnomenu_item_state_type_id__volatile, gnomenu_item_state_type_id);
	}
	return gnomenu_item_state_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


gboolean gnomenu_item_is_child_of (GnomenuItem* self, GnomenuItem* possible_parent) {
	gboolean result = FALSE;
	GnomenuShell* parent_shell;
	GnomenuItem* parent_item;
	g_return_val_if_fail (possible_parent != NULL, FALSE);
	parent_shell = NULL;
	parent_item = _g_object_ref0 (self);
	{
		GnomenuItem* _tmp0_;
		gboolean _tmp1_;
		parent_item = (_tmp0_ = _g_object_ref0 (self), _g_object_unref0 (parent_item), _tmp0_);
		_tmp1_ = TRUE;
		while (TRUE) {
			gboolean _tmp4_ = FALSE;
			if (!_tmp1_) {
				GnomenuShell* _tmp2_;
				GnomenuItem* _tmp3_;
				parent_shell = (_tmp2_ = _g_object_ref0 (gnomenu_item_get_shell (parent_item)), _g_object_unref0 (parent_shell), _tmp2_);
				parent_item = (_tmp3_ = _g_object_ref0 (gnomenu_shell_get_owner (parent_shell)), _g_object_unref0 (parent_item), _tmp3_);
			}
			_tmp1_ = FALSE;
			if (parent_item != NULL) {
				_tmp4_ = parent_item != possible_parent;
			} else {
				_tmp4_ = FALSE;
			}
			if (!_tmp4_) {
				break;
			}
			continue;
		}
	}
	result = parent_item != NULL;
	_g_object_unref0 (parent_item);
	_g_object_unref0 (parent_shell);
	return result;
}


GnomenuItemState gnomenu_item_state_from_string (const char* str) {
	GnomenuItemState result = 0;
	GQuark _tmp1_;
	const char* _tmp0_;
	static GQuark _tmp1__label0 = 0;
	static GQuark _tmp1__label1 = 0;
	static GQuark _tmp1__label2 = 0;
	static GQuark _tmp1__label3 = 0;
	static GQuark _tmp1__label4 = 0;
	static GQuark _tmp1__label5 = 0;
	static GQuark _tmp1__label6 = 0;
	static GQuark _tmp1__label7 = 0;
	_tmp0_ = str;
	_tmp1_ = (NULL == _tmp0_) ? 0 : g_quark_from_string (_tmp0_);
	if ((((_tmp1_ == ((0 != _tmp1__label0) ? _tmp1__label0 : (_tmp1__label0 = g_quark_from_static_string ("true")))) || (_tmp1_ == ((0 != _tmp1__label1) ? _tmp1__label1 : (_tmp1__label1 = g_quark_from_static_string ("toggled"))))) || (_tmp1_ == ((0 != _tmp1__label2) ? _tmp1__label2 : (_tmp1__label2 = g_quark_from_static_string ("t"))))) || (_tmp1_ == ((0 != _tmp1__label3) ? _tmp1__label3 : (_tmp1__label3 = g_quark_from_static_string ("1")))))
	switch (0) {
		default:
		{
			result = GNOMENU_ITEM_STATE_TOGGLED;
			return result;
		}
	} else if ((((_tmp1_ == ((0 != _tmp1__label4) ? _tmp1__label4 : (_tmp1__label4 = g_quark_from_static_string ("false")))) || (_tmp1_ == ((0 != _tmp1__label5) ? _tmp1__label5 : (_tmp1__label5 = g_quark_from_static_string ("untoggled"))))) || (_tmp1_ == ((0 != _tmp1__label6) ? _tmp1__label6 : (_tmp1__label6 = g_quark_from_static_string ("f"))))) || (_tmp1_ == ((0 != _tmp1__label7) ? _tmp1__label7 : (_tmp1__label7 = g_quark_from_static_string ("0")))))
	switch (0) {
		default:
		{
			result = GNOMENU_ITEM_STATE_UNTOGGLED;
			return result;
		}
	} else
	switch (0) {
		default:
		{
			result = GNOMENU_ITEM_STATE_TRISTATE;
			return result;
		}
	}
}


const char* gnomenu_item_state_to_string (GnomenuItemState state) {
	const char* result = NULL;
	switch (state) {
		case GNOMENU_ITEM_STATE_UNTOGGLED:
		{
			result = "untoggled";
			return result;
		}
		case GNOMENU_ITEM_STATE_TOGGLED:
		{
			result = "toggled";
			return result;
		}
		case GNOMENU_ITEM_STATE_TRISTATE:
		{
			result = NULL;
			return result;
		}
	}
	result = NULL;
	return result;
}


GnomenuItemType gnomenu_item_type_from_string (const char* str) {
	GnomenuItemType result = 0;
	GQuark _tmp1_;
	const char* _tmp0_;
	static GQuark _tmp1__label0 = 0;
	static GQuark _tmp1__label1 = 0;
	static GQuark _tmp1__label2 = 0;
	static GQuark _tmp1__label3 = 0;
	static GQuark _tmp1__label4 = 0;
	static GQuark _tmp1__label5 = 0;
	static GQuark _tmp1__label6 = 0;
	static GQuark _tmp1__label7 = 0;
	static GQuark _tmp1__label8 = 0;
	static GQuark _tmp1__label9 = 0;
	static GQuark _tmp1__label10 = 0;
	_tmp0_ = str;
	_tmp1_ = (NULL == _tmp0_) ? 0 : g_quark_from_string (_tmp0_);
	if ((_tmp1_ == ((0 != _tmp1__label0) ? _tmp1__label0 : (_tmp1__label0 = g_quark_from_static_string ("check")))) || (_tmp1_ == ((0 != _tmp1__label1) ? _tmp1__label1 : (_tmp1__label1 = g_quark_from_static_string ("c")))))
	switch (0) {
		default:
		{
			result = GNOMENU_ITEM_TYPE_CHECK;
			return result;
		}
	} else if ((_tmp1_ == ((0 != _tmp1__label2) ? _tmp1__label2 : (_tmp1__label2 = g_quark_from_static_string ("radio")))) || (_tmp1_ == ((0 != _tmp1__label3) ? _tmp1__label3 : (_tmp1__label3 = g_quark_from_static_string ("r")))))
	switch (0) {
		default:
		{
			result = GNOMENU_ITEM_TYPE_RADIO;
			return result;
		}
	} else if ((_tmp1_ == ((0 != _tmp1__label4) ? _tmp1__label4 : (_tmp1__label4 = g_quark_from_static_string ("image")))) || (_tmp1_ == ((0 != _tmp1__label5) ? _tmp1__label5 : (_tmp1__label5 = g_quark_from_static_string ("i")))))
	switch (0) {
		default:
		{
			result = GNOMENU_ITEM_TYPE_IMAGE;
			return result;
		}
	} else if ((_tmp1_ == ((0 != _tmp1__label6) ? _tmp1__label6 : (_tmp1__label6 = g_quark_from_static_string ("arrow")))) || (_tmp1_ == ((0 != _tmp1__label7) ? _tmp1__label7 : (_tmp1__label7 = g_quark_from_static_string ("a")))))
	switch (0) {
		default:
		{
			result = GNOMENU_ITEM_TYPE_ARROW;
			return result;
		}
	} else if ((_tmp1_ == ((0 != _tmp1__label8) ? _tmp1__label8 : (_tmp1__label8 = g_quark_from_static_string ("separator")))) || (_tmp1_ == ((0 != _tmp1__label9) ? _tmp1__label9 : (_tmp1__label9 = g_quark_from_static_string ("s")))))
	switch (0) {
		default:
		{
			result = GNOMENU_ITEM_TYPE_SEPARATOR;
			return result;
		}
	} else if (_tmp1_ == ((0 != _tmp1__label10) ? _tmp1__label10 : (_tmp1__label10 = g_quark_from_static_string ("icon"))))
	switch (0) {
		default:
		{
			result = GNOMENU_ITEM_TYPE_ICON;
			return result;
		}
	} else
	switch (0) {
		default:
		{
			result = GNOMENU_ITEM_TYPE_NORMAL;
			return result;
		}
	}
}


gboolean gnomenu_item_type_has_label (GnomenuItemType type) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	if (type == GNOMENU_ITEM_TYPE_NORMAL) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = type == GNOMENU_ITEM_TYPE_IMAGE;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = type == GNOMENU_ITEM_TYPE_CHECK;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = type == GNOMENU_ITEM_TYPE_RADIO;
	}
	if (_tmp0_) {
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


const char* gnomenu_item_type_to_string (GnomenuItemType type) {
	const char* result = NULL;
	switch (type) {
		case GNOMENU_ITEM_TYPE_CHECK:
		{
			result = "check";
			return result;
		}
		case GNOMENU_ITEM_TYPE_RADIO:
		{
			result = "radio";
			return result;
		}
		case GNOMENU_ITEM_TYPE_NORMAL:
		{
			result = NULL;
			return result;
		}
		case GNOMENU_ITEM_TYPE_IMAGE:
		{
			result = "image";
			return result;
		}
		case GNOMENU_ITEM_TYPE_ICON:
		{
			result = "icon";
			return result;
		}
		case GNOMENU_ITEM_TYPE_ARROW:
		{
			result = "arrow";
			return result;
		}
		case GNOMENU_ITEM_TYPE_SEPARATOR:
		{
			result = "separator";
			return result;
		}
	}
	result = NULL;
	return result;
}


GnomenuShell* gnomenu_item_get_shell (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_shell (self);
}


GnomenuShell* gnomenu_item_get_sub_shell (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_sub_shell (self);
}


gboolean gnomenu_item_get_has_sub_shell (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_has_sub_shell (self);
}


void gnomenu_item_set_has_sub_shell (GnomenuItem* self, gboolean value) {
	GNOMENU_ITEM_GET_INTERFACE (self)->set_has_sub_shell (self, value);
}


gboolean gnomenu_item_get_client_side_sub_shell (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_client_side_sub_shell (self);
}


void gnomenu_item_set_client_side_sub_shell (GnomenuItem* self, gboolean value) {
	GNOMENU_ITEM_GET_INTERFACE (self)->set_client_side_sub_shell (self, value);
}


GnomenuShell* gnomenu_item_get_topmost_shell (GnomenuItem* self) {
	GnomenuShell* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = gnomenu_shell_get_topmost_shell (gnomenu_item_get_shell (self));
	return result;
}


gint gnomenu_item_get_item_position (GnomenuItem* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = gnomenu_shell_get_item_position (gnomenu_item_get_shell (self), self);
	return result;
}


const char* gnomenu_item_get_item_id (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_item_id (self);
}


void gnomenu_item_set_item_id (GnomenuItem* self, const char* value) {
	GNOMENU_ITEM_GET_INTERFACE (self)->set_item_id (self, value);
}


GnomenuItemType gnomenu_item_get_item_type (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_item_type (self);
}


void gnomenu_item_set_item_type (GnomenuItem* self, GnomenuItemType value) {
	GNOMENU_ITEM_GET_INTERFACE (self)->set_item_type (self, value);
}


gboolean gnomenu_item_get_item_use_underline (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_item_use_underline (self);
}


void gnomenu_item_set_item_use_underline (GnomenuItem* self, gboolean value) {
	GNOMENU_ITEM_GET_INTERFACE (self)->set_item_use_underline (self, value);
}


gboolean gnomenu_item_get_item_sensitive (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_item_sensitive (self);
}


void gnomenu_item_set_item_sensitive (GnomenuItem* self, gboolean value) {
	GNOMENU_ITEM_GET_INTERFACE (self)->set_item_sensitive (self, value);
}


gboolean gnomenu_item_get_item_visible (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_item_visible (self);
}


void gnomenu_item_set_item_visible (GnomenuItem* self, gboolean value) {
	GNOMENU_ITEM_GET_INTERFACE (self)->set_item_visible (self, value);
}


GnomenuItemState gnomenu_item_get_item_state (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_item_state (self);
}


void gnomenu_item_set_item_state (GnomenuItem* self, GnomenuItemState value) {
	GNOMENU_ITEM_GET_INTERFACE (self)->set_item_state (self, value);
}


const char* gnomenu_item_get_item_label (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_item_label (self);
}


void gnomenu_item_set_item_label (GnomenuItem* self, const char* value) {
	GNOMENU_ITEM_GET_INTERFACE (self)->set_item_label (self, value);
}


const char* gnomenu_item_get_item_icon (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_item_icon (self);
}


void gnomenu_item_set_item_icon (GnomenuItem* self, const char* value) {
	GNOMENU_ITEM_GET_INTERFACE (self)->set_item_icon (self, value);
}


const char* gnomenu_item_get_item_accel_text (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_item_accel_text (self);
}


void gnomenu_item_set_item_accel_text (GnomenuItem* self, const char* value) {
	GNOMENU_ITEM_GET_INTERFACE (self)->set_item_accel_text (self, value);
}


const char* gnomenu_item_get_item_font (GnomenuItem* self) {
	return GNOMENU_ITEM_GET_INTERFACE (self)->get_item_font (self);
}


void gnomenu_item_set_item_font (GnomenuItem* self, const char* value) {
	GNOMENU_ITEM_GET_INTERFACE (self)->set_item_font (self, value);
}


char* gnomenu_item_get_item_path_name (GnomenuItem* self) {
	char* result;
	g_return_val_if_fail (self != NULL, NULL);
	if (gnomenu_item_get_item_id (self) != NULL) {
		result = g_strdup (gnomenu_item_get_item_id (self));
		return result;
	} else {
		result = g_strdup_printf ("%i", gnomenu_item_get_item_position (self));
		return result;
	}
}


char* gnomenu_item_get_item_path (GnomenuItem* self) {
	char* result;
	GString* sb;
	GnomenuItem* item;
	GnomenuShell* parent;
	char* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	sb = g_string_new ("");
	item = _g_object_ref0 (self);
	parent = _g_object_ref0 (gnomenu_item_get_shell (item));
	g_string_append (sb, _tmp0_ = gnomenu_item_get_item_path_name (self));
	_g_free0 (_tmp0_);
	while (TRUE) {
		GnomenuItem* _tmp2_;
		GnomenuItem* _tmp1_;
		char* _tmp3_;
		GnomenuShell* _tmp4_;
		if (!(parent != NULL)) {
			break;
		}
		item = (_tmp2_ = _g_object_ref0 ((_tmp1_ = gnomenu_shell_get_owner (parent), GNOMENU_IS_ITEM (_tmp1_) ? ((GnomenuItem*) _tmp1_) : NULL)), _g_object_unref0 (item), _tmp2_);
		if (item == NULL) {
			break;
		}
		g_string_prepend_unichar (sb, (gunichar) '/');
		g_string_prepend (sb, _tmp3_ = gnomenu_item_get_item_path_name (item));
		_g_free0 (_tmp3_);
		parent = (_tmp4_ = _g_object_ref0 (gnomenu_item_get_shell (item)), _g_object_unref0 (parent), _tmp4_);
	}
	g_string_prepend_unichar (sb, (gunichar) '/');
	result = g_strdup (sb->str);
	_g_object_unref0 (parent);
	_g_object_unref0 (item);
	_g_string_free0 (sb);
	return result;
}


static void gnomenu_item_base_init (GnomenuItemIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_object_interface_install_property (iface, g_param_spec_object ("shell", "shell", "shell", GNOMENU_TYPE_SHELL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
		g_object_interface_install_property (iface, g_param_spec_object ("sub-shell", "sub-shell", "sub-shell", GNOMENU_TYPE_SHELL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
		g_object_interface_install_property (iface, g_param_spec_boolean ("has-sub-shell", "has-sub-shell", "has-sub-shell", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_boolean ("client-side-sub-shell", "client-side-sub-shell", "client-side-sub-shell", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_string ("item-id", "item-id", "item-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_enum ("item-type", "item-type", "item-type", GNOMENU_TYPE_ITEM_TYPE, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_boolean ("item-use-underline", "item-use-underline", "item-use-underline", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_boolean ("item-sensitive", "item-sensitive", "item-sensitive", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_boolean ("item-visible", "item-visible", "item-visible", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_enum ("item-state", "item-state", "item-state", GNOMENU_TYPE_ITEM_STATE, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_string ("item-label", "item-label", "item-label", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_string ("item-icon", "item-icon", "item-icon", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_string ("item-accel-text", "item-accel-text", "item-accel-text", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_string ("item-font", "item-font", "item-font", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	}
}


GType gnomenu_item_get_type (void) {
	static volatile gsize gnomenu_item_type_id__volatile = 0;
	if (g_once_init_enter (&gnomenu_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GnomenuItemIface), (GBaseInitFunc) gnomenu_item_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType gnomenu_item_type_id;
		gnomenu_item_type_id = g_type_register_static (G_TYPE_INTERFACE, "GnomenuItem", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (gnomenu_item_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&gnomenu_item_type_id__volatile, gnomenu_item_type_id);
	}
	return gnomenu_item_type_id__volatile;
}




