/* shell.c generated by valac, the Vala compiler
 * generated from shell.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define GNOMENU_TYPE_SHELL (gnomenu_shell_get_type ())
#define GNOMENU_SHELL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_SHELL, GnomenuShell))
#define GNOMENU_IS_SHELL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_SHELL))
#define GNOMENU_SHELL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GNOMENU_TYPE_SHELL, GnomenuShellIface))

typedef struct _GnomenuShell GnomenuShell;
typedef struct _GnomenuShellIface GnomenuShellIface;

#define GNOMENU_TYPE_ITEM (gnomenu_item_get_type ())
#define GNOMENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_ITEM, GnomenuItem))
#define GNOMENU_IS_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_ITEM))
#define GNOMENU_ITEM_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GNOMENU_TYPE_ITEM, GnomenuItemIface))

typedef struct _GnomenuItem GnomenuItem;
typedef struct _GnomenuItemIface GnomenuItemIface;

#define GNOMENU_TYPE_ITEM_TYPE (gnomenu_item_type_get_type ())

#define GNOMENU_TYPE_ITEM_STATE (gnomenu_item_state_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

typedef enum  {
	GNOMENU_ITEM_TYPE_NORMAL = 0,
	GNOMENU_ITEM_TYPE_CHECK = 1,
	GNOMENU_ITEM_TYPE_RADIO = 2,
	GNOMENU_ITEM_TYPE_IMAGE = 3,
	GNOMENU_ITEM_TYPE_SEPARATOR = 4,
	GNOMENU_ITEM_TYPE_ARROW = 5,
	GNOMENU_ITEM_TYPE_ICON = 6
} GnomenuItemType;

typedef enum  {
	GNOMENU_ITEM_STATE_UNTOGGLED = 0,
	GNOMENU_ITEM_STATE_TOGGLED = 1,
	GNOMENU_ITEM_STATE_TRISTATE = 2
} GnomenuItemState;

struct _GnomenuItemIface {
	GTypeInterface parent_iface;
	GnomenuShell* (*get_shell) (GnomenuItem* self);
	GnomenuShell* (*get_sub_shell) (GnomenuItem* self);
	gboolean (*get_has_sub_shell) (GnomenuItem* self);
	void (*set_has_sub_shell) (GnomenuItem* self, gboolean value);
	gboolean (*get_client_side_sub_shell) (GnomenuItem* self);
	void (*set_client_side_sub_shell) (GnomenuItem* self, gboolean value);
	const char* (*get_item_id) (GnomenuItem* self);
	void (*set_item_id) (GnomenuItem* self, const char* value);
	GnomenuItemType (*get_item_type) (GnomenuItem* self);
	void (*set_item_type) (GnomenuItem* self, GnomenuItemType value);
	gboolean (*get_item_use_underline) (GnomenuItem* self);
	void (*set_item_use_underline) (GnomenuItem* self, gboolean value);
	gboolean (*get_item_sensitive) (GnomenuItem* self);
	void (*set_item_sensitive) (GnomenuItem* self, gboolean value);
	gboolean (*get_item_visible) (GnomenuItem* self);
	void (*set_item_visible) (GnomenuItem* self, gboolean value);
	GnomenuItemState (*get_item_state) (GnomenuItem* self);
	void (*set_item_state) (GnomenuItem* self, GnomenuItemState value);
	const char* (*get_item_label) (GnomenuItem* self);
	void (*set_item_label) (GnomenuItem* self, const char* value);
	const char* (*get_item_icon) (GnomenuItem* self);
	void (*set_item_icon) (GnomenuItem* self, const char* value);
	const char* (*get_item_accel_text) (GnomenuItem* self);
	void (*set_item_accel_text) (GnomenuItem* self, const char* value);
	const char* (*get_item_font) (GnomenuItem* self);
	void (*set_item_font) (GnomenuItem* self, const char* value);
};

struct _GnomenuShellIface {
	GTypeInterface parent_iface;
	GnomenuItem* (*get_item) (GnomenuShell* self, gint position);
	GnomenuItem* (*get_item_by_id) (GnomenuShell* self, const char* id);
	gint (*get_item_position) (GnomenuShell* self, GnomenuItem* item);
	GnomenuItem* (*get_owner) (GnomenuShell* self);
	gint (*get_length) (GnomenuShell* self);
	void (*set_length) (GnomenuShell* self, gint value);
};



GType gnomenu_item_type_get_type (void) G_GNUC_CONST;
GType gnomenu_item_state_get_type (void) G_GNUC_CONST;
GType gnomenu_item_get_type (void) G_GNUC_CONST;
GType gnomenu_shell_get_type (void) G_GNUC_CONST;
GnomenuItem* gnomenu_shell_get_item (GnomenuShell* self, gint position);
GnomenuItem* gnomenu_shell_get_item_by_id (GnomenuShell* self, const char* id);
gint gnomenu_shell_get_item_position (GnomenuShell* self, GnomenuItem* item);
GnomenuShell* gnomenu_item_get_sub_shell (GnomenuItem* self);
GnomenuItem* gnomenu_shell_get_item_by_path (GnomenuShell* self, const char* path);
GnomenuItem* gnomenu_shell_get_owner (GnomenuShell* self);
gint gnomenu_shell_get_length (GnomenuShell* self);
void gnomenu_shell_set_length (GnomenuShell* self, gint value);
GnomenuShell* gnomenu_item_get_topmost_shell (GnomenuItem* self);
GnomenuShell* gnomenu_shell_get_topmost_shell (GnomenuShell* self);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);



GnomenuItem* gnomenu_shell_get_item (GnomenuShell* self, gint position) {
	return GNOMENU_SHELL_GET_INTERFACE (self)->get_item (self, position);
}


GnomenuItem* gnomenu_shell_get_item_by_id (GnomenuShell* self, const char* id) {
	return GNOMENU_SHELL_GET_INTERFACE (self)->get_item_by_id (self, id);
}


gint gnomenu_shell_get_item_position (GnomenuShell* self, GnomenuItem* item) {
	return GNOMENU_SHELL_GET_INTERFACE (self)->get_item_position (self, item);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


GnomenuItem* gnomenu_shell_get_item_by_path (GnomenuShell* self, const char* path) {
	GnomenuItem* result = NULL;
	char** _tmp1_;
	gint _tokens_size_;
	gint tokens_length1;
	char** _tmp0_;
	char** tokens;
	GnomenuShell* shell;
	g_return_val_if_fail (path != NULL, NULL);
	tokens = (_tmp1_ = _tmp0_ = g_strsplit_set (path, "/", -1), tokens_length1 = _vala_array_length (_tmp0_), _tokens_size_ = tokens_length1, _tmp1_);
	tokens_length1 = (gint) g_strv_length (tokens);
	shell = _g_object_ref0 (self);
	{
		gint i;
		i = 1;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				const char* token;
				GnomenuItem* item;
				GnomenuItem* _tmp3_;
				GnomenuShell* _tmp5_;
				if (!_tmp2_) {
					i++;
				}
				_tmp2_ = FALSE;
				if (!(i < tokens_length1)) {
					break;
				}
				token = tokens[i];
				item = NULL;
				item = (_tmp3_ = gnomenu_shell_get_item_by_id (shell, token), _g_object_unref0 (item), _tmp3_);
				if (item == NULL) {
					const char* endptr;
					gint pos;
					endptr = NULL;
					pos = (gint) g_ascii_strtoll (token, &endptr, 0);
					if (g_utf8_get_char (endptr) == 0) {
						GnomenuItem* _tmp4_;
						item = (_tmp4_ = gnomenu_shell_get_item (shell, pos), _g_object_unref0 (item), _tmp4_);
					}
				}
				if (i == (tokens_length1 - 1)) {
					result = item;
					_g_object_unref0 (shell);
					tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
					return result;
				}
				if (item == NULL) {
					result = NULL;
					_g_object_unref0 (item);
					_g_object_unref0 (shell);
					tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
					return result;
				}
				shell = (_tmp5_ = _g_object_ref0 (gnomenu_item_get_sub_shell (item)), _g_object_unref0 (shell), _tmp5_);
				if (shell == NULL) {
					result = NULL;
					_g_object_unref0 (item);
					_g_object_unref0 (shell);
					tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
					return result;
				}
				_g_object_unref0 (item);
			}
		}
	}
	result = NULL;
	_g_object_unref0 (shell);
	tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


GnomenuItem* gnomenu_shell_get_owner (GnomenuShell* self) {
	return GNOMENU_SHELL_GET_INTERFACE (self)->get_owner (self);
}


gint gnomenu_shell_get_length (GnomenuShell* self) {
	return GNOMENU_SHELL_GET_INTERFACE (self)->get_length (self);
}


void gnomenu_shell_set_length (GnomenuShell* self, gint value) {
	GNOMENU_SHELL_GET_INTERFACE (self)->set_length (self, value);
}


GnomenuShell* gnomenu_shell_get_topmost_shell (GnomenuShell* self) {
	GnomenuShell* result;
	g_return_val_if_fail (self != NULL, NULL);
	if (gnomenu_shell_get_owner (self) != NULL) {
		result = gnomenu_item_get_topmost_shell (gnomenu_shell_get_owner (self));
		return result;
	}
	result = self;
	return result;
}


static void gnomenu_shell_base_init (GnomenuShellIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_object_interface_install_property (iface, g_param_spec_object ("owner", "owner", "owner", GNOMENU_TYPE_ITEM, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
		g_object_interface_install_property (iface, g_param_spec_int ("length", "length", "length", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_signal_new ("activate", GNOMENU_TYPE_SHELL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GNOMENU_TYPE_ITEM);
		g_signal_new ("select", GNOMENU_TYPE_SHELL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GNOMENU_TYPE_ITEM);
		g_signal_new ("deselect", GNOMENU_TYPE_SHELL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GNOMENU_TYPE_ITEM);
	}
}


GType gnomenu_shell_get_type (void) {
	static volatile gsize gnomenu_shell_type_id__volatile = 0;
	if (g_once_init_enter (&gnomenu_shell_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GnomenuShellIface), (GBaseInitFunc) gnomenu_shell_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType gnomenu_shell_type_id;
		gnomenu_shell_type_id = g_type_register_static (G_TYPE_INTERFACE, "GnomenuShell", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (gnomenu_shell_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&gnomenu_shell_type_id__volatile, gnomenu_shell_type_id);
	}
	return gnomenu_shell_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




