/* menulabel.c generated by valac, the Vala compiler
 * generated from menulabel.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <pango/pango.h>
#include <gdk/gdk.h>
#include <float.h>
#include <math.h>


#define GNOMENU_TYPE_MENU_LABEL (gnomenu_menu_label_get_type ())
#define GNOMENU_MENU_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_MENU_LABEL, GnomenuMenuLabel))
#define GNOMENU_MENU_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMENU_TYPE_MENU_LABEL, GnomenuMenuLabelClass))
#define GNOMENU_IS_MENU_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_MENU_LABEL))
#define GNOMENU_IS_MENU_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMENU_TYPE_MENU_LABEL))
#define GNOMENU_MENU_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMENU_TYPE_MENU_LABEL, GnomenuMenuLabelClass))

typedef struct _GnomenuMenuLabel GnomenuMenuLabel;
typedef struct _GnomenuMenuLabelClass GnomenuMenuLabelClass;
typedef struct _GnomenuMenuLabelPrivate GnomenuMenuLabelPrivate;

#define GNOMENU_TYPE_GRAVITY (gnomenu_gravity_get_type ())

#define GNOMENU_MENU_LABEL_TYPE_CHILD_PROP_BAG (gnomenu_menu_label_child_prop_bag_get_type ())
typedef struct _GnomenuMenuLabelChildPropBag GnomenuMenuLabelChildPropBag;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_param_spec_unref0(var) ((var == NULL) ? NULL : (var = (g_param_spec_unref (var), NULL)))

struct _GnomenuMenuLabel {
	GtkContainer parent_instance;
	GnomenuMenuLabelPrivate * priv;
};

struct _GnomenuMenuLabelClass {
	GtkContainerClass parent_class;
};

typedef enum  {
	GNOMENU_GRAVITY_DOWN = 0,
	GNOMENU_GRAVITY_UP = 1,
	GNOMENU_GRAVITY_LEFT = 2,
	GNOMENU_GRAVITY_RIGHT = 3
} GnomenuGravity;

struct _GnomenuMenuLabelChildPropBag {
	PangoAlignment alignment;
	gint padding;
	gboolean ellipsized;
};

struct _GnomenuMenuLabelPrivate {
	GtkLabel* _label_widget;
	GtkLabel* _accel_widget;
	char* _label;
	char* _accel;
	gboolean _use_underline;
	GnomenuGravity _gravity;
	GList* children;
	GHashTable* props;
};


static gpointer gnomenu_menu_label_parent_class = NULL;

GType gnomenu_menu_label_get_type (void) G_GNUC_CONST;
GType gnomenu_gravity_get_type (void) G_GNUC_CONST;
static GType gnomenu_menu_label_child_prop_bag_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GnomenuMenuLabelChildPropBag* gnomenu_menu_label_child_prop_bag_dup (const GnomenuMenuLabelChildPropBag* self);
static void gnomenu_menu_label_child_prop_bag_free (GnomenuMenuLabelChildPropBag* self);
#define GNOMENU_MENU_LABEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GNOMENU_TYPE_MENU_LABEL, GnomenuMenuLabelPrivate))
enum  {
	GNOMENU_MENU_LABEL_DUMMY_PROPERTY,
	GNOMENU_MENU_LABEL_ACCEL,
	GNOMENU_MENU_LABEL_USE_UNDERLINE,
	GNOMENU_MENU_LABEL_MAX_WIDTH_CHARS,
	GNOMENU_MENU_LABEL_LABEL,
	GNOMENU_MENU_LABEL_GRAVITY,
	GNOMENU_MENU_LABEL_LABEL_WIDGET,
	GNOMENU_MENU_LABEL_MNEMONIC_KEYVAL
};
static void _g_free_gdestroy_notify (void* data);
#define GNOMENU_MENU_LABEL_PROP_ALIGNMENT 1234
#define GNOMENU_MENU_LABEL_PROP_PADDING 1235
#define GNOMENU_MENU_LABEL_PROP_ELLIPSIZED 1236
GnomenuMenuLabel* gnomenu_menu_label_new (void);
GnomenuMenuLabel* gnomenu_menu_label_construct (GType object_type);
static gboolean gnomenu_menu_label_real_mnemonic_activate (GtkWidget* base, gboolean arg1);
static gboolean _lambda0_ (GtkWidget* obj, gboolean arg1, GnomenuMenuLabel* self);
static gboolean __lambda0__gtk_widget_mnemonic_activate (GtkWidget* _sender, gboolean group_cycling, gpointer self);
static void gnomenu_menu_label_update_label_gravity (GnomenuMenuLabel* self, GtkLabel* child);
static void gnomenu_menu_label_real_add (GtkContainer* base, GtkWidget* child);
static void gnomenu_menu_label_real_remove (GtkContainer* base, GtkWidget* child);
static void gnomenu_menu_label_real_style_set (GtkWidget* base, GtkStyle* old_style);
static void gnomenu_menu_label_real_forall_internal (GtkContainer* base, gboolean include_internals, GtkCallback callback, void* callback_target);
const char* gnomenu_menu_label_get_label (GnomenuMenuLabel* self);
const char* gnomenu_menu_label_get_accel (GnomenuMenuLabel* self);
static void gnomenu_menu_label_real_map (GtkWidget* base);
GnomenuGravity gnomenu_menu_label_get_gravity (GnomenuMenuLabel* self);
static void gnomenu_menu_label_real_size_request (GtkWidget* base, GtkRequisition* r);
static void gnomenu_menu_label_real_size_allocate (GtkWidget* base, GdkRectangle* a);
static void gnomenu_menu_label_real_get_child_property (GtkContainer* base, GtkWidget* child, guint id, GValue* value, GParamSpec* pspec);
static void gnomenu_menu_label_real_set_child_property (GtkContainer* base, GtkWidget* child, guint id, GValue* value, GParamSpec* pspec);
double gnomenu_gravity_to_text_angle (GnomenuGravity g);
void gnomenu_menu_label_set_accel (GnomenuMenuLabel* self, const char* value);
gboolean gnomenu_menu_label_get_use_underline (GnomenuMenuLabel* self);
void gnomenu_menu_label_set_use_underline (GnomenuMenuLabel* self, gboolean value);
gint gnomenu_menu_label_get_max_width_chars (GnomenuMenuLabel* self);
void gnomenu_menu_label_set_max_width_chars (GnomenuMenuLabel* self, gint value);
void gnomenu_menu_label_set_label (GnomenuMenuLabel* self, const char* value);
void gnomenu_menu_label_set_gravity (GnomenuMenuLabel* self, GnomenuGravity value);
GtkLabel* gnomenu_menu_label_get_label_widget (GnomenuMenuLabel* self);
guint gnomenu_menu_label_get_mnemonic_keyval (GnomenuMenuLabel* self);
static GObject * gnomenu_menu_label_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void gnomenu_menu_label_finalize (GObject* obj);
static void gnomenu_menu_label_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void gnomenu_menu_label_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static int _vala_strcmp0 (const char * str1, const char * str2);



static void _g_free_gdestroy_notify (void* data) {
	g_free (data);
}


GnomenuMenuLabel* gnomenu_menu_label_construct (GType object_type) {
	GnomenuMenuLabel * self;
	self = g_object_newv (object_type, 0, NULL);
	gtk_widget_set_visible ((GtkWidget*) self->priv->_accel_widget, FALSE);
	gtk_widget_set_visible ((GtkWidget*) self->priv->_label_widget, FALSE);
	gtk_label_set_use_underline (self->priv->_label_widget, TRUE);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->_label_widget);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->_accel_widget);
	gtk_container_child_set ((GtkContainer*) self, (GtkWidget*) self->priv->_accel_widget, "alignment", PANGO_ALIGN_RIGHT, NULL, NULL);
	gtk_container_child_set ((GtkContainer*) self, (GtkWidget*) self->priv->_accel_widget, "padding", 10, NULL, NULL);
	gtk_container_child_set ((GtkContainer*) self, (GtkWidget*) self->priv->_label_widget, "ellipsized", TRUE, NULL, NULL);
	gtk_container_child_set ((GtkContainer*) self, (GtkWidget*) self->priv->_label_widget, "padding", 0, NULL, NULL);
	return self;
}


GnomenuMenuLabel* gnomenu_menu_label_new (void) {
	return gnomenu_menu_label_construct (GNOMENU_TYPE_MENU_LABEL);
}


static char* bool_to_string (gboolean self) {
	char* result = NULL;
	if (self) {
		result = g_strdup ("true");
		return result;
	} else {
		result = g_strdup ("false");
		return result;
	}
}


static gboolean gnomenu_menu_label_real_mnemonic_activate (GtkWidget* base, gboolean arg1) {
	GnomenuMenuLabel * self;
	gboolean result = FALSE;
	char* _tmp0_;
	self = (GnomenuMenuLabel*) base;
	g_debug ("menulabel.vala:135: mnemonic_activate %s", _tmp0_ = bool_to_string (arg1));
	_g_free0 (_tmp0_);
	result = gtk_widget_mnemonic_activate ((GtkWidget*) self->priv->_label_widget, arg1);
	return result;
}


static gboolean _lambda0_ (GtkWidget* obj, gboolean arg1, GnomenuMenuLabel* self) {
	gboolean result = FALSE;
	GtkWidget* _tmp0_;
	g_return_val_if_fail (obj != NULL, FALSE);
	g_debug ("menulabel.vala:149: mnemonic activate: %s", gtk_label_get_label ((_tmp0_ = obj, GTK_IS_LABEL (_tmp0_) ? ((GtkLabel*) _tmp0_) : NULL)));
	result = FALSE;
	return result;
}


static gboolean __lambda0__gtk_widget_mnemonic_activate (GtkWidget* _sender, gboolean group_cycling, gpointer self) {
	gboolean result;
	result = _lambda0_ (_sender, group_cycling, self);
	return result;
}


static void gnomenu_menu_label_real_add (GtkContainer* base, GtkWidget* child) {
	GnomenuMenuLabel * self;
	GtkWidget* _tmp0_;
	GtkWidget* _tmp1_;
	self = (GnomenuMenuLabel*) base;
	g_return_if_fail (child != NULL);
	if (!GTK_IS_LABEL (child)) {
		g_warning ("menulabel.vala:145: only GtkLabel is accepted");
		return;
	}
	g_signal_connect_object (child, "mnemonic-activate", (GCallback) __lambda0__gtk_widget_mnemonic_activate, self, 0);
	self->priv->children = g_list_append (self->priv->children, (_tmp0_ = child, GTK_IS_LABEL (_tmp0_) ? ((GtkLabel*) _tmp0_) : NULL));
	gtk_widget_set_parent (child, (GtkWidget*) self);
	g_hash_table_insert (self->priv->props, child, (GnomenuMenuLabelChildPropBag*) g_malloc0 ((gsize) sizeof (GnomenuMenuLabelChildPropBag)));
	gnomenu_menu_label_update_label_gravity (self, (_tmp1_ = child, GTK_IS_LABEL (_tmp1_) ? ((GtkLabel*) _tmp1_) : NULL));
}


static void gnomenu_menu_label_real_remove (GtkContainer* base, GtkWidget* child) {
	GnomenuMenuLabel * self;
	GtkWidget* _tmp0_;
	self = (GnomenuMenuLabel*) base;
	g_return_if_fail (child != NULL);
	self->priv->children = g_list_remove_all (self->priv->children, (_tmp0_ = child, GTK_IS_LABEL (_tmp0_) ? ((GtkLabel*) _tmp0_) : NULL));
	gtk_widget_unparent (child);
	g_hash_table_remove (self->priv->props, child);
}


static void gnomenu_menu_label_real_style_set (GtkWidget* base, GtkStyle* old_style) {
	GnomenuMenuLabel * self;
	self = (GnomenuMenuLabel*) base;
	{
		GList* child_collection;
		GList* child_it;
		child_collection = self->priv->children;
		for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
			GtkLabel* child;
			child = (GtkLabel*) child_it->data;
			{
				gtk_widget_set_style ((GtkWidget*) child, gtk_widget_get_style ((GtkWidget*) self));
			}
		}
	}
}


static void gnomenu_menu_label_real_forall_internal (GtkContainer* base, gboolean include_internals, GtkCallback callback, void* callback_target) {
	GnomenuMenuLabel * self;
	GList* iter;
	self = (GnomenuMenuLabel*) base;
	if (include_internals) {
	}
	iter = self->priv->children;
	while (TRUE) {
		GtkWidget* child;
		if (!(iter != NULL)) {
			break;
		}
		child = (GtkWidget*) ((GtkLabel*) iter->data);
		iter = iter->next;
		callback (child, callback_target);
	}
}


static void gnomenu_menu_label_real_map (GtkWidget* base) {
	GnomenuMenuLabel * self;
	self = (GnomenuMenuLabel*) base;
	if (gnomenu_menu_label_get_label (self) != NULL) {
		gtk_widget_show ((GtkWidget*) self->priv->_label_widget);
	} else {
		gtk_widget_hide ((GtkWidget*) self->priv->_label_widget);
	}
	if (gnomenu_menu_label_get_accel (self) != NULL) {
		gtk_widget_show ((GtkWidget*) self->priv->_accel_widget);
	} else {
		gtk_widget_hide ((GtkWidget*) self->priv->_accel_widget);
	}
	GTK_WIDGET_CLASS (gnomenu_menu_label_parent_class)->map ((GtkWidget*) GTK_CONTAINER (self));
}


static void gnomenu_menu_label_real_size_request (GtkWidget* base, GtkRequisition* r) {
	GnomenuMenuLabel * self;
	GtkRequisition cr = {0};
	self = (GnomenuMenuLabel*) base;
	(*r).width = 0;
	(*r).height = 0;
	{
		GList* child_collection;
		GList* child_it;
		child_collection = self->priv->children;
		for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
			GtkLabel* child;
			child = (GtkLabel*) child_it->data;
			{
				gint padding;
				gtk_widget_size_request ((GtkWidget*) child, &cr);
				if (!gtk_widget_get_visible ((GtkWidget*) child)) {
					continue;
				}
				padding = 0;
				gtk_container_child_get ((GtkContainer*) self, (GtkWidget*) child, "padding", &padding, NULL, NULL);
				switch (gnomenu_menu_label_get_gravity (self)) {
					case GNOMENU_GRAVITY_LEFT:
					case GNOMENU_GRAVITY_RIGHT:
					{
						gint _tmp0_ = 0;
						if ((*r).width > cr.width) {
							_tmp0_ = (*r).width;
						} else {
							_tmp0_ = cr.width;
						}
						(*r).width = _tmp0_;
						(*r).height = (*r).height + (cr.height + padding);
						break;
					}
					case GNOMENU_GRAVITY_UP:
					case GNOMENU_GRAVITY_DOWN:
					{
						gint _tmp1_ = 0;
						if ((*r).height > cr.height) {
							_tmp1_ = (*r).height;
						} else {
							_tmp1_ = cr.height;
						}
						(*r).height = _tmp1_;
						(*r).width = (*r).width + (cr.width + padding);
						break;
					}
				}
			}
		}
	}
}


static void gnomenu_menu_label_real_size_allocate (GtkWidget* base, GdkRectangle* a) {
	GnomenuMenuLabel * self;
	GtkRequisition cr = {0};
	GdkRectangle _tmp0_ = {0};
	GdkRectangle ca;
	gint x;
	gint y;
	gint num_vis;
	gint expand;
	gint remains;
	self = (GnomenuMenuLabel*) base;
	((GtkWidget*) self)->allocation = (GtkAllocation) (*a);
	ca = (_tmp0_.x = 0, _tmp0_.y = 0, _tmp0_.width = 0, _tmp0_.height = 0, _tmp0_);
	x = (*a).x;
	y = (*a).y;
	num_vis = 0;
	expand = 0;
	remains = 0;
	{
		GList* child_collection;
		GList* child_it;
		child_collection = self->priv->children;
		for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
			GtkLabel* child;
			child = (GtkLabel*) child_it->data;
			{
				if (!gtk_widget_get_visible ((GtkWidget*) child)) {
					continue;
				}
				num_vis++;
			}
		}
	}
	switch (gnomenu_menu_label_get_gravity (self)) {
		case GNOMENU_GRAVITY_LEFT:
		case GNOMENU_GRAVITY_RIGHT:
		{
			expand = ((GtkWidget*) self)->allocation.height - ((GtkWidget*) self)->requisition.height;
			remains = ((GtkWidget*) self)->allocation.height;
			break;
		}
		case GNOMENU_GRAVITY_UP:
		case GNOMENU_GRAVITY_DOWN:
		{
			expand = ((GtkWidget*) self)->allocation.width - ((GtkWidget*) self)->requisition.width;
			remains = ((GtkWidget*) self)->allocation.width;
			break;
		}
	}
	if (expand < 0) {
		expand = 0;
	}
	{
		GList* child_collection;
		GList* child_it;
		child_collection = self->priv->children;
		for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
			GtkLabel* child;
			child = (GtkLabel*) child_it->data;
			{
				gint padding;
				PangoAlignment alignment;
				if (!gtk_widget_get_visible ((GtkWidget*) child)) {
					continue;
				}
				gtk_widget_get_child_requisition ((GtkWidget*) child, &cr);
				padding = 0;
				gtk_container_child_get ((GtkContainer*) self, (GtkWidget*) child, "padding", &padding, NULL, NULL);
				alignment = PANGO_ALIGN_LEFT;
				gtk_container_child_get ((GtkContainer*) self, (GtkWidget*) child, "alignment", &alignment, NULL, NULL);
				switch (gnomenu_menu_label_get_gravity (self)) {
					case GNOMENU_GRAVITY_LEFT:
					case GNOMENU_GRAVITY_RIGHT:
					{
						ca.x = x;
						ca.y = y;
						ca.width = (*a).width;
						ca.height = cr.height + (expand / num_vis);
						if (ca.height > remains) {
							ca.height = remains;
						}
						remains = remains - (ca.height + padding);
						if (remains < 1) {
							remains = 1;
						}
						y = y + (ca.height + padding);
						switch (alignment) {
							case PANGO_ALIGN_LEFT:
							{
								break;
							}
							case PANGO_ALIGN_RIGHT:
							{
								ca.y = ca.y + padding;
								break;
							}
							case PANGO_ALIGN_CENTER:
							{
								ca.y = ca.y + (padding / 2);
								break;
							}
						}
						break;
					}
					case GNOMENU_GRAVITY_UP:
					case GNOMENU_GRAVITY_DOWN:
					{
						ca.x = x;
						ca.y = y;
						ca.width = cr.width + (expand / num_vis);
						if (ca.width > remains) {
							ca.width = remains;
						}
						remains = remains - (ca.width + padding);
						if (remains < 1) {
							remains = 1;
						}
						ca.height = (*a).height;
						x = x + (ca.width + padding);
						switch (alignment) {
							case PANGO_ALIGN_LEFT:
							{
								break;
							}
							case PANGO_ALIGN_RIGHT:
							{
								ca.x = ca.x + padding;
								break;
							}
							case PANGO_ALIGN_CENTER:
							{
								ca.x = ca.x + (padding / 2);
								break;
							}
						}
						break;
					}
				}
				gtk_widget_size_allocate ((GtkWidget*) child, &ca);
			}
		}
	}
}


static void gnomenu_menu_label_real_get_child_property (GtkContainer* base, GtkWidget* child, guint id, GValue* value, GParamSpec* pspec) {
	GnomenuMenuLabel * self;
	self = (GnomenuMenuLabel*) base;
	g_return_if_fail (child != NULL);
	g_return_if_fail (pspec != NULL);
	switch (id) {
		case GNOMENU_MENU_LABEL_PROP_ALIGNMENT:
		{
			GnomenuMenuLabelChildPropBag* prop;
			prop = g_hash_table_lookup (self->priv->props, child);
			g_assert (prop != NULL);
			g_value_set_enum (value, (gint) (*prop).alignment);
			break;
		}
		case GNOMENU_MENU_LABEL_PROP_PADDING:
		{
			GnomenuMenuLabelChildPropBag* prop;
			prop = g_hash_table_lookup (self->priv->props, child);
			g_assert (prop != NULL);
			g_value_set_int (value, (*prop).padding);
			break;
		}
		case GNOMENU_MENU_LABEL_PROP_ELLIPSIZED:
		{
			GnomenuMenuLabelChildPropBag* prop;
			prop = g_hash_table_lookup (self->priv->props, child);
			g_assert (prop != NULL);
			g_value_set_boolean (value, (*prop).ellipsized);
			break;
		}
	}
}


static void gnomenu_menu_label_real_set_child_property (GtkContainer* base, GtkWidget* child, guint id, GValue* value, GParamSpec* pspec) {
	GnomenuMenuLabel * self;
	self = (GnomenuMenuLabel*) base;
	g_return_if_fail (child != NULL);
	g_return_if_fail (pspec != NULL);
	switch (id) {
		case GNOMENU_MENU_LABEL_PROP_ALIGNMENT:
		{
			PangoAlignment alignment;
			GnomenuMenuLabelChildPropBag* prop;
			alignment = (PangoAlignment) g_value_get_enum (value);
			prop = g_hash_table_lookup (self->priv->props, child);
			g_assert (prop != NULL);
			if ((*prop).alignment != alignment) {
				GtkWidget* _tmp0_;
				(*prop).alignment = alignment;
				gnomenu_menu_label_update_label_gravity (self, (_tmp0_ = child, GTK_IS_LABEL (_tmp0_) ? ((GtkLabel*) _tmp0_) : NULL));
			}
			break;
		}
		case GNOMENU_MENU_LABEL_PROP_PADDING:
		{
			gint padding;
			GnomenuMenuLabelChildPropBag* prop;
			padding = g_value_get_int (value);
			prop = g_hash_table_lookup (self->priv->props, child);
			g_assert (prop != NULL);
			if ((*prop).padding != padding) {
				(*prop).padding = padding;
				gtk_widget_queue_resize ((GtkWidget*) self);
			}
			break;
		}
		case GNOMENU_MENU_LABEL_PROP_ELLIPSIZED:
		{
			gboolean ellipsized;
			GnomenuMenuLabelChildPropBag* prop;
			ellipsized = g_value_get_boolean (value);
			prop = g_hash_table_lookup (self->priv->props, child);
			g_assert (prop != NULL);
			if ((*prop).ellipsized != ellipsized) {
				gboolean _tmp1_ = FALSE;
				GtkWidget* _tmp2_;
				(*prop).ellipsized = ellipsized;
				if (gtk_label_get_angle ((_tmp2_ = child, GTK_IS_LABEL (_tmp2_) ? ((GtkLabel*) _tmp2_) : NULL)) == 0.0) {
					_tmp1_ = ellipsized;
				} else {
					_tmp1_ = FALSE;
				}
				if (_tmp1_) {
					GtkWidget* _tmp3_;
					gtk_label_set_ellipsize ((_tmp3_ = child, GTK_IS_LABEL (_tmp3_) ? ((GtkLabel*) _tmp3_) : NULL), PANGO_ELLIPSIZE_END);
				} else {
					GtkWidget* _tmp4_;
					gtk_label_set_ellipsize ((_tmp4_ = child, GTK_IS_LABEL (_tmp4_) ? ((GtkLabel*) _tmp4_) : NULL), PANGO_ELLIPSIZE_NONE);
				}
				gtk_widget_queue_resize ((GtkWidget*) self);
			}
			break;
		}
	}
}


static void gnomenu_menu_label_update_label_gravity (GnomenuMenuLabel* self, GtkLabel* child) {
	double text_angle;
	PangoAlignment alignment;
	gboolean ellipsized;
	double al;
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (child != NULL);
	text_angle = gnomenu_gravity_to_text_angle (gnomenu_menu_label_get_gravity (self));
	alignment = PANGO_ALIGN_LEFT;
	ellipsized = FALSE;
	gtk_container_child_get ((GtkContainer*) self, (GtkWidget*) child, "alignment", &alignment, NULL, NULL);
	gtk_container_child_get ((GtkContainer*) self, (GtkWidget*) child, "ellipsized", &ellipsized, NULL, NULL);
	al = 0.0;
	switch (alignment) {
		case PANGO_ALIGN_LEFT:
		{
			al = 0.0;
			break;
		}
		case PANGO_ALIGN_CENTER:
		{
			al = 0.5;
			break;
		}
		case PANGO_ALIGN_RIGHT:
		{
			al = 1.0;
			break;
		}
	}
	switch (self->priv->_gravity) {
		case GNOMENU_GRAVITY_DOWN:
		case GNOMENU_GRAVITY_UP:
		{
			gtk_misc_set_alignment ((GtkMisc*) child, (float) al, (float) 0.5);
			break;
		}
		case GNOMENU_GRAVITY_LEFT:
		case GNOMENU_GRAVITY_RIGHT:
		{
			gtk_misc_set_alignment ((GtkMisc*) child, (float) 0.5, (float) al);
			break;
		}
	}
	gtk_label_set_angle (child, text_angle);
	if (text_angle == 0.0) {
		_tmp0_ = ellipsized;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gtk_label_set_ellipsize (child, PANGO_ELLIPSIZE_END);
	} else {
		gtk_label_set_ellipsize (child, PANGO_ELLIPSIZE_NONE);
	}
}


const char* gnomenu_menu_label_get_accel (GnomenuMenuLabel* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_accel;
	return result;
}


void gnomenu_menu_label_set_accel (GnomenuMenuLabel* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	if (value == NULL) {
		gtk_widget_set_visible ((GtkWidget*) self->priv->_accel_widget, FALSE);
	} else {
		gtk_widget_set_visible ((GtkWidget*) self->priv->_accel_widget, TRUE);
	}
	if (_vala_strcmp0 (self->priv->_accel, value) == 0) {
		return;
	}
	self->priv->_accel = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_accel), _tmp0_);
	if (value != NULL) {
		gtk_label_set_label (self->priv->_accel_widget, value);
	}
	gtk_widget_queue_resize ((GtkWidget*) self);
	g_object_notify ((GObject *) self, "accel");
}


gboolean gnomenu_menu_label_get_use_underline (GnomenuMenuLabel* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_use_underline;
	return result;
}


void gnomenu_menu_label_set_use_underline (GnomenuMenuLabel* self, gboolean value) {
	g_return_if_fail (self != NULL);
	if (self->priv->_use_underline == value) {
		return;
	}
	self->priv->_use_underline = value;
	gtk_label_set_use_underline (self->priv->_label_widget, self->priv->_use_underline);
	g_object_notify ((GObject *) self, "use-underline");
}


gint gnomenu_menu_label_get_max_width_chars (GnomenuMenuLabel* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = gtk_label_get_max_width_chars (self->priv->_label_widget);
	return result;
}


void gnomenu_menu_label_set_max_width_chars (GnomenuMenuLabel* self, gint value) {
	g_return_if_fail (self != NULL);
	gtk_label_set_max_width_chars (self->priv->_label_widget, value);
	g_object_notify ((GObject *) self, "max-width-chars");
}


const char* gnomenu_menu_label_get_label (GnomenuMenuLabel* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_label;
	return result;
}


void gnomenu_menu_label_set_label (GnomenuMenuLabel* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	if (_vala_strcmp0 (self->priv->_label, value) == 0) {
		return;
	}
	self->priv->_label = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_label), _tmp0_);
	if (value == NULL) {
		gtk_widget_set_visible ((GtkWidget*) self->priv->_label_widget, FALSE);
	} else {
		gtk_label_set_text_with_mnemonic (self->priv->_label_widget, value);
		gtk_widget_set_visible ((GtkWidget*) self->priv->_label_widget, TRUE);
	}
	gtk_widget_queue_resize ((GtkWidget*) self);
	g_object_notify ((GObject *) self, "label");
}


GnomenuGravity gnomenu_menu_label_get_gravity (GnomenuMenuLabel* self) {
	GnomenuGravity result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_gravity;
	return result;
}


void gnomenu_menu_label_set_gravity (GnomenuMenuLabel* self, GnomenuGravity value) {
	g_return_if_fail (self != NULL);
	if (self->priv->_gravity == value) {
		return;
	}
	self->priv->_gravity = value;
	{
		GList* child_collection;
		GList* child_it;
		child_collection = self->priv->children;
		for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
			GtkLabel* child;
			child = (GtkLabel*) child_it->data;
			{
				gnomenu_menu_label_update_label_gravity (self, child);
			}
		}
	}
	gtk_widget_queue_resize ((GtkWidget*) self);
	g_object_notify ((GObject *) self, "gravity");
}


GtkLabel* gnomenu_menu_label_get_label_widget (GnomenuMenuLabel* self) {
	GtkLabel* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_label_widget;
	return result;
}


guint gnomenu_menu_label_get_mnemonic_keyval (GnomenuMenuLabel* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = gtk_label_get_mnemonic_keyval (self->priv->_label_widget);
	return result;
}


static GObject * gnomenu_menu_label_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	GnomenuMenuLabel * self;
	parent_class = G_OBJECT_CLASS (gnomenu_menu_label_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = GNOMENU_MENU_LABEL (obj);
	{
		GTK_WIDGET_SET_FLAGS ((GtkWidget*) self, GTK_NO_WINDOW);
	}
	return obj;
}


static GnomenuMenuLabelChildPropBag* gnomenu_menu_label_child_prop_bag_dup (const GnomenuMenuLabelChildPropBag* self) {
	GnomenuMenuLabelChildPropBag* dup;
	dup = g_new0 (GnomenuMenuLabelChildPropBag, 1);
	memcpy (dup, self, sizeof (GnomenuMenuLabelChildPropBag));
	return dup;
}


static void gnomenu_menu_label_child_prop_bag_free (GnomenuMenuLabelChildPropBag* self) {
	g_free (self);
}


static GType gnomenu_menu_label_child_prop_bag_get_type (void) {
	static volatile gsize gnomenu_menu_label_child_prop_bag_type_id__volatile = 0;
	if (g_once_init_enter (&gnomenu_menu_label_child_prop_bag_type_id__volatile)) {
		GType gnomenu_menu_label_child_prop_bag_type_id;
		gnomenu_menu_label_child_prop_bag_type_id = g_boxed_type_register_static ("GnomenuMenuLabelChildPropBag", (GBoxedCopyFunc) gnomenu_menu_label_child_prop_bag_dup, (GBoxedFreeFunc) gnomenu_menu_label_child_prop_bag_free);
		g_once_init_leave (&gnomenu_menu_label_child_prop_bag_type_id__volatile, gnomenu_menu_label_child_prop_bag_type_id);
	}
	return gnomenu_menu_label_child_prop_bag_type_id__volatile;
}


static void gnomenu_menu_label_class_init (GnomenuMenuLabelClass * klass) {
	gnomenu_menu_label_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GnomenuMenuLabelPrivate));
	GTK_WIDGET_CLASS (klass)->mnemonic_activate = gnomenu_menu_label_real_mnemonic_activate;
	GTK_CONTAINER_CLASS (klass)->add = gnomenu_menu_label_real_add;
	GTK_CONTAINER_CLASS (klass)->remove = gnomenu_menu_label_real_remove;
	GTK_WIDGET_CLASS (klass)->style_set = gnomenu_menu_label_real_style_set;
	GTK_CONTAINER_CLASS (klass)->forall = gnomenu_menu_label_real_forall_internal;
	GTK_WIDGET_CLASS (klass)->map = gnomenu_menu_label_real_map;
	GTK_WIDGET_CLASS (klass)->size_request = gnomenu_menu_label_real_size_request;
	GTK_WIDGET_CLASS (klass)->size_allocate = gnomenu_menu_label_real_size_allocate;
	GTK_CONTAINER_CLASS (klass)->get_child_property = gnomenu_menu_label_real_get_child_property;
	GTK_CONTAINER_CLASS (klass)->set_child_property = gnomenu_menu_label_real_set_child_property;
	G_OBJECT_CLASS (klass)->get_property = gnomenu_menu_label_get_property;
	G_OBJECT_CLASS (klass)->set_property = gnomenu_menu_label_set_property;
	G_OBJECT_CLASS (klass)->constructor = gnomenu_menu_label_constructor;
	G_OBJECT_CLASS (klass)->finalize = gnomenu_menu_label_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_LABEL_ACCEL, g_param_spec_string ("accel", "accel", "accel", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_LABEL_USE_UNDERLINE, g_param_spec_boolean ("use-underline", "use-underline", "use-underline", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_LABEL_MAX_WIDTH_CHARS, g_param_spec_int ("max-width-chars", "max-width-chars", "max-width-chars", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_LABEL_LABEL, g_param_spec_string ("label", "label", "label", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_LABEL_GRAVITY, g_param_spec_enum ("gravity", "gravity", "gravity", GNOMENU_TYPE_GRAVITY, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_LABEL_LABEL_WIDGET, g_param_spec_object ("label-widget", "label-widget", "label-widget", GTK_TYPE_LABEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_LABEL_MNEMONIC_KEYVAL, g_param_spec_uint ("mnemonic-keyval", "mnemonic-keyval", "mnemonic-keyval", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	{
		GParamSpecEnum* _tmp0_;
		GParamSpecInt* _tmp1_;
		GParamSpecBoolean* _tmp2_;
		gtk_container_class_install_child_property (GTK_CONTAINER_CLASS (klass), (guint) GNOMENU_MENU_LABEL_PROP_ALIGNMENT, (GParamSpec*) (_tmp0_ = g_param_spec_enum ("alignment", "Alignment", "the alignment of the child", PANGO_TYPE_ALIGNMENT, (gint) PANGO_ALIGN_CENTER, G_PARAM_READABLE | G_PARAM_WRITABLE)));
		_g_param_spec_unref0 (_tmp0_);
		gtk_container_class_install_child_property (GTK_CONTAINER_CLASS (klass), (guint) GNOMENU_MENU_LABEL_PROP_PADDING, (GParamSpec*) (_tmp1_ = g_param_spec_int ("padding", "Padding", "the padding on left, both or right", 0, 1000, 0, G_PARAM_READABLE | G_PARAM_WRITABLE)));
		_g_param_spec_unref0 (_tmp1_);
		gtk_container_class_install_child_property (GTK_CONTAINER_CLASS (klass), (guint) GNOMENU_MENU_LABEL_PROP_ELLIPSIZED, (GParamSpec*) (_tmp2_ = g_param_spec_boolean ("ellipsized", "Ellipsized", "if the child is ellipsized", FALSE, G_PARAM_READABLE | G_PARAM_WRITABLE)));
		_g_param_spec_unref0 (_tmp2_);
	}
}


static void gnomenu_menu_label_instance_init (GnomenuMenuLabel * self) {
	self->priv = GNOMENU_MENU_LABEL_GET_PRIVATE (self);
	self->priv->_label_widget = g_object_ref_sink ((GtkLabel*) gtk_label_new (""));
	self->priv->_accel_widget = g_object_ref_sink ((GtkLabel*) gtk_label_new (""));
	self->priv->props = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, _g_free_gdestroy_notify);
}


static void gnomenu_menu_label_finalize (GObject* obj) {
	GnomenuMenuLabel * self;
	self = GNOMENU_MENU_LABEL (obj);
	_g_object_unref0 (self->priv->_label_widget);
	_g_object_unref0 (self->priv->_accel_widget);
	_g_free0 (self->priv->_label);
	_g_free0 (self->priv->_accel);
	_g_list_free0 (self->priv->children);
	_g_hash_table_unref0 (self->priv->props);
	G_OBJECT_CLASS (gnomenu_menu_label_parent_class)->finalize (obj);
}


GType gnomenu_menu_label_get_type (void) {
	static volatile gsize gnomenu_menu_label_type_id__volatile = 0;
	if (g_once_init_enter (&gnomenu_menu_label_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GnomenuMenuLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnomenu_menu_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GnomenuMenuLabel), 0, (GInstanceInitFunc) gnomenu_menu_label_instance_init, NULL };
		GType gnomenu_menu_label_type_id;
		gnomenu_menu_label_type_id = g_type_register_static (GTK_TYPE_CONTAINER, "GnomenuMenuLabel", &g_define_type_info, 0);
		g_once_init_leave (&gnomenu_menu_label_type_id__volatile, gnomenu_menu_label_type_id);
	}
	return gnomenu_menu_label_type_id__volatile;
}


static void gnomenu_menu_label_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GnomenuMenuLabel * self;
	self = GNOMENU_MENU_LABEL (object);
	switch (property_id) {
		case GNOMENU_MENU_LABEL_ACCEL:
		g_value_set_string (value, gnomenu_menu_label_get_accel (self));
		break;
		case GNOMENU_MENU_LABEL_USE_UNDERLINE:
		g_value_set_boolean (value, gnomenu_menu_label_get_use_underline (self));
		break;
		case GNOMENU_MENU_LABEL_MAX_WIDTH_CHARS:
		g_value_set_int (value, gnomenu_menu_label_get_max_width_chars (self));
		break;
		case GNOMENU_MENU_LABEL_LABEL:
		g_value_set_string (value, gnomenu_menu_label_get_label (self));
		break;
		case GNOMENU_MENU_LABEL_GRAVITY:
		g_value_set_enum (value, gnomenu_menu_label_get_gravity (self));
		break;
		case GNOMENU_MENU_LABEL_LABEL_WIDGET:
		g_value_set_object (value, gnomenu_menu_label_get_label_widget (self));
		break;
		case GNOMENU_MENU_LABEL_MNEMONIC_KEYVAL:
		g_value_set_uint (value, gnomenu_menu_label_get_mnemonic_keyval (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void gnomenu_menu_label_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GnomenuMenuLabel * self;
	self = GNOMENU_MENU_LABEL (object);
	switch (property_id) {
		case GNOMENU_MENU_LABEL_ACCEL:
		gnomenu_menu_label_set_accel (self, g_value_get_string (value));
		break;
		case GNOMENU_MENU_LABEL_USE_UNDERLINE:
		gnomenu_menu_label_set_use_underline (self, g_value_get_boolean (value));
		break;
		case GNOMENU_MENU_LABEL_MAX_WIDTH_CHARS:
		gnomenu_menu_label_set_max_width_chars (self, g_value_get_int (value));
		break;
		case GNOMENU_MENU_LABEL_LABEL:
		gnomenu_menu_label_set_label (self, g_value_get_string (value));
		break;
		case GNOMENU_MENU_LABEL_GRAVITY:
		gnomenu_menu_label_set_gravity (self, g_value_get_enum (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




