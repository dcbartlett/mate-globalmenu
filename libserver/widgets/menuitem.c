/* menuitem.c generated by valac, the Vala compiler
 * generated from menuitem.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <pango/pango.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <glib/gi18n-lib.h>


#define GNOMENU_TYPE_ITEM (gnomenu_item_get_type ())
#define GNOMENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_ITEM, GnomenuItem))
#define GNOMENU_IS_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_ITEM))
#define GNOMENU_ITEM_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GNOMENU_TYPE_ITEM, GnomenuItemIface))

typedef struct _GnomenuItem GnomenuItem;
typedef struct _GnomenuItemIface GnomenuItemIface;

#define GNOMENU_TYPE_SHELL (gnomenu_shell_get_type ())
#define GNOMENU_SHELL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_SHELL, GnomenuShell))
#define GNOMENU_IS_SHELL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_SHELL))
#define GNOMENU_SHELL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GNOMENU_TYPE_SHELL, GnomenuShellIface))

typedef struct _GnomenuShell GnomenuShell;
typedef struct _GnomenuShellIface GnomenuShellIface;

#define GNOMENU_TYPE_ITEM_TYPE (gnomenu_item_type_get_type ())

#define GNOMENU_TYPE_ITEM_STATE (gnomenu_item_state_get_type ())

#define GNOMENU_TYPE_MENU_ITEM (gnomenu_menu_item_get_type ())
#define GNOMENU_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_MENU_ITEM, GnomenuMenuItem))
#define GNOMENU_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMENU_TYPE_MENU_ITEM, GnomenuMenuItemClass))
#define GNOMENU_IS_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_MENU_ITEM))
#define GNOMENU_IS_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMENU_TYPE_MENU_ITEM))
#define GNOMENU_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMENU_TYPE_MENU_ITEM, GnomenuMenuItemClass))

typedef struct _GnomenuMenuItem GnomenuMenuItem;
typedef struct _GnomenuMenuItemClass GnomenuMenuItemClass;
typedef struct _GnomenuMenuItemPrivate GnomenuMenuItemPrivate;

#define GNOMENU_TYPE_MENU (gnomenu_menu_get_type ())
#define GNOMENU_MENU(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_MENU, GnomenuMenu))
#define GNOMENU_MENU_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMENU_TYPE_MENU, GnomenuMenuClass))
#define GNOMENU_IS_MENU(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_MENU))
#define GNOMENU_IS_MENU_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMENU_TYPE_MENU))
#define GNOMENU_MENU_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMENU_TYPE_MENU, GnomenuMenuClass))

typedef struct _GnomenuMenu GnomenuMenu;
typedef struct _GnomenuMenuClass GnomenuMenuClass;

#define GNOMENU_TYPE_GRAVITY (gnomenu_gravity_get_type ())

#define GNOMENU_TYPE_MENU_LABEL (gnomenu_menu_label_get_type ())
#define GNOMENU_MENU_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_MENU_LABEL, GnomenuMenuLabel))
#define GNOMENU_MENU_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMENU_TYPE_MENU_LABEL, GnomenuMenuLabelClass))
#define GNOMENU_IS_MENU_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_MENU_LABEL))
#define GNOMENU_IS_MENU_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMENU_TYPE_MENU_LABEL))
#define GNOMENU_MENU_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMENU_TYPE_MENU_LABEL, GnomenuMenuLabelClass))

typedef struct _GnomenuMenuLabel GnomenuMenuLabel;
typedef struct _GnomenuMenuLabelClass GnomenuMenuLabelClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define GNOMENU_TYPE_MENU_BAR (gnomenu_menu_bar_get_type ())
#define GNOMENU_MENU_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_MENU_BAR, GnomenuMenuBar))
#define GNOMENU_MENU_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMENU_TYPE_MENU_BAR, GnomenuMenuBarClass))
#define GNOMENU_IS_MENU_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_MENU_BAR))
#define GNOMENU_IS_MENU_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMENU_TYPE_MENU_BAR))
#define GNOMENU_MENU_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMENU_TYPE_MENU_BAR, GnomenuMenuBarClass))

typedef struct _GnomenuMenuBar GnomenuMenuBar;
typedef struct _GnomenuMenuBarClass GnomenuMenuBarClass;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _pango_font_description_free0(var) ((var == NULL) ? NULL : (var = (pango_font_description_free (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

#define GNOMENU_TYPE_ADAPTER (gnomenu_adapter_get_type ())
#define GNOMENU_ADAPTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_ADAPTER, GnomenuAdapter))
#define GNOMENU_ADAPTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMENU_TYPE_ADAPTER, GnomenuAdapterClass))
#define GNOMENU_IS_ADAPTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_ADAPTER))
#define GNOMENU_IS_ADAPTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMENU_TYPE_ADAPTER))
#define GNOMENU_ADAPTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMENU_TYPE_ADAPTER, GnomenuAdapterClass))

typedef struct _GnomenuAdapter GnomenuAdapter;
typedef struct _GnomenuAdapterClass GnomenuAdapterClass;
#define _g_param_spec_unref0(var) ((var == NULL) ? NULL : (var = (g_param_spec_unref (var), NULL)))

struct _GnomenuShellIface {
	GTypeInterface parent_iface;
	GnomenuItem* (*get_item) (GnomenuShell* self, gint position);
	GnomenuItem* (*get_item_by_id) (GnomenuShell* self, const char* id);
	gint (*get_item_position) (GnomenuShell* self, GnomenuItem* item);
	GnomenuItem* (*get_owner) (GnomenuShell* self);
	gint (*get_length) (GnomenuShell* self);
	void (*set_length) (GnomenuShell* self, gint value);
};

typedef enum  {
	GNOMENU_ITEM_TYPE_NORMAL = 0,
	GNOMENU_ITEM_TYPE_CHECK = 1,
	GNOMENU_ITEM_TYPE_RADIO = 2,
	GNOMENU_ITEM_TYPE_IMAGE = 3,
	GNOMENU_ITEM_TYPE_SEPARATOR = 4,
	GNOMENU_ITEM_TYPE_ARROW = 5,
	GNOMENU_ITEM_TYPE_ICON = 6
} GnomenuItemType;

typedef enum  {
	GNOMENU_ITEM_STATE_UNTOGGLED = 0,
	GNOMENU_ITEM_STATE_TOGGLED = 1,
	GNOMENU_ITEM_STATE_TRISTATE = 2
} GnomenuItemState;

struct _GnomenuItemIface {
	GTypeInterface parent_iface;
	GnomenuShell* (*get_shell) (GnomenuItem* self);
	GnomenuShell* (*get_sub_shell) (GnomenuItem* self);
	gboolean (*get_has_sub_shell) (GnomenuItem* self);
	void (*set_has_sub_shell) (GnomenuItem* self, gboolean value);
	gboolean (*get_client_side_sub_shell) (GnomenuItem* self);
	void (*set_client_side_sub_shell) (GnomenuItem* self, gboolean value);
	const char* (*get_item_id) (GnomenuItem* self);
	void (*set_item_id) (GnomenuItem* self, const char* value);
	GnomenuItemType (*get_item_type) (GnomenuItem* self);
	void (*set_item_type) (GnomenuItem* self, GnomenuItemType value);
	gboolean (*get_item_use_underline) (GnomenuItem* self);
	void (*set_item_use_underline) (GnomenuItem* self, gboolean value);
	gboolean (*get_item_sensitive) (GnomenuItem* self);
	void (*set_item_sensitive) (GnomenuItem* self, gboolean value);
	gboolean (*get_item_visible) (GnomenuItem* self);
	void (*set_item_visible) (GnomenuItem* self, gboolean value);
	GnomenuItemState (*get_item_state) (GnomenuItem* self);
	void (*set_item_state) (GnomenuItem* self, GnomenuItemState value);
	const char* (*get_item_label) (GnomenuItem* self);
	void (*set_item_label) (GnomenuItem* self, const char* value);
	const char* (*get_item_icon) (GnomenuItem* self);
	void (*set_item_icon) (GnomenuItem* self, const char* value);
	const char* (*get_item_accel_text) (GnomenuItem* self);
	void (*set_item_accel_text) (GnomenuItem* self, const char* value);
	const char* (*get_item_font) (GnomenuItem* self);
	void (*set_item_font) (GnomenuItem* self, const char* value);
};

struct _GnomenuMenuItem {
	GtkMenuItem parent_instance;
	GnomenuMenuItemPrivate * priv;
	GnomenuMenu* _submenu_cache;
};

struct _GnomenuMenuItemClass {
	GtkMenuItemClass parent_class;
};

typedef enum  {
	GNOMENU_GRAVITY_DOWN = 0,
	GNOMENU_GRAVITY_UP = 1,
	GNOMENU_GRAVITY_LEFT = 2,
	GNOMENU_GRAVITY_RIGHT = 3
} GnomenuGravity;

struct _GnomenuMenuItemPrivate {
	gint _max_width_chars;
	gboolean _has_sub_shell;
	gboolean _client_side_sub_shell;
	gboolean _item_visible;
	gboolean _show_underline;
	gboolean disposed;
	gboolean _truncated;
	char* _font;
	char* _label;
	char* _icon;
	char* _accel_text;
	char* _id;
	GnomenuGravity _gravity;
	GnomenuItemType _item_type;
	GnomenuItemState _item_state;
	gboolean _use_underline;
	GtkImage* _cached_image_widget;
	GtkArrow* _cached_arrow_widget;
	GnomenuMenuLabel* _cached_label_widget;
	GtkImage* _image_widget;
	GtkImage* _icon_widget;
};


static gint gnomenu_menu_item_icon_width;
static gint gnomenu_menu_item_icon_width = 0;
static gint gnomenu_menu_item_icon_height;
static gint gnomenu_menu_item_icon_height = 0;
static gpointer gnomenu_menu_item_parent_class = NULL;
static GnomenuItemIface* gnomenu_menu_item_gnomenu_item_parent_iface = NULL;

GType gnomenu_shell_get_type (void) G_GNUC_CONST;
GType gnomenu_item_type_get_type (void) G_GNUC_CONST;
GType gnomenu_item_state_get_type (void) G_GNUC_CONST;
GType gnomenu_item_get_type (void) G_GNUC_CONST;
GType gnomenu_menu_item_get_type (void) G_GNUC_CONST;
GType gnomenu_menu_get_type (void) G_GNUC_CONST;
GType gnomenu_gravity_get_type (void) G_GNUC_CONST;
GType gnomenu_menu_label_get_type (void) G_GNUC_CONST;
#define GNOMENU_MENU_ITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GNOMENU_TYPE_MENU_ITEM, GnomenuMenuItemPrivate))
enum  {
	GNOMENU_MENU_ITEM_DUMMY_PROPERTY,
	GNOMENU_MENU_ITEM_MAX_WIDTH_CHARS,
	GNOMENU_MENU_ITEM_SHELL,
	GNOMENU_MENU_ITEM_SUB_SHELL,
	GNOMENU_MENU_ITEM_HAS_SUB_SHELL,
	GNOMENU_MENU_ITEM_CLIENT_SIDE_SUB_SHELL,
	GNOMENU_MENU_ITEM_ITEM_ID,
	GNOMENU_MENU_ITEM_ITEM_LABEL,
	GNOMENU_MENU_ITEM_ITEM_ICON,
	GNOMENU_MENU_ITEM_ITEM_ACCEL_TEXT,
	GNOMENU_MENU_ITEM_ITEM_FONT,
	GNOMENU_MENU_ITEM_ITEM_TYPE,
	GNOMENU_MENU_ITEM_ITEM_USE_UNDERLINE,
	GNOMENU_MENU_ITEM_ITEM_STATE,
	GNOMENU_MENU_ITEM_ITEM_VISIBLE,
	GNOMENU_MENU_ITEM_ITEM_SENSITIVE,
	GNOMENU_MENU_ITEM_GRAVITY,
	GNOMENU_MENU_ITEM_SHOW_UNDERLINE,
	GNOMENU_MENU_ITEM_TRUNCATED,
	GNOMENU_MENU_ITEM_IMAGE
};
GnomenuMenu* gnomenu_menu_new (void);
GnomenuMenu* gnomenu_menu_construct (GType object_type);
GnomenuMenuItem* gnomenu_menu_item_new (void);
GnomenuMenuItem* gnomenu_menu_item_construct (GType object_type);
static void gnomenu_menu_item_real_dispose (GObject* base);
static void gnomenu_menu_item_maybe_connect_cached_submenu (GnomenuMenuItem* self);
static gboolean gnomenu_menu_item_get__show_image (GnomenuMenuItem* self);
GtkImage* gnomenu_menu_item_get_image (GnomenuMenuItem* self);
static GtkPackDirection gnomenu_menu_item_get_pack_direction (GnomenuMenuItem* self);
static void gnomenu_menu_item_real_toggle_size_request (GtkMenuItem* base, void* requisition);
GtkShadowType gnomenu_menu_item_item_state_to_shadow_type (GnomenuItemState state);
static gboolean gnomenu_menu_item_real_expose_event (GtkWidget* base, GdkEventExpose* event);
static void gnomenu_menu_item_real_forall_internal (GtkContainer* base, gboolean include_internals, GtkCallback callback, void* callback_target);
GnomenuShell* gnomenu_item_get_topmost_shell (GnomenuItem* self);
GType gnomenu_menu_bar_get_type (void) G_GNUC_CONST;
void gnomenu_menu_bar_emit_activate (GnomenuMenuBar* self, GnomenuMenuItem* item);
char* gnomenu_item_get_item_path (GnomenuItem* self);
static void gnomenu_menu_item_real_activate (GtkMenuItem* base);
void gnomenu_menu_bar_emit_select (GnomenuMenuBar* self, GnomenuMenuItem* item);
static void gnomenu_menu_item_real_select (GtkItem* base);
void gnomenu_menu_bar_emit_deselect (GnomenuMenuBar* self, GnomenuMenuItem* item);
static void gnomenu_menu_item_real_deselect (GtkItem* base);
static void gnomenu_menu_item_update_show_image (GnomenuMenuItem* self);
static void gnomenu_menu_item_show_image_notify_r (GtkWidget* widget, GtkSettings* settings);
static void gnomenu_menu_item_show_image_notify (GnomenuMenuItem* self, GtkSettings* settings, GParamSpec* pspec);
static void _gnomenu_menu_item_show_image_notify_g_object_notify (GtkSettings* _sender, GParamSpec* pspec, gpointer self);
static void gnomenu_menu_item_real_screen_changed (GtkWidget* base, GdkScreen* previous_screen);
static void gnomenu_menu_item_real_size_request (GtkWidget* base, GtkRequisition* req);
static void gnomenu_menu_item_real_size_allocate (GtkWidget* base, GdkRectangle* a);
static void gnomenu_menu_item_update_font (GnomenuMenuItem* self);
static char* gnomenu_menu_item_remove_underlines (GnomenuMenuItem* self, const char* s);
gboolean gnomenu_item_type_has_label (GnomenuItemType type);
static GnomenuMenuLabel* gnomenu_menu_item_get_label_widget (GnomenuMenuItem* self);
void gnomenu_menu_label_set_label (GnomenuMenuLabel* self, const char* value);
void gnomenu_menu_label_set_accel (GnomenuMenuLabel* self, const char* value);
void gnomenu_menu_label_set_max_width_chars (GnomenuMenuLabel* self, gint value);
static void gnomenu_menu_item_update_label_text (GnomenuMenuItem* self);
void gnomenu_menu_label_set_use_underline (GnomenuMenuLabel* self, gboolean value);
static void gnomenu_menu_item_update_label_underline (GnomenuMenuItem* self);
static void gnomenu_menu_item_update_image (GnomenuMenuItem* self);
static void gnomenu_menu_item_real_parent_set (GtkWidget* base, GtkWidget* old_parent);
GnomenuGravity gnomenu_menu_item_get_gravity (GnomenuMenuItem* self);
void gnomenu_menu_label_set_gravity (GnomenuMenuLabel* self, GnomenuGravity value);
static void gnomenu_menu_item_create_labels (GnomenuMenuItem* self);
static void gnomenu_menu_item_remove_child (GnomenuMenuItem* self);
static void gnomenu_menu_item_update_arrow_type (GnomenuMenuItem* self);
static void gnomenu_menu_item_create_arrow (GnomenuMenuItem* self);
GtkArrowType gnomenu_gravity_to_arrow_type (GnomenuGravity g);
gint gnomenu_menu_item_get_max_width_chars (GnomenuMenuItem* self);
void gnomenu_menu_item_set_max_width_chars (GnomenuMenuItem* self, gint value);
GType gnomenu_adapter_get_type (void) G_GNUC_CONST;
GnomenuAdapter* gnomenu_adapter_get_adapter (GtkMenuShell* gtk_shell);
void gnomenu_menu_item_set_gravity (GnomenuMenuItem* self, GnomenuGravity value);
gboolean gnomenu_menu_item_get_show_underline (GnomenuMenuItem* self);
void gnomenu_menu_item_set_show_underline (GnomenuMenuItem* self, gboolean value);
gboolean gnomenu_menu_item_get_truncated (GnomenuMenuItem* self);
void gnomenu_menu_item_set_truncated (GnomenuMenuItem* self, gboolean value);
GnomenuMenuLabel* gnomenu_menu_label_new (void);
GnomenuMenuLabel* gnomenu_menu_label_construct (GType object_type);
static GObject * gnomenu_menu_item_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void gnomenu_menu_item_finalize (GObject* obj);
GnomenuShell* gnomenu_item_get_shell (GnomenuItem* self);
GnomenuShell* gnomenu_item_get_sub_shell (GnomenuItem* self);
gboolean gnomenu_item_get_has_sub_shell (GnomenuItem* self);
gboolean gnomenu_item_get_client_side_sub_shell (GnomenuItem* self);
const char* gnomenu_item_get_item_id (GnomenuItem* self);
const char* gnomenu_item_get_item_label (GnomenuItem* self);
const char* gnomenu_item_get_item_icon (GnomenuItem* self);
const char* gnomenu_item_get_item_accel_text (GnomenuItem* self);
const char* gnomenu_item_get_item_font (GnomenuItem* self);
GnomenuItemType gnomenu_item_get_item_type (GnomenuItem* self);
gboolean gnomenu_item_get_item_use_underline (GnomenuItem* self);
GnomenuItemState gnomenu_item_get_item_state (GnomenuItem* self);
gboolean gnomenu_item_get_item_visible (GnomenuItem* self);
gboolean gnomenu_item_get_item_sensitive (GnomenuItem* self);
static void gnomenu_menu_item_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
void gnomenu_item_set_has_sub_shell (GnomenuItem* self, gboolean value);
void gnomenu_item_set_client_side_sub_shell (GnomenuItem* self, gboolean value);
void gnomenu_item_set_item_id (GnomenuItem* self, const char* value);
void gnomenu_item_set_item_label (GnomenuItem* self, const char* value);
void gnomenu_item_set_item_icon (GnomenuItem* self, const char* value);
void gnomenu_item_set_item_accel_text (GnomenuItem* self, const char* value);
void gnomenu_item_set_item_font (GnomenuItem* self, const char* value);
void gnomenu_item_set_item_type (GnomenuItem* self, GnomenuItemType value);
void gnomenu_item_set_item_use_underline (GnomenuItem* self, gboolean value);
void gnomenu_item_set_item_state (GnomenuItem* self, GnomenuItemState value);
void gnomenu_item_set_item_visible (GnomenuItem* self, gboolean value);
void gnomenu_item_set_item_sensitive (GnomenuItem* self, gboolean value);
static void gnomenu_menu_item_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static int _vala_strcmp0 (const char * str1, const char * str2);



GnomenuMenuItem* gnomenu_menu_item_construct (GType object_type) {
	GnomenuMenuItem * self;
	self = g_object_newv (object_type, 0, NULL);
	return self;
}


GnomenuMenuItem* gnomenu_menu_item_new (void) {
	return gnomenu_menu_item_construct (GNOMENU_TYPE_MENU_ITEM);
}


static void gnomenu_menu_item_real_dispose (GObject* base) {
	GnomenuMenuItem * self;
	self = (GnomenuMenuItem*) base;
	if (!self->priv->disposed) {
		self->priv->disposed = TRUE;
		if (self->priv->_image_widget != NULL) {
			GtkImage* _tmp0_;
			gtk_widget_unparent ((GtkWidget*) self->priv->_image_widget);
			self->priv->_image_widget = (_tmp0_ = NULL, _g_object_unref0 (self->priv->_image_widget), _tmp0_);
		}
		gtk_object_destroy ((GtkObject*) self->_submenu_cache);
	}
	G_OBJECT_CLASS (gnomenu_menu_item_parent_class)->dispose ((GObject*) GTK_MENU_ITEM (self));
}


static void gnomenu_menu_item_maybe_connect_cached_submenu (GnomenuMenuItem* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	if (self->priv->_has_sub_shell) {
		_tmp0_ = !self->priv->_client_side_sub_shell;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		if (gtk_menu_item_get_submenu ((GtkMenuItem*) self) != GTK_MENU (self->_submenu_cache)) {
			gtk_menu_item_set_submenu ((GtkMenuItem*) self, (GtkMenu*) self->_submenu_cache);
		}
	} else {
		if (gtk_menu_item_get_submenu ((GtkMenuItem*) self) != NULL) {
			gtk_menu_popdown (gtk_menu_item_get_submenu ((GtkMenuItem*) self));
		}
		gtk_menu_item_set_submenu ((GtkMenuItem*) self, NULL);
	}
}


static void gnomenu_menu_item_real_toggle_size_request (GtkMenuItem* base, void* requisition) {
	GnomenuMenuItem * self;
	gint toggle_spacing;
	gint indicator_size;
	self = (GnomenuMenuItem*) base;
	toggle_spacing = 0;
	indicator_size = 0;
	gtk_widget_style_get ((GtkWidget*) self, "toggle-spacing", &toggle_spacing, "indicator-size", &indicator_size, NULL, NULL);
	switch (self->priv->_item_type) {
		case GNOMENU_ITEM_TYPE_CHECK:
		case GNOMENU_ITEM_TYPE_RADIO:
		{
			*((gint*) requisition) = indicator_size + toggle_spacing;
			break;
		}
		case GNOMENU_ITEM_TYPE_IMAGE:
		{
			gboolean _tmp0_ = FALSE;
			if (!gnomenu_menu_item_get__show_image (self)) {
				*((gint*) requisition) = 0;
				break;
			}
			if (gnomenu_menu_item_get_image (self) != NULL) {
				_tmp0_ = self->priv->_icon != NULL;
			} else {
				_tmp0_ = FALSE;
			}
			if (_tmp0_) {
				GtkRequisition req = {0};
				gboolean _tmp1_ = FALSE;
				gboolean _tmp2_ = FALSE;
				gtk_widget_size_request ((GtkWidget*) gnomenu_menu_item_get_image (self), &req);
				if (gnomenu_menu_item_get_pack_direction (self) == GTK_PACK_DIRECTION_LTR) {
					_tmp1_ = TRUE;
				} else {
					_tmp1_ = gnomenu_menu_item_get_pack_direction (self) == GTK_PACK_DIRECTION_RTL;
				}
				if (_tmp1_) {
					*((gint*) requisition) = req.width + toggle_spacing;
				}
				if (gnomenu_menu_item_get_pack_direction (self) == GTK_PACK_DIRECTION_TTB) {
					_tmp2_ = TRUE;
				} else {
					_tmp2_ = gnomenu_menu_item_get_pack_direction (self) == GTK_PACK_DIRECTION_BTT;
				}
				if (_tmp2_) {
					*((gint*) requisition) = req.height + toggle_spacing;
				}
			} else {
				*((gint*) requisition) = 0;
			}
			break;
		}
		default:
		{
			*((gint*) requisition) = 0;
			break;
		}
	}
}


static gboolean gnomenu_menu_item_real_expose_event (GtkWidget* base, GdkEventExpose* event) {
	GnomenuMenuItem * self;
	gboolean result = FALSE;
	gint toggle_spacing;
	gint indicator_size;
	gint horizontal_padding;
	GtkShadowType shadow_type;
	gint x;
	gint y;
	gint xoffset;
	gint yoffset;
	gint spacing;
	self = (GnomenuMenuItem*) base;
	GTK_WIDGET_CLASS (gnomenu_menu_item_parent_class)->expose_event ((GtkWidget*) GTK_MENU_ITEM (self), event);
	toggle_spacing = 0;
	indicator_size = 0;
	horizontal_padding = 0;
	gtk_widget_style_get ((GtkWidget*) self, "toggle-spacing", &toggle_spacing, "indicator-size", &indicator_size, "horizontal-padding", &horizontal_padding, NULL, NULL);
	shadow_type = gnomenu_menu_item_item_state_to_shadow_type (self->priv->_item_state);
	x = 0;
	y = 0;
	xoffset = (((GtkMenuItem*) self)->toggle_size - indicator_size) / 2;
	yoffset = (((GtkWidget*) self)->allocation.height - indicator_size) / 2;
	spacing = toggle_spacing / 2;
	switch (gtk_widget_get_direction ((GtkWidget*) self)) {
		case GTK_TEXT_DIR_LTR:
		{
			x = (((GtkWidget*) self)->allocation.x + xoffset) + spacing;
			y = ((GtkWidget*) self)->allocation.y + yoffset;
			break;
		}
		case GTK_TEXT_DIR_RTL:
		{
			x = (((((GtkWidget*) self)->allocation.x + ((GtkWidget*) self)->allocation.width) - ((GtkMenuItem*) self)->toggle_size) - xoffset) - spacing;
			y = ((GtkWidget*) self)->allocation.y + yoffset;
			break;
		}
	}
	switch (self->priv->_item_type) {
		case GNOMENU_ITEM_TYPE_CHECK:
		{
			gtk_paint_check (gtk_widget_get_style ((GtkWidget*) self), ((GtkWidget*) self)->window, (GtkStateType) ((GtkWidget*) self)->state, shadow_type, &(*event).area, (GtkWidget*) self, "check", x, y, indicator_size, indicator_size);
			break;
		}
		case GNOMENU_ITEM_TYPE_RADIO:
		{
			gtk_paint_option (gtk_widget_get_style ((GtkWidget*) self), ((GtkWidget*) self)->window, (GtkStateType) ((GtkWidget*) self)->state, shadow_type, &(*event).area, (GtkWidget*) self, "option", x, y, indicator_size, indicator_size);
			break;
		}
	}
	result = FALSE;
	return result;
}


static void gnomenu_menu_item_real_forall_internal (GtkContainer* base, gboolean include_internals, GtkCallback callback, void* callback_target) {
	GnomenuMenuItem * self;
	self = (GnomenuMenuItem*) base;
	if (include_internals) {
		gboolean _tmp0_ = FALSE;
		if (self->priv->_item_type == GNOMENU_ITEM_TYPE_IMAGE) {
			_tmp0_ = self->priv->_image_widget != NULL;
		} else {
			_tmp0_ = FALSE;
		}
		if (_tmp0_) {
			callback ((GtkWidget*) self->priv->_image_widget, callback_target);
		}
	}
	GTK_CONTAINER_CLASS (gnomenu_menu_item_parent_class)->forall ((GtkContainer*) GTK_MENU_ITEM (self), include_internals, callback, callback_target);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void gnomenu_menu_item_real_activate (GtkMenuItem* base) {
	GnomenuMenuItem * self;
	self = (GnomenuMenuItem*) base;
	if (GNOMENU_IS_MENU_BAR (gnomenu_item_get_topmost_shell ((GnomenuItem*) self))) {
		GnomenuShell* _tmp0_;
		GnomenuMenuBar* menubar;
		menubar = _g_object_ref0 ((_tmp0_ = gnomenu_item_get_topmost_shell ((GnomenuItem*) self), GNOMENU_IS_MENU_BAR (_tmp0_) ? ((GnomenuMenuBar*) _tmp0_) : NULL));
		gnomenu_menu_bar_emit_activate (menubar, self);
		_g_object_unref0 (menubar);
	} else {
		char* _tmp1_;
		g_debug ("menuitem.vala:504: activate %s, %p", _tmp1_ = gnomenu_item_get_item_path ((GnomenuItem*) self), gnomenu_item_get_topmost_shell ((GnomenuItem*) self));
		_g_free0 (_tmp1_);
		g_signal_emit_by_name (gnomenu_item_get_topmost_shell ((GnomenuItem*) self), "activate", (GnomenuItem*) self);
	}
}


static void gnomenu_menu_item_real_select (GtkItem* base) {
	GnomenuMenuItem * self;
	self = (GnomenuMenuItem*) base;
	if (GNOMENU_IS_MENU_BAR (gnomenu_item_get_topmost_shell ((GnomenuItem*) self))) {
		GnomenuShell* _tmp0_;
		GnomenuMenuBar* menubar;
		menubar = _g_object_ref0 ((_tmp0_ = gnomenu_item_get_topmost_shell ((GnomenuItem*) self), GNOMENU_IS_MENU_BAR (_tmp0_) ? ((GnomenuMenuBar*) _tmp0_) : NULL));
		gnomenu_menu_bar_emit_select (menubar, self);
		_g_object_unref0 (menubar);
	} else {
		g_signal_emit_by_name (gnomenu_item_get_topmost_shell ((GnomenuItem*) self), "select", (GnomenuItem*) self);
	}
	GTK_ITEM_CLASS (gnomenu_menu_item_parent_class)->select ((GtkItem*) GTK_MENU_ITEM (self));
}


static void gnomenu_menu_item_real_deselect (GtkItem* base) {
	GnomenuMenuItem * self;
	self = (GnomenuMenuItem*) base;
	if (GNOMENU_IS_MENU_BAR (gnomenu_item_get_topmost_shell ((GnomenuItem*) self))) {
		GnomenuShell* _tmp0_;
		GnomenuMenuBar* menubar;
		menubar = _g_object_ref0 ((_tmp0_ = gnomenu_item_get_topmost_shell ((GnomenuItem*) self), GNOMENU_IS_MENU_BAR (_tmp0_) ? ((GnomenuMenuBar*) _tmp0_) : NULL));
		gnomenu_menu_bar_emit_deselect (menubar, self);
		_g_object_unref0 (menubar);
	} else {
		g_signal_emit_by_name (gnomenu_item_get_topmost_shell ((GnomenuItem*) self), "deselect", (GnomenuItem*) self);
	}
	GTK_ITEM_CLASS (gnomenu_menu_item_parent_class)->deselect ((GtkItem*) GTK_MENU_ITEM (self));
}


static void gnomenu_menu_item_update_show_image (GnomenuMenuItem* self) {
	g_return_if_fail (self != NULL);
	if (self->priv->_image_widget != NULL) {
		gtk_widget_set_visible ((GtkWidget*) self->priv->_image_widget, gnomenu_menu_item_get__show_image (self));
	}
	gtk_widget_queue_resize ((GtkWidget*) self);
}


static void gnomenu_menu_item_show_image_notify_r (GtkWidget* widget, GtkSettings* settings) {
	g_return_if_fail (widget != NULL);
	g_return_if_fail (settings != NULL);
	if (GNOMENU_IS_MENU_ITEM (widget)) {
		GtkWidget* _tmp0_;
		GnomenuMenuItem* item;
		item = _g_object_ref0 ((_tmp0_ = widget, GNOMENU_IS_MENU_ITEM (_tmp0_) ? ((GnomenuMenuItem*) _tmp0_) : NULL));
		gnomenu_menu_item_update_show_image (item);
		_g_object_unref0 (item);
	} else {
		if (GTK_IS_CONTAINER (widget)) {
			GtkWidget* _tmp1_;
			GList* children;
			children = gtk_container_get_children ((_tmp1_ = widget, GTK_IS_CONTAINER (_tmp1_) ? ((GtkContainer*) _tmp1_) : NULL));
			{
				GList* child_collection;
				GList* child_it;
				child_collection = children;
				for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
					GtkWidget* child;
					child = _g_object_ref0 ((GtkWidget*) child_it->data);
					{
						gnomenu_menu_item_show_image_notify_r (child, settings);
						_g_object_unref0 (child);
					}
				}
			}
			_g_list_free0 (children);
		}
	}
}


static void gnomenu_menu_item_show_image_notify (GnomenuMenuItem* self, GtkSettings* settings, GParamSpec* pspec) {
	GList* toplevels;
	g_return_if_fail (self != NULL);
	g_return_if_fail (settings != NULL);
	g_return_if_fail (pspec != NULL);
	toplevels = gtk_window_list_toplevels ();
	{
		GList* c_collection;
		GList* c_it;
		c_collection = toplevels;
		for (c_it = c_collection; c_it != NULL; c_it = c_it->next) {
			GtkContainer* c;
			c = _g_object_ref0 ((GtkContainer*) ((GtkWindow*) c_it->data));
			{
				gnomenu_menu_item_show_image_notify_r ((GtkWidget*) c, settings);
				_g_object_unref0 (c);
			}
		}
	}
	_g_list_free0 (toplevels);
}


static void _gnomenu_menu_item_show_image_notify_g_object_notify (GtkSettings* _sender, GParamSpec* pspec, gpointer self) {
	gnomenu_menu_item_show_image_notify (self, _sender, pspec);
}


static void gnomenu_menu_item_real_screen_changed (GtkWidget* base, GdkScreen* previous_screen) {
	GnomenuMenuItem * self;
	GtkSettings* settings;
	self = (GnomenuMenuItem*) base;
	if (!gtk_widget_has_screen ((GtkWidget*) self)) {
		return;
	}
	settings = _g_object_ref0 (gtk_widget_get_settings ((GtkWidget*) self));
	if (((GtkSettings*) g_object_get_data ((GObject*) settings, "gnomenu-menu-item-connection")) == NULL) {
		g_signal_connect_object ((GObject*) settings, "notify::gtk-menu-images", (GCallback) _gnomenu_menu_item_show_image_notify_g_object_notify, self, 0);
		g_object_set_data_full ((GObject*) settings, "gnomenu-menu-item-connection", _g_object_ref0 (settings), g_object_unref);
	}
	gnomenu_menu_item_update_show_image (self);
	_g_object_unref0 (settings);
}


static void gnomenu_menu_item_real_size_request (GtkWidget* base, GtkRequisition* req) {
	GnomenuMenuItem * self;
	self = (GnomenuMenuItem*) base;
	if (self->priv->_item_type == GNOMENU_ITEM_TYPE_IMAGE) {
		GtkRequisition image_req = {0};
		gtk_widget_size_request ((GtkWidget*) self->priv->_image_widget, &image_req);
	}
	if (self->priv->_item_type == GNOMENU_ITEM_TYPE_ICON) {
		gint horizontal_padding;
		horizontal_padding = 0;
		gtk_widget_style_get ((GtkWidget*) self, "horizontal-padding", &horizontal_padding, NULL, NULL);
		gtk_widget_size_request ((GtkWidget*) self->priv->_icon_widget, req);
		(*req).width = (*req).width + ((((gint) gtk_container_get_border_width ((GtkContainer*) self)) * 2) + (horizontal_padding * 2));
		(*req).height = (*req).height + (((gint) gtk_container_get_border_width ((GtkContainer*) self)) * 2);
	} else {
		GTK_WIDGET_CLASS (gnomenu_menu_item_parent_class)->size_request ((GtkWidget*) GTK_MENU_ITEM (self), req);
	}
}


static void gnomenu_menu_item_real_size_allocate (GtkWidget* base, GdkRectangle* a) {
	GnomenuMenuItem * self;
	GdkRectangle _tmp0_ = {0};
	GdkRectangle ca;
	self = (GnomenuMenuItem*) base;
	ca = (_tmp0_.x = 0, _tmp0_.y = 0, _tmp0_.width = 0, _tmp0_.height = 0, _tmp0_);
	if (self->priv->_item_type == GNOMENU_ITEM_TYPE_ICON) {
		gint horizontal_padding;
		horizontal_padding = 0;
		gtk_widget_style_get ((GtkWidget*) self, "horizontal-padding", &horizontal_padding, NULL, NULL);
		ca.x = ((*a).x + ((gint) gtk_container_get_border_width ((GtkContainer*) self))) + horizontal_padding;
		ca.y = (*a).y + ((gint) gtk_container_get_border_width ((GtkContainer*) self));
		ca.width = ((*a).width - (((gint) gtk_container_get_border_width ((GtkContainer*) self)) * 2)) - horizontal_padding;
		ca.height = (*a).height - (((gint) gtk_container_get_border_width ((GtkContainer*) self)) * 2);
		gtk_widget_size_allocate ((GtkWidget*) self->priv->_icon_widget, &ca);
		if ((GTK_WIDGET_FLAGS ((GtkWidget*) self) & GTK_REALIZED) != 0) {
			gdk_window_move_resize (((GtkMenuItem*) self)->event_window, ((GtkWidget*) self)->allocation.x, ((GtkWidget*) self)->allocation.y, ((GtkWidget*) self)->allocation.width, ((GtkWidget*) self)->allocation.height);
		}
		((GtkWidget*) self)->allocation = (GtkAllocation) (*a);
	} else {
		GTK_WIDGET_CLASS (gnomenu_menu_item_parent_class)->size_allocate ((GtkWidget*) GTK_MENU_ITEM (self), a);
	}
	if (self->priv->_item_type == GNOMENU_ITEM_TYPE_IMAGE) {
		gint toggle_spacing;
		GtkRequisition icon_req = {0};
		toggle_spacing = 0;
		gtk_widget_get_child_requisition ((GtkWidget*) self->priv->_image_widget, &icon_req);
		gtk_widget_style_get ((GtkWidget*) self, "toggle-spacing", &toggle_spacing, NULL, NULL);
		ca.width = icon_req.width;
		ca.height = icon_req.height;
		switch (gnomenu_menu_item_get_pack_direction (self)) {
			case GTK_PACK_DIRECTION_LTR:
			case GTK_PACK_DIRECTION_RTL:
			{
				gint xoffset;
				gint yoffset;
				gboolean _tmp1_ = FALSE;
				xoffset = ((((GtkMenuItem*) self)->toggle_size - icon_req.width) + toggle_spacing) / 2;
				yoffset = ((*a).height - icon_req.height) / 2;
				ca.y = (*a).y + yoffset;
				if (gtk_widget_get_direction ((GtkWidget*) self) == GTK_TEXT_DIR_LTR) {
					_tmp1_ = gnomenu_menu_item_get_pack_direction (self) == GTK_PACK_DIRECTION_LTR;
				} else {
					_tmp1_ = FALSE;
				}
				if (_tmp1_) {
					ca.x = (*a).x + xoffset;
				} else {
					ca.x = (((*a).x + (*a).width) - ca.width) - xoffset;
				}
				break;
			}
			case GTK_PACK_DIRECTION_TTB:
			case GTK_PACK_DIRECTION_BTT:
			{
				gint yoffset;
				gint xoffset;
				gboolean _tmp2_ = FALSE;
				yoffset = ((((GtkMenuItem*) self)->toggle_size - icon_req.height) + toggle_spacing) / 2;
				xoffset = ((*a).width - icon_req.width) / 2;
				ca.x = (*a).x + xoffset;
				if (gtk_widget_get_direction ((GtkWidget*) self) == GTK_TEXT_DIR_LTR) {
					_tmp2_ = gnomenu_menu_item_get_pack_direction (self) == GTK_PACK_DIRECTION_TTB;
				} else {
					_tmp2_ = FALSE;
				}
				if (_tmp2_) {
					ca.y = (*a).y + yoffset;
				} else {
					ca.y = (((*a).y + (*a).height) - ca.height) - yoffset;
				}
				break;
			}
		}
		gtk_widget_size_allocate ((GtkWidget*) self->priv->_image_widget, &ca);
	}
}


static void gnomenu_menu_item_update_font (GnomenuMenuItem* self) {
	PangoFontDescription* desc;
	GtkWidget* bin_child;
	g_return_if_fail (self != NULL);
	desc = NULL;
	if (self->priv->_font != NULL) {
		PangoFontDescription* _tmp0_;
		desc = (_tmp0_ = pango_font_description_from_string (self->priv->_font), _pango_font_description_free0 (desc), _tmp0_);
	} else {
		PangoFontDescription* _tmp1_;
		desc = (_tmp1_ = NULL, _pango_font_description_free0 (desc), _tmp1_);
	}
	bin_child = _g_object_ref0 (gtk_bin_get_child ((GtkBin*) self));
	if (bin_child != NULL) {
		gtk_widget_modify_font (bin_child, desc);
	}
	_g_object_unref0 (bin_child);
	_pango_font_description_free0 (desc);
}


static char* gnomenu_menu_item_remove_underlines (GnomenuMenuItem* self, const char* s) {
	char* result = NULL;
	GString* sb;
	const char* p;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	sb = g_string_new ("");
	p = NULL;
	{
		gboolean _tmp0_;
		p = s;
		_tmp0_ = TRUE;
		while (TRUE) {
			gunichar c;
			if (!_tmp0_) {
				p = g_utf8_next_char (p);
			}
			_tmp0_ = FALSE;
			if (!(g_utf8_get_char (p) != 0)) {
				break;
			}
			c = g_utf8_get_char (p);
			if (c != '_') {
				g_string_append_unichar (sb, c);
			}
		}
	}
	result = g_strdup (sb->str);
	_g_string_free0 (sb);
	return result;
}


static void gnomenu_menu_item_update_label_text (GnomenuMenuItem* self) {
	char* text;
	GnomenuMenuLabel* label;
	g_return_if_fail (self != NULL);
	if (!gnomenu_item_type_has_label (self->priv->_item_type)) {
		return;
	}
	text = NULL;
	if (self->priv->_label == NULL) {
		char* _tmp0_;
		text = (_tmp0_ = gnomenu_item_get_item_path ((GnomenuItem*) self), _g_free0 (text), _tmp0_);
	} else {
		if (!self->priv->_show_underline) {
			char* _tmp1_;
			text = (_tmp1_ = gnomenu_menu_item_remove_underlines (self, self->priv->_label), _g_free0 (text), _tmp1_);
		} else {
			char* _tmp2_;
			text = (_tmp2_ = g_strdup (self->priv->_label), _g_free0 (text), _tmp2_);
		}
	}
	label = _g_object_ref0 (gnomenu_menu_item_get_label_widget (self));
	;
	g_assert (label != NULL);
	gnomenu_menu_label_set_label (label, text);
	gnomenu_menu_label_set_accel (label, self->priv->_accel_text);
	gnomenu_menu_label_set_max_width_chars (label, self->priv->_max_width_chars);
	_g_object_unref0 (label);
	_g_free0 (text);
}


static void gnomenu_menu_item_update_label_underline (GnomenuMenuItem* self) {
	GnomenuMenuLabel* label;
	g_return_if_fail (self != NULL);
	if (!gnomenu_item_type_has_label (self->priv->_item_type)) {
		return;
	}
	label = _g_object_ref0 (gnomenu_menu_item_get_label_widget (self));
	;
	g_assert (label != NULL);
	gnomenu_menu_label_set_use_underline (label, self->priv->_use_underline);
	_g_object_unref0 (label);
}


static void gnomenu_menu_item_update_image (GnomenuMenuItem* self) {
	GError * _inner_error_;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	if (self->priv->_item_type != GNOMENU_ITEM_TYPE_IMAGE) {
		_tmp0_ = self->priv->_item_type != GNOMENU_ITEM_TYPE_ICON;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		return;
	}
	if (self->priv->_icon != NULL) {
		_tmp1_ = g_str_has_prefix (self->priv->_icon, "theme:");
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		const char* icon_name;
		icon_name = g_utf8_offset_to_pointer (self->priv->_icon, (glong) 6);
		gtk_image_set_from_icon_name (gnomenu_menu_item_get_image (self), icon_name, GTK_ICON_SIZE_MENU);
	} else {
		gboolean _tmp2_ = FALSE;
		if (self->priv->_icon != NULL) {
			_tmp2_ = g_str_has_prefix (self->priv->_icon, "file:");
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			const char* filename;
			filename = g_utf8_offset_to_pointer (self->priv->_icon, (glong) 5);
			gtk_image_set_from_file (gnomenu_menu_item_get_image (self), filename);
		} else {
			gboolean _tmp3_ = FALSE;
			if (self->priv->_icon != NULL) {
				_tmp3_ = g_str_has_prefix (self->priv->_icon, "pixbuf:");
			} else {
				_tmp3_ = FALSE;
			}
			if (_tmp3_) {
				const char* b64data;
				guchar* _tmp5_;
				gint _data_size_;
				gint data_length1;
				size_t _tmp4_;
				guchar* data;
				GdkPixdata _tmp6_ = {0};
				GdkPixdata pixdata;
				GdkPixbuf* pixbuf;
				b64data = g_utf8_offset_to_pointer (self->priv->_icon, (glong) 7);
				data = (_tmp5_ = g_base64_decode (b64data, &_tmp4_), data_length1 = _tmp4_, _data_size_ = data_length1, _tmp5_);
				pixdata = (_tmp6_.magic = (guint32) 0, _tmp6_);
				gdk_pixdata_deserialize (&pixdata, data_length1, data, &_inner_error_);
				if (_inner_error_ != NULL) {
					data = (g_free (data), NULL);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				pixbuf = gdk_pixbuf_from_pixdata (&pixdata, TRUE, &_inner_error_);
				if (_inner_error_ != NULL) {
					data = (g_free (data), NULL);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				gtk_image_set_from_pixbuf (gnomenu_menu_item_get_image (self), pixbuf);
				_g_object_unref0 (pixbuf);
				data = (g_free (data), NULL);
			} else {
				gboolean _tmp7_ = FALSE;
				if (self->priv->_icon != NULL) {
					_tmp7_ = g_str_has_prefix (self->priv->_icon, "custom:");
				} else {
					_tmp7_ = FALSE;
				}
				if (_tmp7_) {
				} else {
					gtk_image_set_from_stock (gnomenu_menu_item_get_image (self), self->priv->_icon, GTK_ICON_SIZE_MENU);
				}
			}
		}
	}
}


static void gnomenu_menu_item_real_parent_set (GtkWidget* base, GtkWidget* old_parent) {
	GnomenuMenuItem * self;
	self = (GnomenuMenuItem*) base;
	if (gtk_widget_get_parent ((GtkWidget*) self) != NULL) {
		gnomenu_menu_item_update_label_text (self);
	}
}


static void gnomenu_menu_item_create_labels (GnomenuMenuItem* self) {
	g_return_if_fail (self != NULL);
	g_assert (gnomenu_item_type_has_label (self->priv->_item_type));
	gtk_widget_set_visible ((GtkWidget*) self->priv->_cached_label_widget, TRUE);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->_cached_label_widget, TRUE);
	gnomenu_menu_label_set_gravity (self->priv->_cached_label_widget, gnomenu_menu_item_get_gravity (self));
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->_cached_label_widget);
	gnomenu_menu_item_update_font (self);
	gnomenu_menu_item_update_label_underline (self);
}


static GnomenuMenuLabel* gnomenu_menu_item_get_label_widget (GnomenuMenuItem* self) {
	GnomenuMenuLabel* result = NULL;
	GtkWidget* _tmp0_;
	GnomenuMenuLabel* label;
	g_return_val_if_fail (self != NULL, NULL);
	label = (_tmp0_ = gtk_bin_get_child ((GtkBin*) self), GNOMENU_IS_MENU_LABEL (_tmp0_) ? ((GnomenuMenuLabel*) _tmp0_) : NULL);
	result = label;
	return result;
}


static void gnomenu_menu_item_remove_child (GnomenuMenuItem* self) {
	GtkWidget* child;
	g_return_if_fail (self != NULL);
	child = _g_object_ref0 (gtk_bin_get_child ((GtkBin*) self));
	if (child != NULL) {
		gtk_container_remove ((GtkContainer*) self, child);
	}
	_g_object_unref0 (child);
}


static void gnomenu_menu_item_create_arrow (GnomenuMenuItem* self) {
	g_return_if_fail (self != NULL);
	g_assert (self->priv->_item_type == GNOMENU_ITEM_TYPE_ARROW);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->_cached_arrow_widget);
	gtk_widget_set_visible ((GtkWidget*) self->priv->_cached_arrow_widget, TRUE);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->_cached_arrow_widget, TRUE);
	gnomenu_menu_item_update_arrow_type (self);
}


static void gnomenu_menu_item_update_arrow_type (GnomenuMenuItem* self) {
	GtkWidget* _tmp0_;
	g_return_if_fail (self != NULL);
	if (self->priv->_item_type != GNOMENU_ITEM_TYPE_ARROW) {
		return;
	}
	gtk_arrow_set ((_tmp0_ = gtk_bin_get_child ((GtkBin*) self), GTK_IS_ARROW (_tmp0_) ? ((GtkArrow*) _tmp0_) : NULL), gnomenu_gravity_to_arrow_type (self->priv->_gravity), GTK_SHADOW_NONE);
}


GtkShadowType gnomenu_menu_item_item_state_to_shadow_type (GnomenuItemState state) {
	GtkShadowType result = 0;
	switch (state) {
		case GNOMENU_ITEM_STATE_TOGGLED:
		{
			result = GTK_SHADOW_IN;
			return result;
		}
		case GNOMENU_ITEM_STATE_UNTOGGLED:
		{
			result = GTK_SHADOW_OUT;
			return result;
		}
		default:
		{
			result = GTK_SHADOW_ETCHED_IN;
			return result;
		}
	}
}


gint gnomenu_menu_item_get_max_width_chars (GnomenuMenuItem* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_max_width_chars;
	return result;
}


void gnomenu_menu_item_set_max_width_chars (GnomenuMenuItem* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_max_width_chars = value;
	gnomenu_menu_item_update_label_text (self);
	g_object_notify ((GObject *) self, "max-width-chars");
}


static GnomenuShell* gnomenu_menu_item_real_get_shell (GnomenuItem* base) {
	GnomenuShell* result;
	GnomenuMenuItem* self;
	GtkContainer* _tmp0_;
	GnomenuShell* rt;
	self = (GnomenuMenuItem*) base;
	rt = (GnomenuShell*) gnomenu_adapter_get_adapter ((_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self), GTK_IS_MENU_SHELL (_tmp0_) ? ((GtkMenuShell*) _tmp0_) : NULL));
	if (rt != NULL) {
		result = rt;
		return result;
	} else {
		GtkContainer* _tmp1_;
		result = (_tmp1_ = gtk_widget_get_parent ((GtkWidget*) self), GNOMENU_IS_SHELL (_tmp1_) ? ((GnomenuShell*) _tmp1_) : NULL);
		return result;
	}
}


static GnomenuShell* gnomenu_menu_item_real_get_sub_shell (GnomenuItem* base) {
	GnomenuShell* result;
	GnomenuMenuItem* self;
	GnomenuMenu* _tmp0_;
	self = (GnomenuMenuItem*) base;
	result = (_tmp0_ = self->_submenu_cache, GNOMENU_IS_SHELL (_tmp0_) ? ((GnomenuShell*) _tmp0_) : NULL);
	return result;
}


static gboolean gnomenu_menu_item_real_get_has_sub_shell (GnomenuItem* base) {
	gboolean result;
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	result = self->priv->_has_sub_shell;
	return result;
}


static void gnomenu_menu_item_real_set_has_sub_shell (GnomenuItem* base, gboolean value) {
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	self->priv->_has_sub_shell = value;
	gnomenu_menu_item_maybe_connect_cached_submenu (self);
	g_object_notify ((GObject *) self, "has-sub-shell");
}


static gboolean gnomenu_menu_item_real_get_client_side_sub_shell (GnomenuItem* base) {
	gboolean result;
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	result = self->priv->_client_side_sub_shell;
	return result;
}


static void gnomenu_menu_item_real_set_client_side_sub_shell (GnomenuItem* base, gboolean value) {
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	self->priv->_client_side_sub_shell = value;
	gnomenu_menu_item_maybe_connect_cached_submenu (self);
	g_object_notify ((GObject *) self, "client-side-sub-shell");
}


static const char* gnomenu_menu_item_real_get_item_id (GnomenuItem* base) {
	const char* result;
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	result = self->priv->_id;
	return result;
}


static void gnomenu_menu_item_real_set_item_id (GnomenuItem* base, const char* value) {
	GnomenuMenuItem* self;
	char* _tmp0_;
	self = (GnomenuMenuItem*) base;
	if (_vala_strcmp0 (self->priv->_id, value) == 0) {
		return;
	}
	self->priv->_id = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_id), _tmp0_);
	if (self->priv->_label == NULL) {
		gnomenu_menu_item_update_label_text (self);
	}
	g_object_notify ((GObject *) self, "item-id");
}


static const char* gnomenu_menu_item_real_get_item_label (GnomenuItem* base) {
	const char* result;
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	result = self->priv->_label;
	return result;
}


static void gnomenu_menu_item_real_set_item_label (GnomenuItem* base, const char* value) {
	GnomenuMenuItem* self;
	char* _tmp0_;
	self = (GnomenuMenuItem*) base;
	if (_vala_strcmp0 (self->priv->_label, value) == 0) {
		return;
	}
	self->priv->_label = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_label), _tmp0_);
	gnomenu_menu_item_update_label_text (self);
	g_object_notify ((GObject *) self, "item-label");
}


static const char* gnomenu_menu_item_real_get_item_icon (GnomenuItem* base) {
	const char* result;
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	result = self->priv->_icon;
	return result;
}


static void gnomenu_menu_item_real_set_item_icon (GnomenuItem* base, const char* value) {
	GnomenuMenuItem* self;
	char* _tmp0_;
	self = (GnomenuMenuItem*) base;
	if (_vala_strcmp0 (self->priv->_icon, value) == 0) {
		return;
	}
	self->priv->_icon = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_icon), _tmp0_);
	gnomenu_menu_item_update_image (self);
	g_object_notify ((GObject *) self, "item-icon");
}


static const char* gnomenu_menu_item_real_get_item_accel_text (GnomenuItem* base) {
	const char* result;
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	result = self->priv->_accel_text;
	return result;
}


static void gnomenu_menu_item_real_set_item_accel_text (GnomenuItem* base, const char* value) {
	GnomenuMenuItem* self;
	char* _tmp0_;
	self = (GnomenuMenuItem*) base;
	if (_vala_strcmp0 (self->priv->_accel_text, value) == 0) {
		return;
	}
	self->priv->_accel_text = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_accel_text), _tmp0_);
	gnomenu_menu_item_update_label_text (self);
	g_object_notify ((GObject *) self, "item-accel-text");
}


static const char* gnomenu_menu_item_real_get_item_font (GnomenuItem* base) {
	const char* result;
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	result = self->priv->_font;
	return result;
}


static void gnomenu_menu_item_real_set_item_font (GnomenuItem* base, const char* value) {
	GnomenuMenuItem* self;
	char* _tmp0_;
	self = (GnomenuMenuItem*) base;
	if (_vala_strcmp0 (self->priv->_font, value) == 0) {
		return;
	}
	self->priv->_font = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_font), _tmp0_);
	gnomenu_menu_item_update_font (self);
	g_object_notify ((GObject *) self, "item-font");
}


static GnomenuItemType gnomenu_menu_item_real_get_item_type (GnomenuItem* base) {
	GnomenuItemType result;
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	result = self->priv->_item_type;
	return result;
}


static void gnomenu_menu_item_real_set_item_type (GnomenuItem* base, GnomenuItemType value) {
	GnomenuMenuItem* self;
	GnomenuItemType old_type;
	self = (GnomenuMenuItem*) base;
	if (value == self->priv->_item_type) {
		return;
	}
	old_type = self->priv->_item_type;
	self->priv->_item_type = value;
	switch (self->priv->_item_type) {
		case GNOMENU_ITEM_TYPE_SEPARATOR:
		{
			gnomenu_menu_item_remove_child (self);
			break;
		}
		case GNOMENU_ITEM_TYPE_NORMAL:
		case GNOMENU_ITEM_TYPE_IMAGE:
		case GNOMENU_ITEM_TYPE_CHECK:
		case GNOMENU_ITEM_TYPE_RADIO:
		{
			gboolean _tmp0_ = FALSE;
			gboolean _tmp1_ = FALSE;
			gboolean _tmp2_ = FALSE;
			if (old_type != GNOMENU_ITEM_TYPE_NORMAL) {
				_tmp2_ = old_type != GNOMENU_ITEM_TYPE_IMAGE;
			} else {
				_tmp2_ = FALSE;
			}
			if (_tmp2_) {
				_tmp1_ = old_type != GNOMENU_ITEM_TYPE_RADIO;
			} else {
				_tmp1_ = FALSE;
			}
			if (_tmp1_) {
				_tmp0_ = old_type != GNOMENU_ITEM_TYPE_CHECK;
			} else {
				_tmp0_ = FALSE;
			}
			if (_tmp0_) {
				gnomenu_menu_item_remove_child (self);
				gnomenu_menu_item_create_labels (self);
				gnomenu_menu_item_update_label_text (self);
			}
			break;
		}
		case GNOMENU_ITEM_TYPE_ARROW:
		{
			if (old_type != GNOMENU_ITEM_TYPE_ARROW) {
				gnomenu_menu_item_remove_child (self);
				gnomenu_menu_item_create_arrow (self);
				gnomenu_menu_item_update_arrow_type (self);
			}
			break;
		}
		case GNOMENU_ITEM_TYPE_ICON:
		{
			if (old_type != GNOMENU_ITEM_TYPE_ICON) {
				GtkImage* _tmp3_;
				gnomenu_menu_item_remove_child (self);
				self->priv->_icon_widget = (_tmp3_ = g_object_ref_sink ((GtkImage*) gtk_image_new ()), _g_object_unref0 (self->priv->_icon_widget), _tmp3_);
				gtk_widget_set_visible ((GtkWidget*) self->priv->_icon_widget, TRUE);
				gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->_icon_widget);
				gnomenu_menu_item_update_image (self);
			}
			break;
		}
	}
	if (self->priv->_item_type == GNOMENU_ITEM_TYPE_IMAGE) {
		GtkImage* _tmp4_;
		self->priv->_image_widget = (_tmp4_ = _g_object_ref0 (self->priv->_cached_image_widget), _g_object_unref0 (self->priv->_image_widget), _tmp4_);
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->_image_widget, FALSE);
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->_image_widget, TRUE);
		gtk_widget_set_parent ((GtkWidget*) self->priv->_image_widget, (GtkWidget*) self);
		gtk_widget_set_visible ((GtkWidget*) self->priv->_image_widget, gnomenu_menu_item_get__show_image (self));
		gnomenu_menu_item_update_image (self);
	} else {
		if (self->priv->_image_widget != NULL) {
			GtkImage* _tmp5_;
			gtk_widget_unparent ((GtkWidget*) self->priv->_image_widget);
			self->priv->_image_widget = (_tmp5_ = NULL, _g_object_unref0 (self->priv->_image_widget), _tmp5_);
		}
	}
	gtk_widget_queue_resize ((GtkWidget*) self);
	g_object_notify ((GObject *) self, "item-type");
}


static gboolean gnomenu_menu_item_real_get_item_use_underline (GnomenuItem* base) {
	gboolean result;
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	result = self->priv->_use_underline;
	return result;
}


static void gnomenu_menu_item_real_set_item_use_underline (GnomenuItem* base, gboolean value) {
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	if (self->priv->_use_underline == value) {
		return;
	}
	self->priv->_use_underline = value;
	gnomenu_menu_item_update_label_underline (self);
	g_object_notify ((GObject *) self, "item-use-underline");
}


static GnomenuItemState gnomenu_menu_item_real_get_item_state (GnomenuItem* base) {
	GnomenuItemState result;
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	result = self->priv->_item_state;
	return result;
}


static void gnomenu_menu_item_real_set_item_state (GnomenuItem* base, GnomenuItemState value) {
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	if (value == self->priv->_item_state) {
		return;
	}
	self->priv->_item_state = value;
	gtk_widget_queue_draw ((GtkWidget*) self);
	g_object_notify ((GObject *) self, "item-state");
}


static gboolean gnomenu_menu_item_real_get_item_visible (GnomenuItem* base) {
	gboolean result;
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	result = self->priv->_item_visible;
	return result;
}


static void gnomenu_menu_item_real_set_item_visible (GnomenuItem* base, gboolean value) {
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	self->priv->_item_visible = value;
	gtk_widget_set_visible ((GtkWidget*) self, value);
	g_object_notify ((GObject *) self, "item-visible");
}


static gboolean gnomenu_menu_item_real_get_item_sensitive (GnomenuItem* base) {
	gboolean result;
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	result = gtk_widget_get_sensitive ((GtkWidget*) self);
	return result;
}


static void gnomenu_menu_item_real_set_item_sensitive (GnomenuItem* base, gboolean value) {
	GnomenuMenuItem* self;
	self = (GnomenuMenuItem*) base;
	gtk_widget_set_sensitive ((GtkWidget*) self, value);
	g_object_notify ((GObject *) self, "item-sensitive");
}


GnomenuGravity gnomenu_menu_item_get_gravity (GnomenuMenuItem* self) {
	GnomenuGravity result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_gravity;
	return result;
}


void gnomenu_menu_item_set_gravity (GnomenuMenuItem* self, GnomenuGravity value) {
	g_return_if_fail (self != NULL);
	if (self->priv->_gravity == value) {
		return;
	}
	self->priv->_gravity = value;
	if (gnomenu_item_type_has_label (self->priv->_item_type)) {
		gnomenu_menu_label_set_gravity (gnomenu_menu_item_get_label_widget (self), value);
	}
	gnomenu_menu_item_update_arrow_type (self);
	g_object_notify ((GObject *) self, "gravity");
}


gboolean gnomenu_menu_item_get_show_underline (GnomenuMenuItem* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_show_underline;
	return result;
}


void gnomenu_menu_item_set_show_underline (GnomenuMenuItem* self, gboolean value) {
	g_return_if_fail (self != NULL);
	if (self->priv->_show_underline != value) {
		self->priv->_show_underline = value;
		gnomenu_menu_item_update_label_text (self);
	}
	g_object_notify ((GObject *) self, "show-underline");
}


gboolean gnomenu_menu_item_get_truncated (GnomenuMenuItem* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_truncated;
	return result;
}


void gnomenu_menu_item_set_truncated (GnomenuMenuItem* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	self->priv->_truncated = value;
	if (self->priv->_item_visible) {
		_tmp0_ = !gnomenu_menu_item_get_truncated (self);
	} else {
		_tmp0_ = FALSE;
	}
	gtk_widget_set_visible ((GtkWidget*) self, _tmp0_);
	g_object_notify ((GObject *) self, "truncated");
}


static gboolean gnomenu_menu_item_get__show_image (GnomenuMenuItem* self) {
	gboolean result;
	gboolean rt;
	g_return_val_if_fail (self != NULL, FALSE);
	rt = FALSE;
	g_object_get ((GObject*) gtk_widget_get_settings ((GtkWidget*) self), "gtk-menu-images", &rt, NULL, NULL);
	result = rt;
	return result;
}


GtkImage* gnomenu_menu_item_get_image (GnomenuMenuItem* self) {
	GtkImage* result;
	g_return_val_if_fail (self != NULL, NULL);
	if (self->priv->_item_type == GNOMENU_ITEM_TYPE_IMAGE) {
		result = self->priv->_image_widget;
		return result;
	}
	if (self->priv->_item_type == GNOMENU_ITEM_TYPE_ICON) {
		result = self->priv->_icon_widget;
		return result;
	}
	result = NULL;
	return result;
}


static GtkPackDirection gnomenu_menu_item_get_pack_direction (GnomenuMenuItem* self) {
	GtkPackDirection result;
	g_return_val_if_fail (self != NULL, 0);
	if (GTK_IS_MENU_BAR (gtk_widget_get_parent ((GtkWidget*) self))) {
		GtkContainer* _tmp0_;
		result = gtk_menu_bar_get_child_pack_direction ((_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self), GTK_IS_MENU_BAR (_tmp0_) ? ((GtkMenuBar*) _tmp0_) : NULL));
		return result;
	}
	result = GTK_PACK_DIRECTION_LTR;
	return result;
}


static GObject * gnomenu_menu_item_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	GnomenuMenuItem * self;
	parent_class = G_OBJECT_CLASS (gnomenu_menu_item_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = GNOMENU_MENU_ITEM (obj);
	{
		GnomenuMenuLabel* _tmp0_;
		GtkImage* _tmp1_;
		GtkArrow* _tmp2_;
		self->priv->disposed = FALSE;
		gtk_widget_set_no_show_all ((GtkWidget*) self, TRUE);
		self->priv->_item_type = GNOMENU_ITEM_TYPE_NORMAL;
		self->priv->_cached_label_widget = (_tmp0_ = g_object_ref_sink (gnomenu_menu_label_new ()), _g_object_unref0 (self->priv->_cached_label_widget), _tmp0_);
		self->priv->_cached_image_widget = (_tmp1_ = g_object_ref_sink ((GtkImage*) gtk_image_new ()), _g_object_unref0 (self->priv->_cached_image_widget), _tmp1_);
		self->priv->_cached_arrow_widget = (_tmp2_ = g_object_ref_sink ((GtkArrow*) gtk_arrow_new (gnomenu_gravity_to_arrow_type (self->priv->_gravity), GTK_SHADOW_NONE)), _g_object_unref0 (self->priv->_cached_arrow_widget), _tmp2_);
		self->priv->_use_underline = TRUE;
		gnomenu_menu_item_create_labels (self);
	}
	return obj;
}


static void gnomenu_menu_item_class_init (GnomenuMenuItemClass * klass) {
	gnomenu_menu_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GnomenuMenuItemPrivate));
	G_OBJECT_CLASS (klass)->dispose = gnomenu_menu_item_real_dispose;
	GTK_MENU_ITEM_CLASS (klass)->toggle_size_request = gnomenu_menu_item_real_toggle_size_request;
	GTK_WIDGET_CLASS (klass)->expose_event = gnomenu_menu_item_real_expose_event;
	GTK_CONTAINER_CLASS (klass)->forall = gnomenu_menu_item_real_forall_internal;
	GTK_MENU_ITEM_CLASS (klass)->activate = gnomenu_menu_item_real_activate;
	GTK_ITEM_CLASS (klass)->select = gnomenu_menu_item_real_select;
	GTK_ITEM_CLASS (klass)->deselect = gnomenu_menu_item_real_deselect;
	GTK_WIDGET_CLASS (klass)->screen_changed = gnomenu_menu_item_real_screen_changed;
	GTK_WIDGET_CLASS (klass)->size_request = gnomenu_menu_item_real_size_request;
	GTK_WIDGET_CLASS (klass)->size_allocate = gnomenu_menu_item_real_size_allocate;
	GTK_WIDGET_CLASS (klass)->parent_set = gnomenu_menu_item_real_parent_set;
	G_OBJECT_CLASS (klass)->get_property = gnomenu_menu_item_get_property;
	G_OBJECT_CLASS (klass)->set_property = gnomenu_menu_item_set_property;
	G_OBJECT_CLASS (klass)->constructor = gnomenu_menu_item_constructor;
	G_OBJECT_CLASS (klass)->finalize = gnomenu_menu_item_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_MAX_WIDTH_CHARS, g_param_spec_int ("max-width-chars", "max-width-chars", "max-width-chars", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_SHELL, "shell");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_SUB_SHELL, "sub-shell");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_HAS_SUB_SHELL, "has-sub-shell");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_CLIENT_SIDE_SUB_SHELL, "client-side-sub-shell");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_ITEM_ID, "item-id");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_ITEM_LABEL, "item-label");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_ITEM_ICON, "item-icon");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_ITEM_ACCEL_TEXT, "item-accel-text");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_ITEM_FONT, "item-font");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_ITEM_TYPE, "item-type");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_ITEM_USE_UNDERLINE, "item-use-underline");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_ITEM_STATE, "item-state");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_ITEM_VISIBLE, "item-visible");
	g_object_class_override_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_ITEM_SENSITIVE, "item-sensitive");
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_GRAVITY, g_param_spec_enum ("gravity", "gravity", "gravity", GNOMENU_TYPE_GRAVITY, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_SHOW_UNDERLINE, g_param_spec_boolean ("show-underline", "show-underline", "show-underline", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_TRUNCATED, g_param_spec_boolean ("truncated", "truncated", "truncated", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_ITEM_IMAGE, g_param_spec_object ("image", "image", "image", GTK_TYPE_IMAGE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	{
		GParamSpecInt* _tmp3_;
		GtkImageMenuItem* item;
		gtk_widget_class_install_style_property (GTK_WIDGET_CLASS (klass), (GParamSpec*) (_tmp3_ = g_param_spec_int ("indicator-size", _ ("Indicator Size"), _ ("Size of check or radio indicator"), 0, G_MAXINT, 13, G_PARAM_READABLE)));
		_g_param_spec_unref0 (_tmp3_);
		gtk_icon_size_lookup (GTK_ICON_SIZE_MENU, &gnomenu_menu_item_icon_width, &gnomenu_menu_item_icon_height);
		item = g_object_ref_sink ((GtkImageMenuItem*) gtk_image_menu_item_new ());
		_g_object_unref0 (item);
	}
}


static void gnomenu_menu_item_gnomenu_item_interface_init (GnomenuItemIface * iface) {
	gnomenu_menu_item_gnomenu_item_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_shell = gnomenu_menu_item_real_get_shell;
	iface->get_sub_shell = gnomenu_menu_item_real_get_sub_shell;
	iface->get_has_sub_shell = gnomenu_menu_item_real_get_has_sub_shell;
	iface->set_has_sub_shell = gnomenu_menu_item_real_set_has_sub_shell;
	iface->get_client_side_sub_shell = gnomenu_menu_item_real_get_client_side_sub_shell;
	iface->set_client_side_sub_shell = gnomenu_menu_item_real_set_client_side_sub_shell;
	iface->get_item_id = gnomenu_menu_item_real_get_item_id;
	iface->set_item_id = gnomenu_menu_item_real_set_item_id;
	iface->get_item_label = gnomenu_menu_item_real_get_item_label;
	iface->set_item_label = gnomenu_menu_item_real_set_item_label;
	iface->get_item_icon = gnomenu_menu_item_real_get_item_icon;
	iface->set_item_icon = gnomenu_menu_item_real_set_item_icon;
	iface->get_item_accel_text = gnomenu_menu_item_real_get_item_accel_text;
	iface->set_item_accel_text = gnomenu_menu_item_real_set_item_accel_text;
	iface->get_item_font = gnomenu_menu_item_real_get_item_font;
	iface->set_item_font = gnomenu_menu_item_real_set_item_font;
	iface->get_item_type = gnomenu_menu_item_real_get_item_type;
	iface->set_item_type = gnomenu_menu_item_real_set_item_type;
	iface->get_item_use_underline = gnomenu_menu_item_real_get_item_use_underline;
	iface->set_item_use_underline = gnomenu_menu_item_real_set_item_use_underline;
	iface->get_item_state = gnomenu_menu_item_real_get_item_state;
	iface->set_item_state = gnomenu_menu_item_real_set_item_state;
	iface->get_item_visible = gnomenu_menu_item_real_get_item_visible;
	iface->set_item_visible = gnomenu_menu_item_real_set_item_visible;
	iface->get_item_sensitive = gnomenu_menu_item_real_get_item_sensitive;
	iface->set_item_sensitive = gnomenu_menu_item_real_set_item_sensitive;
}


static void gnomenu_menu_item_instance_init (GnomenuMenuItem * self) {
	self->priv = GNOMENU_MENU_ITEM_GET_PRIVATE (self);
	self->priv->_max_width_chars = 30;
	self->_submenu_cache = g_object_ref_sink (gnomenu_menu_new ());
	self->priv->_has_sub_shell = FALSE;
	self->priv->_client_side_sub_shell = FALSE;
	self->priv->_show_underline = TRUE;
	self->priv->_use_underline = FALSE;
}


static void gnomenu_menu_item_finalize (GObject* obj) {
	GnomenuMenuItem * self;
	self = GNOMENU_MENU_ITEM (obj);
	_g_object_unref0 (self->_submenu_cache);
	_g_free0 (self->priv->_font);
	_g_free0 (self->priv->_label);
	_g_free0 (self->priv->_icon);
	_g_free0 (self->priv->_accel_text);
	_g_free0 (self->priv->_id);
	_g_object_unref0 (self->priv->_cached_image_widget);
	_g_object_unref0 (self->priv->_cached_arrow_widget);
	_g_object_unref0 (self->priv->_cached_label_widget);
	_g_object_unref0 (self->priv->_image_widget);
	_g_object_unref0 (self->priv->_icon_widget);
	G_OBJECT_CLASS (gnomenu_menu_item_parent_class)->finalize (obj);
}


GType gnomenu_menu_item_get_type (void) {
	static volatile gsize gnomenu_menu_item_type_id__volatile = 0;
	if (g_once_init_enter (&gnomenu_menu_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GnomenuMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnomenu_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GnomenuMenuItem), 0, (GInstanceInitFunc) gnomenu_menu_item_instance_init, NULL };
		static const GInterfaceInfo gnomenu_item_info = { (GInterfaceInitFunc) gnomenu_menu_item_gnomenu_item_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gnomenu_menu_item_type_id;
		gnomenu_menu_item_type_id = g_type_register_static (GTK_TYPE_MENU_ITEM, "GnomenuMenuItem", &g_define_type_info, 0);
		g_type_add_interface_static (gnomenu_menu_item_type_id, GNOMENU_TYPE_ITEM, &gnomenu_item_info);
		g_once_init_leave (&gnomenu_menu_item_type_id__volatile, gnomenu_menu_item_type_id);
	}
	return gnomenu_menu_item_type_id__volatile;
}


static void gnomenu_menu_item_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GnomenuMenuItem * self;
	self = GNOMENU_MENU_ITEM (object);
	switch (property_id) {
		case GNOMENU_MENU_ITEM_MAX_WIDTH_CHARS:
		g_value_set_int (value, gnomenu_menu_item_get_max_width_chars (self));
		break;
		case GNOMENU_MENU_ITEM_SHELL:
		g_value_set_object (value, gnomenu_item_get_shell ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_SUB_SHELL:
		g_value_set_object (value, gnomenu_item_get_sub_shell ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_HAS_SUB_SHELL:
		g_value_set_boolean (value, gnomenu_item_get_has_sub_shell ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_CLIENT_SIDE_SUB_SHELL:
		g_value_set_boolean (value, gnomenu_item_get_client_side_sub_shell ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_ITEM_ID:
		g_value_set_string (value, gnomenu_item_get_item_id ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_ITEM_LABEL:
		g_value_set_string (value, gnomenu_item_get_item_label ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_ITEM_ICON:
		g_value_set_string (value, gnomenu_item_get_item_icon ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_ITEM_ACCEL_TEXT:
		g_value_set_string (value, gnomenu_item_get_item_accel_text ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_ITEM_FONT:
		g_value_set_string (value, gnomenu_item_get_item_font ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_ITEM_TYPE:
		g_value_set_enum (value, gnomenu_item_get_item_type ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_ITEM_USE_UNDERLINE:
		g_value_set_boolean (value, gnomenu_item_get_item_use_underline ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_ITEM_STATE:
		g_value_set_enum (value, gnomenu_item_get_item_state ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_ITEM_VISIBLE:
		g_value_set_boolean (value, gnomenu_item_get_item_visible ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_ITEM_SENSITIVE:
		g_value_set_boolean (value, gnomenu_item_get_item_sensitive ((GnomenuItem*) self));
		break;
		case GNOMENU_MENU_ITEM_GRAVITY:
		g_value_set_enum (value, gnomenu_menu_item_get_gravity (self));
		break;
		case GNOMENU_MENU_ITEM_SHOW_UNDERLINE:
		g_value_set_boolean (value, gnomenu_menu_item_get_show_underline (self));
		break;
		case GNOMENU_MENU_ITEM_TRUNCATED:
		g_value_set_boolean (value, gnomenu_menu_item_get_truncated (self));
		break;
		case GNOMENU_MENU_ITEM_IMAGE:
		g_value_set_object (value, gnomenu_menu_item_get_image (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void gnomenu_menu_item_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GnomenuMenuItem * self;
	self = GNOMENU_MENU_ITEM (object);
	switch (property_id) {
		case GNOMENU_MENU_ITEM_MAX_WIDTH_CHARS:
		gnomenu_menu_item_set_max_width_chars (self, g_value_get_int (value));
		break;
		case GNOMENU_MENU_ITEM_HAS_SUB_SHELL:
		gnomenu_item_set_has_sub_shell ((GnomenuItem*) self, g_value_get_boolean (value));
		break;
		case GNOMENU_MENU_ITEM_CLIENT_SIDE_SUB_SHELL:
		gnomenu_item_set_client_side_sub_shell ((GnomenuItem*) self, g_value_get_boolean (value));
		break;
		case GNOMENU_MENU_ITEM_ITEM_ID:
		gnomenu_item_set_item_id ((GnomenuItem*) self, g_value_get_string (value));
		break;
		case GNOMENU_MENU_ITEM_ITEM_LABEL:
		gnomenu_item_set_item_label ((GnomenuItem*) self, g_value_get_string (value));
		break;
		case GNOMENU_MENU_ITEM_ITEM_ICON:
		gnomenu_item_set_item_icon ((GnomenuItem*) self, g_value_get_string (value));
		break;
		case GNOMENU_MENU_ITEM_ITEM_ACCEL_TEXT:
		gnomenu_item_set_item_accel_text ((GnomenuItem*) self, g_value_get_string (value));
		break;
		case GNOMENU_MENU_ITEM_ITEM_FONT:
		gnomenu_item_set_item_font ((GnomenuItem*) self, g_value_get_string (value));
		break;
		case GNOMENU_MENU_ITEM_ITEM_TYPE:
		gnomenu_item_set_item_type ((GnomenuItem*) self, g_value_get_enum (value));
		break;
		case GNOMENU_MENU_ITEM_ITEM_USE_UNDERLINE:
		gnomenu_item_set_item_use_underline ((GnomenuItem*) self, g_value_get_boolean (value));
		break;
		case GNOMENU_MENU_ITEM_ITEM_STATE:
		gnomenu_item_set_item_state ((GnomenuItem*) self, g_value_get_enum (value));
		break;
		case GNOMENU_MENU_ITEM_ITEM_VISIBLE:
		gnomenu_item_set_item_visible ((GnomenuItem*) self, g_value_get_boolean (value));
		break;
		case GNOMENU_MENU_ITEM_ITEM_SENSITIVE:
		gnomenu_item_set_item_sensitive ((GnomenuItem*) self, g_value_get_boolean (value));
		break;
		case GNOMENU_MENU_ITEM_GRAVITY:
		gnomenu_menu_item_set_gravity (self, g_value_get_enum (value));
		break;
		case GNOMENU_MENU_ITEM_SHOW_UNDERLINE:
		gnomenu_menu_item_set_show_underline (self, g_value_get_boolean (value));
		break;
		case GNOMENU_MENU_ITEM_TRUNCATED:
		gnomenu_menu_item_set_truncated (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




