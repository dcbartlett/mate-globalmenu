/* menubarbox.c generated by valac, the Vala compiler
 * generated from menubarbox.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <string.h>


#define GNOMENU_TYPE_MENU_BAR_BOX (gnomenu_menu_bar_box_get_type ())
#define GNOMENU_MENU_BAR_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_MENU_BAR_BOX, GnomenuMenuBarBox))
#define GNOMENU_MENU_BAR_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMENU_TYPE_MENU_BAR_BOX, GnomenuMenuBarBoxClass))
#define GNOMENU_IS_MENU_BAR_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_MENU_BAR_BOX))
#define GNOMENU_IS_MENU_BAR_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMENU_TYPE_MENU_BAR_BOX))
#define GNOMENU_MENU_BAR_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMENU_TYPE_MENU_BAR_BOX, GnomenuMenuBarBoxClass))

typedef struct _GnomenuMenuBarBox GnomenuMenuBarBox;
typedef struct _GnomenuMenuBarBoxClass GnomenuMenuBarBoxClass;
typedef struct _GnomenuMenuBarBoxPrivate GnomenuMenuBarBoxPrivate;

#define GNOMENU_MENU_BAR_BOX_TYPE_CHILD_PROP_BAG (gnomenu_menu_bar_box_child_prop_bag_get_type ())
typedef struct _GnomenuMenuBarBoxChildPropBag GnomenuMenuBarBoxChildPropBag;

#define GNOMENU_TYPE_GRAVITY (gnomenu_gravity_get_type ())

#define GNOMENU_TYPE_MENU_BAR (gnomenu_menu_bar_get_type ())
#define GNOMENU_MENU_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_MENU_BAR, GnomenuMenuBar))
#define GNOMENU_MENU_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMENU_TYPE_MENU_BAR, GnomenuMenuBarClass))
#define GNOMENU_IS_MENU_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_MENU_BAR))
#define GNOMENU_IS_MENU_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMENU_TYPE_MENU_BAR))
#define GNOMENU_MENU_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMENU_TYPE_MENU_BAR, GnomenuMenuBarClass))

typedef struct _GnomenuMenuBar GnomenuMenuBar;
typedef struct _GnomenuMenuBarClass GnomenuMenuBarClass;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))

#define GNOMENU_TYPE_BACKGROUND (gnomenu_background_get_type ())
#define GNOMENU_BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_BACKGROUND, GnomenuBackground))
#define GNOMENU_BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMENU_TYPE_BACKGROUND, GnomenuBackgroundClass))
#define GNOMENU_IS_BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_BACKGROUND))
#define GNOMENU_IS_BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMENU_TYPE_BACKGROUND))
#define GNOMENU_BACKGROUND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMENU_TYPE_BACKGROUND, GnomenuBackgroundClass))

typedef struct _GnomenuBackground GnomenuBackground;
typedef struct _GnomenuBackgroundClass GnomenuBackgroundClass;
typedef struct _GnomenuBackgroundPrivate GnomenuBackgroundPrivate;

#define GNOMENU_TYPE_BACKGROUND_TYPE (gnomenu_background_type_get_type ())
#define _gnomenu_background_unref0(var) ((var == NULL) ? NULL : (var = (gnomenu_background_unref (var), NULL)))
#define _g_param_spec_unref0(var) ((var == NULL) ? NULL : (var = (g_param_spec_unref (var), NULL)))

struct _GnomenuMenuBarBox {
	GtkContainer parent_instance;
	GnomenuMenuBarBoxPrivate * priv;
};

struct _GnomenuMenuBarBoxClass {
	GtkContainerClass parent_class;
};

struct _GnomenuMenuBarBoxChildPropBag {
	gboolean expand;
	gboolean shrink;
};

typedef enum  {
	GNOMENU_GRAVITY_DOWN = 0,
	GNOMENU_GRAVITY_UP = 1,
	GNOMENU_GRAVITY_LEFT = 2,
	GNOMENU_GRAVITY_RIGHT = 3
} GnomenuGravity;

struct _GnomenuMenuBarBoxPrivate {
	GHashTable* props;
	GtkPackDirection _pack_direction;
	GtkPackDirection _child_pack_direction;
	GnomenuGravity _gravity;
	GList* children;
	gint* size_hints;
	gint size_hints_length1;
	gint _size_hints_size_;
};

typedef enum  {
	GNOMENU_BACKGROUND_TYPE_NONE = 0,
	GNOMENU_BACKGROUND_TYPE_COLOR = 1,
	GNOMENU_BACKGROUND_TYPE_PIXMAP = 2
} GnomenuBackgroundType;

struct _GnomenuBackground {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GnomenuBackgroundPrivate * priv;
	GnomenuBackgroundType type;
	GdkPixmap* pixmap;
	GdkColor color;
	gint offset_x;
	gint offset_y;
};

struct _GnomenuBackgroundClass {
	GTypeClass parent_class;
	void (*finalize) (GnomenuBackground *self);
};


static gpointer gnomenu_menu_bar_box_parent_class = NULL;

GType gnomenu_menu_bar_box_get_type (void) G_GNUC_CONST;
static GType gnomenu_menu_bar_box_child_prop_bag_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GnomenuMenuBarBoxChildPropBag* gnomenu_menu_bar_box_child_prop_bag_dup (const GnomenuMenuBarBoxChildPropBag* self);
static void gnomenu_menu_bar_box_child_prop_bag_free (GnomenuMenuBarBoxChildPropBag* self);
GType gnomenu_gravity_get_type (void) G_GNUC_CONST;
GType gnomenu_menu_bar_get_type (void) G_GNUC_CONST;
#define GNOMENU_MENU_BAR_BOX_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GNOMENU_TYPE_MENU_BAR_BOX, GnomenuMenuBarBoxPrivate))
enum  {
	GNOMENU_MENU_BAR_BOX_DUMMY_PROPERTY,
	GNOMENU_MENU_BAR_BOX_PACK_DIRECTION,
	GNOMENU_MENU_BAR_BOX_CHILD_PACK_DIRECTION,
	GNOMENU_MENU_BAR_BOX_GRAVITY,
	GNOMENU_MENU_BAR_BOX_BACKGROUND
};
#define GNOMENU_MENU_BAR_BOX_PROP_EXPAND 1234
#define GNOMENU_MENU_BAR_BOX_PROP_SHRINK 1235
GnomenuMenuBarBox* gnomenu_menu_bar_box_new (void);
GnomenuMenuBarBox* gnomenu_menu_bar_box_construct (GType object_type);
gint* gnomenu_menu_bar_box_get_size_hints (GnomenuMenuBarBox* self, int* result_length1);
static void gnomenu_menu_bar_box_real_forall_internal (GtkContainer* base, gboolean include_internals, GtkCallback callback, void* callback_target);
GtkPackDirection gnomenu_menu_bar_box_get_pack_direction (GnomenuMenuBarBox* self);
GnomenuGravity gnomenu_menu_bar_box_get_gravity (GnomenuMenuBarBox* self);
void gnomenu_menu_bar_set_gravity (GnomenuMenuBar* self, GnomenuGravity value);
static void gnomenu_menu_bar_box_real_add (GtkContainer* base, GtkWidget* child);
static void gnomenu_menu_bar_box_real_remove (GtkContainer* base, GtkWidget* child);
static void gnomenu_menu_bar_box_real_size_request (GtkWidget* base, GtkRequisition* r);
static void gnomenu_menu_bar_box_real_size_allocate (GtkWidget* base, GdkRectangle* a);
static void gnomenu_menu_bar_box_real_get_child_property (GtkContainer* base, GtkWidget* child, guint id, GValue* value, GParamSpec* pspec);
static void gnomenu_menu_bar_box_real_set_child_property (GtkContainer* base, GtkWidget* child, guint id, GValue* value, GParamSpec* pspec);
void gnomenu_menu_bar_box_set_pack_direction (GnomenuMenuBarBox* self, GtkPackDirection value);
GtkPackDirection gnomenu_menu_bar_box_get_child_pack_direction (GnomenuMenuBarBox* self);
void gnomenu_menu_bar_box_set_child_pack_direction (GnomenuMenuBarBox* self, GtkPackDirection value);
void gnomenu_menu_bar_box_set_gravity (GnomenuMenuBarBox* self, GnomenuGravity value);
gpointer gnomenu_background_ref (gpointer instance);
void gnomenu_background_unref (gpointer instance);
GParamSpec* gnomenu_param_spec_background (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void gnomenu_value_set_background (GValue* value, gpointer v_object);
void gnomenu_value_take_background (GValue* value, gpointer v_object);
gpointer gnomenu_value_get_background (const GValue* value);
GType gnomenu_background_get_type (void) G_GNUC_CONST;
GnomenuBackground* gnomenu_background_clone (GnomenuBackground* self);
GType gnomenu_background_type_get_type (void) G_GNUC_CONST;
void gnomenu_menu_bar_set_background (GnomenuMenuBar* self, GnomenuBackground* value);
void gnomenu_menu_bar_box_set_background (GnomenuMenuBarBox* self, GnomenuBackground* value);
static void _g_free_gdestroy_notify (void* data);
static GObject * gnomenu_menu_bar_box_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void gnomenu_menu_bar_box_finalize (GObject* obj);
static void gnomenu_menu_bar_box_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void gnomenu_menu_bar_box_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);



GnomenuMenuBarBox* gnomenu_menu_bar_box_construct (GType object_type) {
	GnomenuMenuBarBox * self;
	self = g_object_newv (object_type, 0, NULL);
	return self;
}


GnomenuMenuBarBox* gnomenu_menu_bar_box_new (void) {
	return gnomenu_menu_bar_box_construct (GNOMENU_TYPE_MENU_BAR_BOX);
}


gint* gnomenu_menu_bar_box_get_size_hints (GnomenuMenuBarBox* self, int* result_length1) {
	gint* result = NULL;
	gint* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	result = (_tmp0_ = self->priv->size_hints, *result_length1 = self->priv->size_hints_length1, _tmp0_);
	return result;
}


static void gnomenu_menu_bar_box_real_forall_internal (GtkContainer* base, gboolean include_internals, GtkCallback callback, void* callback_target) {
	GnomenuMenuBarBox * self;
	GList* iter;
	self = (GnomenuMenuBarBox*) base;
	if (include_internals) {
	}
	iter = self->priv->children;
	while (TRUE) {
		GtkWidget* child;
		if (!(iter != NULL)) {
			break;
		}
		child = (GtkWidget*) ((GnomenuMenuBar*) iter->data);
		iter = iter->next;
		callback (child, callback_target);
	}
}


static void gnomenu_menu_bar_box_real_add (GtkContainer* base, GtkWidget* child) {
	GnomenuMenuBarBox * self;
	self = (GnomenuMenuBarBox*) base;
	g_return_if_fail (child != NULL);
	if (GNOMENU_IS_MENU_BAR (child)) {
		GtkWidget* _tmp0_;
		GtkWidget* _tmp1_;
		GtkWidget* _tmp2_;
		self->priv->children = g_list_append (self->priv->children, (_tmp0_ = child, GNOMENU_IS_MENU_BAR (_tmp0_) ? ((GnomenuMenuBar*) _tmp0_) : NULL));
		gtk_widget_set_parent (child, (GtkWidget*) self);
		g_hash_table_insert (self->priv->props, child, (GnomenuMenuBarBoxChildPropBag*) g_malloc0 ((gsize) sizeof (GnomenuMenuBarBoxChildPropBag)));
		gtk_menu_bar_set_pack_direction ((GtkMenuBar*) (_tmp1_ = child, GNOMENU_IS_MENU_BAR (_tmp1_) ? ((GnomenuMenuBar*) _tmp1_) : NULL), gnomenu_menu_bar_box_get_pack_direction (self));
		gnomenu_menu_bar_set_gravity ((_tmp2_ = child, GNOMENU_IS_MENU_BAR (_tmp2_) ? ((GnomenuMenuBar*) _tmp2_) : NULL), gnomenu_menu_bar_box_get_gravity (self));
	}
}


static void gnomenu_menu_bar_box_real_remove (GtkContainer* base, GtkWidget* child) {
	GnomenuMenuBarBox * self;
	self = (GnomenuMenuBarBox*) base;
	g_return_if_fail (child != NULL);
	if (GNOMENU_IS_MENU_BAR (child)) {
		GtkWidget* _tmp0_;
		self->priv->children = g_list_remove_all (self->priv->children, (_tmp0_ = child, GNOMENU_IS_MENU_BAR (_tmp0_) ? ((GnomenuMenuBar*) _tmp0_) : NULL));
		gtk_widget_unparent (child);
		g_hash_table_remove (self->priv->props, child);
	}
}


static void gnomenu_menu_bar_box_real_size_request (GtkWidget* base, GtkRequisition* r) {
	GnomenuMenuBarBox * self;
	GtkRequisition cr = {0};
	GList* hints;
	gint* _tmp3_;
	gint _tmp2_;
	gint i;
	self = (GnomenuMenuBarBox*) base;
	(*r).width = 0;
	(*r).height = 0;
	hints = NULL;
	{
		GList* menubar_collection;
		GList* menubar_it;
		menubar_collection = self->priv->children;
		for (menubar_it = menubar_collection; menubar_it != NULL; menubar_it = menubar_it->next) {
			GnomenuMenuBar* menubar;
			menubar = (GnomenuMenuBar*) menubar_it->data;
			{
				gboolean shrink;
				if (!gtk_widget_get_visible ((GtkWidget*) menubar)) {
					continue;
				}
				gtk_widget_size_request ((GtkWidget*) menubar, &cr);
				shrink = FALSE;
				gtk_container_child_get ((GtkContainer*) self, (GtkWidget*) menubar, "shrink", &shrink, NULL);
				switch (gnomenu_menu_bar_box_get_pack_direction (self)) {
					case GTK_PACK_DIRECTION_LTR:
					case GTK_PACK_DIRECTION_RTL:
					{
						gint _tmp0_ = 0;
						if ((*r).height > cr.height) {
							_tmp0_ = (*r).height;
						} else {
							_tmp0_ = cr.height;
						}
						(*r).height = _tmp0_;
						hints = g_list_prepend (hints, GINT_TO_POINTER ((*r).width + 2));
						(*r).width = (*r).width + cr.width;
						hints = g_list_prepend (hints, GINT_TO_POINTER ((*r).width + 1));
						break;
					}
					case GTK_PACK_DIRECTION_BTT:
					case GTK_PACK_DIRECTION_TTB:
					{
						gint _tmp1_ = 0;
						if ((*r).width > cr.width) {
							_tmp1_ = (*r).width;
						} else {
							_tmp1_ = cr.width;
						}
						(*r).width = _tmp1_;
						hints = g_list_prepend (hints, GINT_TO_POINTER ((*r).height + 2));
						(*r).height = (*r).height + cr.height;
						hints = g_list_prepend (hints, GINT_TO_POINTER ((*r).height + 1));
						break;
					}
				}
			}
		}
	}
	self->priv->size_hints = (_tmp3_ = g_new0 (gint, _tmp2_ = g_list_length (hints)), self->priv->size_hints = (g_free (self->priv->size_hints), NULL), self->priv->size_hints_length1 = _tmp2_, self->priv->_size_hints_size_ = self->priv->size_hints_length1, _tmp3_);
	i = 0;
	{
		GList* val_collection;
		GList* val_it;
		val_collection = hints;
		for (val_it = val_collection; val_it != NULL; val_it = val_it->next) {
			gint val;
			val = GPOINTER_TO_INT (val_it->data);
			{
				self->priv->size_hints[i] = val;
				i++;
			}
		}
	}
	_g_list_free0 (hints);
}


static void gnomenu_menu_bar_box_real_size_allocate (GtkWidget* base, GdkRectangle* a) {
	GnomenuMenuBarBox * self;
	GtkRequisition cr = {0};
	GtkAllocation _tmp0_ = {0};
	GtkAllocation ca;
	gint x;
	gint y;
	gint rev_x;
	gint rev_y;
	gint num_of_shrinks;
	gint non_shrink_a;
	self = (GnomenuMenuBarBox*) base;
	((GtkWidget*) self)->allocation = (GtkAllocation) (*a);
	ca = (_tmp0_.x = 0, _tmp0_.y = 0, _tmp0_.width = 0, _tmp0_.height = 0, _tmp0_);
	x = 0;
	y = 0;
	rev_x = (*a).width;
	rev_y = (*a).height;
	num_of_shrinks = 0;
	non_shrink_a = 0;
	{
		GList* menubar_collection;
		GList* menubar_it;
		menubar_collection = self->priv->children;
		for (menubar_it = menubar_collection; menubar_it != NULL; menubar_it = menubar_it->next) {
			GnomenuMenuBar* menubar;
			menubar = (GnomenuMenuBar*) menubar_it->data;
			{
				gboolean shrink;
				if (!gtk_widget_get_visible ((GtkWidget*) menubar)) {
					continue;
				}
				shrink = FALSE;
				gtk_container_child_get ((GtkContainer*) self, (GtkWidget*) menubar, "shrink", &shrink, NULL, NULL);
				if (shrink) {
					num_of_shrinks++;
				} else {
					gtk_widget_get_child_requisition ((GtkWidget*) menubar, &cr);
					switch (gnomenu_menu_bar_box_get_pack_direction (self)) {
						case GTK_PACK_DIRECTION_LTR:
						case GTK_PACK_DIRECTION_RTL:
						{
							non_shrink_a = non_shrink_a + cr.width;
							break;
						}
						case GTK_PACK_DIRECTION_BTT:
						case GTK_PACK_DIRECTION_TTB:
						{
							non_shrink_a = non_shrink_a + cr.height;
							break;
						}
					}
				}
			}
		}
	}
	{
		GList* menubar_collection;
		GList* menubar_it;
		menubar_collection = self->priv->children;
		for (menubar_it = menubar_collection; menubar_it != NULL; menubar_it = menubar_it->next) {
			GnomenuMenuBar* menubar;
			menubar = (GnomenuMenuBar*) menubar_it->data;
			{
				gboolean shrink;
				GdkRectangle _tmp1_;
				shrink = FALSE;
				if (!gtk_widget_get_visible ((GtkWidget*) menubar)) {
					continue;
				}
				gtk_widget_get_child_requisition ((GtkWidget*) menubar, &cr);
				gtk_container_child_get ((GtkContainer*) self, (GtkWidget*) menubar, "shrink", &shrink, NULL, NULL);
				switch (gnomenu_menu_bar_box_get_pack_direction (self)) {
					case GTK_PACK_DIRECTION_LTR:
					{
						if (shrink) {
							ca.width = ((*a).width - non_shrink_a) / num_of_shrinks;
							if (ca.width < 0) {
								ca.width = 0;
							}
						} else {
							ca.width = cr.width;
						}
						ca.height = (*a).height;
						ca.x = x;
						ca.y = y;
						x = x + ca.width;
						break;
					}
					case GTK_PACK_DIRECTION_RTL:
					{
						if (shrink) {
							ca.width = ((*a).width - non_shrink_a) / num_of_shrinks;
							if (ca.width < 0) {
								ca.width = 0;
							}
						} else {
							ca.width = cr.width;
						}
						ca.x = rev_x - ca.width;
						ca.y = y;
						ca.height = (*a).height;
						rev_x = rev_x - ca.width;
						x = x + ca.width;
						break;
					}
					case GTK_PACK_DIRECTION_TTB:
					{
						ca.width = (*a).width;
						if (shrink) {
							ca.height = ((*a).height - non_shrink_a) / num_of_shrinks;
							if (ca.height < 0) {
								ca.height = 0;
							}
						} else {
							ca.height = cr.height;
						}
						ca.x = x;
						ca.y = y;
						y = y + ca.height;
						break;
					}
					case GTK_PACK_DIRECTION_BTT:
					{
						ca.width = (*a).width;
						if (shrink) {
							ca.height = ((*a).height - non_shrink_a) / num_of_shrinks;
							if (ca.height < 0) {
								ca.height = 0;
							}
						} else {
							ca.height = cr.height;
						}
						ca.x = x;
						ca.y = rev_y - ca.height;
						rev_y = rev_y - ca.height;
						y = y + ca.height;
						break;
					}
				}
				gtk_widget_size_allocate ((GtkWidget*) menubar, (_tmp1_ = (GdkRectangle) ca, &_tmp1_));
			}
		}
	}
	GTK_WIDGET_CLASS (gnomenu_menu_bar_box_parent_class)->size_allocate ((GtkWidget*) GTK_CONTAINER (self), a);
}


static void gnomenu_menu_bar_box_real_get_child_property (GtkContainer* base, GtkWidget* child, guint id, GValue* value, GParamSpec* pspec) {
	GnomenuMenuBarBox * self;
	self = (GnomenuMenuBarBox*) base;
	g_return_if_fail (child != NULL);
	g_return_if_fail (pspec != NULL);
	switch (id) {
		case GNOMENU_MENU_BAR_BOX_PROP_EXPAND:
		{
			GnomenuMenuBarBoxChildPropBag* prop;
			prop = g_hash_table_lookup (self->priv->props, child);
			g_value_set_boolean (value, (*prop).expand);
			break;
		}
		case GNOMENU_MENU_BAR_BOX_PROP_SHRINK:
		{
			GnomenuMenuBarBoxChildPropBag* prop;
			prop = g_hash_table_lookup (self->priv->props, child);
			g_value_set_boolean (value, (*prop).shrink);
			break;
		}
	}
}


static void gnomenu_menu_bar_box_real_set_child_property (GtkContainer* base, GtkWidget* child, guint id, GValue* value, GParamSpec* pspec) {
	GnomenuMenuBarBox * self;
	self = (GnomenuMenuBarBox*) base;
	g_return_if_fail (child != NULL);
	g_return_if_fail (pspec != NULL);
	switch (id) {
		case GNOMENU_MENU_BAR_BOX_PROP_EXPAND:
		{
			gboolean expand;
			GnomenuMenuBarBoxChildPropBag* prop;
			expand = g_value_get_boolean (value);
			prop = g_hash_table_lookup (self->priv->props, child);
			if ((*prop).expand != expand) {
				(*prop).expand = expand;
				gtk_widget_queue_resize ((GtkWidget*) self);
			}
			break;
		}
		case GNOMENU_MENU_BAR_BOX_PROP_SHRINK:
		{
			gboolean shrink;
			GnomenuMenuBarBoxChildPropBag* prop;
			shrink = g_value_get_boolean (value);
			prop = g_hash_table_lookup (self->priv->props, child);
			if ((*prop).shrink != shrink) {
				(*prop).shrink = shrink;
				gtk_widget_queue_resize ((GtkWidget*) self);
			}
			break;
		}
	}
}


GtkPackDirection gnomenu_menu_bar_box_get_pack_direction (GnomenuMenuBarBox* self) {
	GtkPackDirection result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_pack_direction;
	return result;
}


void gnomenu_menu_bar_box_set_pack_direction (GnomenuMenuBarBox* self, GtkPackDirection value) {
	g_return_if_fail (self != NULL);
	{
		GList* menubar_collection;
		GList* menubar_it;
		menubar_collection = self->priv->children;
		for (menubar_it = menubar_collection; menubar_it != NULL; menubar_it = menubar_it->next) {
			GnomenuMenuBar* menubar;
			menubar = (GnomenuMenuBar*) menubar_it->data;
			{
				gtk_menu_bar_set_child_pack_direction ((GtkMenuBar*) menubar, value);
			}
		}
	}
	if (self->priv->_pack_direction == value) {
		return;
	}
	self->priv->_pack_direction = value;
	gtk_widget_queue_resize ((GtkWidget*) self);
	g_object_notify ((GObject *) self, "pack-direction");
}


GtkPackDirection gnomenu_menu_bar_box_get_child_pack_direction (GnomenuMenuBarBox* self) {
	GtkPackDirection result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_child_pack_direction;
	return result;
}


void gnomenu_menu_bar_box_set_child_pack_direction (GnomenuMenuBarBox* self, GtkPackDirection value) {
	g_return_if_fail (self != NULL);
	{
		GList* menubar_collection;
		GList* menubar_it;
		menubar_collection = self->priv->children;
		for (menubar_it = menubar_collection; menubar_it != NULL; menubar_it = menubar_it->next) {
			GnomenuMenuBar* menubar;
			menubar = (GnomenuMenuBar*) menubar_it->data;
			{
				gtk_menu_bar_set_pack_direction ((GtkMenuBar*) menubar, value);
			}
		}
	}
	if (self->priv->_child_pack_direction == value) {
		return;
	}
	self->priv->_child_pack_direction = value;
	gtk_widget_queue_resize ((GtkWidget*) self);
	g_object_notify ((GObject *) self, "child-pack-direction");
}


GnomenuGravity gnomenu_menu_bar_box_get_gravity (GnomenuMenuBarBox* self) {
	GnomenuGravity result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_gravity;
	return result;
}


void gnomenu_menu_bar_box_set_gravity (GnomenuMenuBarBox* self, GnomenuGravity value) {
	g_return_if_fail (self != NULL);
	if (self->priv->_gravity == value) {
		return;
	}
	self->priv->_gravity = value;
	{
		GList* menubar_collection;
		GList* menubar_it;
		menubar_collection = self->priv->children;
		for (menubar_it = menubar_collection; menubar_it != NULL; menubar_it = menubar_it->next) {
			GnomenuMenuBar* menubar;
			menubar = (GnomenuMenuBar*) menubar_it->data;
			{
				gnomenu_menu_bar_set_gravity (menubar, value);
			}
		}
	}
	gtk_widget_queue_draw ((GtkWidget*) self);
	g_object_notify ((GObject *) self, "gravity");
}


void gnomenu_menu_bar_box_set_background (GnomenuMenuBarBox* self, GnomenuBackground* value) {
	GnomenuBackground* bg;
	g_return_if_fail (self != NULL);
	bg = gnomenu_background_clone (value);
	{
		GList* menubar_collection;
		GList* menubar_it;
		menubar_collection = self->priv->children;
		for (menubar_it = menubar_collection; menubar_it != NULL; menubar_it = menubar_it->next) {
			GnomenuMenuBar* menubar;
			menubar = (GnomenuMenuBar*) menubar_it->data;
			{
				bg->offset_x = ((GtkWidget*) menubar)->allocation.x - ((GtkWidget*) self)->allocation.x;
				bg->offset_y = ((GtkWidget*) menubar)->allocation.y - ((GtkWidget*) self)->allocation.y;
				gnomenu_menu_bar_set_background (menubar, bg);
			}
		}
	}
	_gnomenu_background_unref0 (bg);
	g_object_notify ((GObject *) self, "background");
}


static void _g_free_gdestroy_notify (void* data) {
	g_free (data);
}


static GObject * gnomenu_menu_bar_box_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	GnomenuMenuBarBox * self;
	parent_class = G_OBJECT_CLASS (gnomenu_menu_bar_box_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = GNOMENU_MENU_BAR_BOX (obj);
	{
		GHashTable* _tmp0_;
		GTK_WIDGET_SET_FLAGS ((GtkWidget*) self, GTK_NO_WINDOW);
		self->priv->props = (_tmp0_ = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, _g_free_gdestroy_notify), _g_hash_table_unref0 (self->priv->props), _tmp0_);
	}
	return obj;
}


static GnomenuMenuBarBoxChildPropBag* gnomenu_menu_bar_box_child_prop_bag_dup (const GnomenuMenuBarBoxChildPropBag* self) {
	GnomenuMenuBarBoxChildPropBag* dup;
	dup = g_new0 (GnomenuMenuBarBoxChildPropBag, 1);
	memcpy (dup, self, sizeof (GnomenuMenuBarBoxChildPropBag));
	return dup;
}


static void gnomenu_menu_bar_box_child_prop_bag_free (GnomenuMenuBarBoxChildPropBag* self) {
	g_free (self);
}


static GType gnomenu_menu_bar_box_child_prop_bag_get_type (void) {
	static volatile gsize gnomenu_menu_bar_box_child_prop_bag_type_id__volatile = 0;
	if (g_once_init_enter (&gnomenu_menu_bar_box_child_prop_bag_type_id__volatile)) {
		GType gnomenu_menu_bar_box_child_prop_bag_type_id;
		gnomenu_menu_bar_box_child_prop_bag_type_id = g_boxed_type_register_static ("GnomenuMenuBarBoxChildPropBag", (GBoxedCopyFunc) gnomenu_menu_bar_box_child_prop_bag_dup, (GBoxedFreeFunc) gnomenu_menu_bar_box_child_prop_bag_free);
		g_once_init_leave (&gnomenu_menu_bar_box_child_prop_bag_type_id__volatile, gnomenu_menu_bar_box_child_prop_bag_type_id);
	}
	return gnomenu_menu_bar_box_child_prop_bag_type_id__volatile;
}


static void gnomenu_menu_bar_box_class_init (GnomenuMenuBarBoxClass * klass) {
	gnomenu_menu_bar_box_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GnomenuMenuBarBoxPrivate));
	GTK_CONTAINER_CLASS (klass)->forall = gnomenu_menu_bar_box_real_forall_internal;
	GTK_CONTAINER_CLASS (klass)->add = gnomenu_menu_bar_box_real_add;
	GTK_CONTAINER_CLASS (klass)->remove = gnomenu_menu_bar_box_real_remove;
	GTK_WIDGET_CLASS (klass)->size_request = gnomenu_menu_bar_box_real_size_request;
	GTK_WIDGET_CLASS (klass)->size_allocate = gnomenu_menu_bar_box_real_size_allocate;
	GTK_CONTAINER_CLASS (klass)->get_child_property = gnomenu_menu_bar_box_real_get_child_property;
	GTK_CONTAINER_CLASS (klass)->set_child_property = gnomenu_menu_bar_box_real_set_child_property;
	G_OBJECT_CLASS (klass)->get_property = gnomenu_menu_bar_box_get_property;
	G_OBJECT_CLASS (klass)->set_property = gnomenu_menu_bar_box_set_property;
	G_OBJECT_CLASS (klass)->constructor = gnomenu_menu_bar_box_constructor;
	G_OBJECT_CLASS (klass)->finalize = gnomenu_menu_bar_box_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_BAR_BOX_PACK_DIRECTION, g_param_spec_enum ("pack-direction", "pack-direction", "pack-direction", GTK_TYPE_PACK_DIRECTION, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_BAR_BOX_CHILD_PACK_DIRECTION, g_param_spec_enum ("child-pack-direction", "child-pack-direction", "child-pack-direction", GTK_TYPE_PACK_DIRECTION, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_BAR_BOX_GRAVITY, g_param_spec_enum ("gravity", "gravity", "gravity", GNOMENU_TYPE_GRAVITY, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GNOMENU_MENU_BAR_BOX_BACKGROUND, gnomenu_param_spec_background ("background", "background", "background", GNOMENU_TYPE_BACKGROUND, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE));
	{
		GParamSpecBoolean* _tmp1_;
		GParamSpecBoolean* _tmp2_;
		gtk_container_class_install_child_property (GTK_CONTAINER_CLASS (klass), (guint) GNOMENU_MENU_BAR_BOX_PROP_EXPAND, (GParamSpec*) (_tmp1_ = g_param_spec_boolean ("expand", "Expand", "the child will expand if set to true", FALSE, G_PARAM_READABLE | G_PARAM_WRITABLE)));
		_g_param_spec_unref0 (_tmp1_);
		gtk_container_class_install_child_property (GTK_CONTAINER_CLASS (klass), (guint) GNOMENU_MENU_BAR_BOX_PROP_SHRINK, (GParamSpec*) (_tmp2_ = g_param_spec_boolean ("shrink", "shrink", "the child will shrink if set to true", FALSE, G_PARAM_READABLE | G_PARAM_WRITABLE)));
		_g_param_spec_unref0 (_tmp2_);
	}
}


static void gnomenu_menu_bar_box_instance_init (GnomenuMenuBarBox * self) {
	self->priv = GNOMENU_MENU_BAR_BOX_GET_PRIVATE (self);
}


static void gnomenu_menu_bar_box_finalize (GObject* obj) {
	GnomenuMenuBarBox * self;
	self = GNOMENU_MENU_BAR_BOX (obj);
	_g_hash_table_unref0 (self->priv->props);
	_g_list_free0 (self->priv->children);
	self->priv->size_hints = (g_free (self->priv->size_hints), NULL);
	G_OBJECT_CLASS (gnomenu_menu_bar_box_parent_class)->finalize (obj);
}


GType gnomenu_menu_bar_box_get_type (void) {
	static volatile gsize gnomenu_menu_bar_box_type_id__volatile = 0;
	if (g_once_init_enter (&gnomenu_menu_bar_box_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GnomenuMenuBarBoxClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnomenu_menu_bar_box_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GnomenuMenuBarBox), 0, (GInstanceInitFunc) gnomenu_menu_bar_box_instance_init, NULL };
		GType gnomenu_menu_bar_box_type_id;
		gnomenu_menu_bar_box_type_id = g_type_register_static (GTK_TYPE_CONTAINER, "GnomenuMenuBarBox", &g_define_type_info, 0);
		g_once_init_leave (&gnomenu_menu_bar_box_type_id__volatile, gnomenu_menu_bar_box_type_id);
	}
	return gnomenu_menu_bar_box_type_id__volatile;
}


static void gnomenu_menu_bar_box_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GnomenuMenuBarBox * self;
	self = GNOMENU_MENU_BAR_BOX (object);
	switch (property_id) {
		case GNOMENU_MENU_BAR_BOX_PACK_DIRECTION:
		g_value_set_enum (value, gnomenu_menu_bar_box_get_pack_direction (self));
		break;
		case GNOMENU_MENU_BAR_BOX_CHILD_PACK_DIRECTION:
		g_value_set_enum (value, gnomenu_menu_bar_box_get_child_pack_direction (self));
		break;
		case GNOMENU_MENU_BAR_BOX_GRAVITY:
		g_value_set_enum (value, gnomenu_menu_bar_box_get_gravity (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void gnomenu_menu_bar_box_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GnomenuMenuBarBox * self;
	self = GNOMENU_MENU_BAR_BOX (object);
	switch (property_id) {
		case GNOMENU_MENU_BAR_BOX_PACK_DIRECTION:
		gnomenu_menu_bar_box_set_pack_direction (self, g_value_get_enum (value));
		break;
		case GNOMENU_MENU_BAR_BOX_CHILD_PACK_DIRECTION:
		gnomenu_menu_bar_box_set_child_pack_direction (self, g_value_get_enum (value));
		break;
		case GNOMENU_MENU_BAR_BOX_GRAVITY:
		gnomenu_menu_bar_box_set_gravity (self, g_value_get_enum (value));
		break;
		case GNOMENU_MENU_BAR_BOX_BACKGROUND:
		gnomenu_menu_bar_box_set_background (self, gnomenu_value_get_background (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}




