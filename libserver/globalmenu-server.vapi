/* globalmenu-server.vapi generated by valac, do not modify. */

[CCode (cprefix = "Gnomenu", lower_case_cprefix = "gnomenu_")]
namespace Gnomenu {
	[CCode (cheader_filename = "globalmenu-server.h")]
	public class Adapter : GLib.Object, Gnomenu.Shell {
		public Adapter (Gtk.MenuShell gtk_shell);
		public override void dispose ();
		public static unowned Gnomenu.Adapter? get_adapter (Gtk.MenuShell gtk_shell);
		public Gtk.MenuShell gtk_shell { get; set construct; }
		public bool is_topmost { get; set; }
	}
	[CCode (ref_function = "gnomenu_background_ref", unref_function = "gnomenu_background_unref", cheader_filename = "globalmenu-server.h")]
	public class Background {
		public Gdk.Color color;
		public int offset_x;
		public int offset_y;
		public Gdk.Pixmap pixmap;
		public Gnomenu.BackgroundType type;
		public Background ();
		public Gnomenu.Background clone ();
	}
	[CCode (cheader_filename = "globalmenu-server.h")]
	public class GlobalMenuAdapter : Gnomenu.Adapter {
		public GlobalMenuAdapter (Gtk.MenuShell gtk_shell);
		public Gnomenu.Window active_window { get; }
		public signal void active_window_changed (Gnomenu.Window? prev_window);
	}
	[CCode (cheader_filename = "globalmenu-server.h")]
	public class GlobalMenuBar : Gnomenu.MenuBar {
		public bool _grab_menu_key;
		public GlobalMenuBar ();
		public override void dispose ();
		public Gnomenu.Window active_window { get; }
		public bool grab_keys { get; set; }
		public bool grab_menu_key { get; set; }
		public bool per_monitor_mode { get; set; }
		public signal void active_window_changed (Gnomenu.Window? prev_window);
	}
	[CCode (cheader_filename = "globalmenu-server.h")]
	public class GlobalMenuItem : Gtk.MenuItem {
		public GlobalMenuItem ();
		public Gnomenu.Window active_window { get; }
		public bool per_monitor_mode { get; set; }
		public signal void active_window_changed (Gnomenu.Window? prev_window);
	}
	[CCode (cheader_filename = "globalmenu-server.h")]
	public class Menu : Gtk.Menu, Gnomenu.Shell {
		public static bool default_use_rgba_colormap;
		public Menu ();
		public override void destroy ();
		public bool is_topmost { get; set; }
		public bool use_rgba_colormap { get; set; }
	}
	[CCode (cheader_filename = "globalmenu-server.h")]
	public class MenuBar : Gtk.MenuBar, Gnomenu.Shell {
		public MenuBar ();
		public override void dispose ();
		public override bool expose_event (Gdk.EventExpose event);
		public override void forall_internal (bool include_internals, Gtk.Callback callback);
		public Gnomenu.MenuItem? @get (string path);
		public override void insert (Gtk.Widget child, int position);
		public override bool move_selected (int distance);
		public override void realize ();
		public override void size_allocate (Gdk.Rectangle a);
		public override void size_request (out Gtk.Requisition req);
		public Gnomenu.Background background { get; set; }
		public Gnomenu.Gravity gravity { get; set; }
		public bool overflown { get; }
	}
	[CCode (cheader_filename = "globalmenu-server.h")]
	public class MenuBarBox : Gtk.Container {
		public MenuBarBox ();
		public override void add (Gtk.Widget child);
		public override void forall_internal (bool include_internals, Gtk.Callback callback);
		public override void get_child_property (Gtk.Widget child, uint id, GLib.Value value, GLib.ParamSpec pspec);
		public unowned int[] get_size_hints ();
		public override void remove (Gtk.Widget child);
		public override void set_child_property (Gtk.Widget child, uint id, GLib.Value value, GLib.ParamSpec pspec);
		public override void size_allocate (Gdk.Rectangle a);
		public override void size_request (out Gtk.Requisition r);
		public Gnomenu.Background background { set; }
		public Gtk.PackDirection child_pack_direction { get; set; }
		public Gnomenu.Gravity gravity { get; set; }
		public Gtk.PackDirection pack_direction { get; set; }
	}
	[CCode (cheader_filename = "globalmenu-server.h")]
	public class MenuItem : Gtk.MenuItem, Gnomenu.Item {
		public Gnomenu.Menu _submenu_cache;
		public MenuItem ();
		public override void activate ();
		public override void deselect ();
		public override void dispose ();
		public override bool expose_event (Gdk.EventExpose event);
		public override void forall_internal (bool include_internals, Gtk.Callback callback);
		public static Gtk.ShadowType item_state_to_shadow_type (Gnomenu.ItemState state);
		public override void parent_set (Gtk.Widget? old_parent);
		public override void screen_changed (Gdk.Screen? previous_screen);
		public override void select ();
		public override void size_allocate (Gdk.Rectangle a);
		public override void size_request (out Gtk.Requisition req);
		public override void toggle_size_request (void* requisition);
		public Gnomenu.Gravity gravity { get; set; }
		public Gtk.Image? image { get; }
		public int max_width_chars { get; set; }
		public bool show_underline { get; set; }
		public bool truncated { get; set; }
	}
	[CCode (cheader_filename = "globalmenu-server.h")]
	public class MenuLabel : Gtk.Container {
		public MenuLabel ();
		public override void add (Gtk.Widget child);
		public override void forall_internal (bool include_internals, Gtk.Callback callback);
		public override void get_child_property (Gtk.Widget child, uint id, GLib.Value value, GLib.ParamSpec pspec);
		public override void map ();
		public override bool mnemonic_activate (bool arg1);
		public override void remove (Gtk.Widget child);
		public override void set_child_property (Gtk.Widget child, uint id, GLib.Value value, GLib.ParamSpec pspec);
		public override void size_allocate (Gdk.Rectangle a);
		public override void size_request (out Gtk.Requisition r);
		public override void style_set (Gtk.Style? old_style);
		public string accel { get; set; }
		public Gnomenu.Gravity gravity { get; set; }
		public string label { get; set; }
		public Gtk.Label? label_widget { get; }
		public int max_width_chars { get; set; }
		public uint mnemonic_keyval { get; }
		public bool use_underline { get; set; }
	}
	[CCode (ref_function = "gnomenu_parser_ref", unref_function = "gnomenu_parser_unref", cheader_filename = "globalmenu-server.h")]
	public class Parser {
		public static void parse (Gnomenu.Shell shell, string description) throws GLib.Error;
	}
	[CCode (ref_function = "gnomenu_serializer_ref", unref_function = "gnomenu_serializer_unref", cheader_filename = "globalmenu-server.h")]
	public class Serializer {
		public static string to_string (GLib.Object obj, bool pretty_print = false);
	}
	[CCode (cheader_filename = "globalmenu-server.h")]
	public class Window : GLib.Object {
		public Window (Gdk.Window window);
		public override void dispose ();
		public void emit_menu_deselect (string path);
		public void emit_menu_event (string path);
		public void emit_menu_select (string path, string? pos);
		public static Gnomenu.Window? foreign_new (ulong xid);
		public string? @get (string property_name);
		public string? get_by_atom (Gdk.Atom atom);
		public string? get_menu_context ();
		public int get_monitor_num ();
		public uint get_xid ();
		public bool grab_key (uint keyval, Gdk.ModifierType state);
		public bool is_on_active_workspace ();
		public void @set (string property_name, string? value);
		public void set_by_atom (Gdk.Atom atom, string? value);
		public void set_key_widget (Gtk.Widget? widget);
		public void set_menu_context (string? value);
		public bool ungrab_key (uint keyval, Gdk.ModifierType state);
		public Gnomenu.Window transient { get; set; }
		public Gdk.Window window { get; set; }
		public signal void menu_context_changed ();
		public signal void menu_deselect (string path);
		public signal void menu_event (string path);
		public signal void menu_select (string path, string? pos);
		public signal void monitor_num_changed (int prev_num);
		public virtual signal void property_notify_event (string prop);
		public signal void transient_changed (Gnomenu.Window? prev_transient);
	}
	[CCode (cheader_filename = "globalmenu-server.h")]
	public interface Item : GLib.Object {
		public bool is_child_of (Gnomenu.Item possible_parent);
		public static Gnomenu.ItemState state_from_string (string? str);
		public static unowned string? state_to_string (Gnomenu.ItemState state);
		public static Gnomenu.ItemType type_from_string (string? str);
		public static bool type_has_label (Gnomenu.ItemType type);
		public static unowned string? type_to_string (Gnomenu.ItemType type);
		public abstract bool client_side_sub_shell { get; set; }
		public abstract bool has_sub_shell { get; set; }
		public abstract string? item_accel_text { get; set; }
		public abstract string? item_font { get; set; }
		public abstract string? item_icon { get; set; }
		public abstract string? item_id { get; set; }
		public abstract string? item_label { get; set; }
		public string item_path { owned get; }
		public string item_path_name { owned get; }
		public int item_position { get; }
		public abstract bool item_sensitive { get; set; }
		public abstract Gnomenu.ItemState item_state { get; set; }
		public abstract Gnomenu.ItemType item_type { get; set; }
		public abstract bool item_use_underline { get; set; }
		public abstract bool item_visible { get; set; }
		public abstract Gnomenu.Shell shell { get; }
		public abstract Gnomenu.Shell sub_shell { get; }
		public Gnomenu.Shell? topmost_shell { get; }
	}
	[CCode (cheader_filename = "globalmenu-server.h")]
	public interface Shell : GLib.Object {
		public abstract Gnomenu.Item? get_item (int position);
		public abstract Gnomenu.Item? get_item_by_id (string id);
		public Gnomenu.Item? get_item_by_path (string path);
		public abstract int get_item_position (Gnomenu.Item item);
		public abstract int length { get; set; }
		public abstract Gnomenu.Item? owner { get; }
		public Gnomenu.Shell? topmost_shell { get; }
		public signal void activate (Gnomenu.Item item);
		public signal void deselect (Gnomenu.Item item);
		public signal void select (Gnomenu.Item item);
	}
	[CCode (cprefix = "GNOMENU_BACKGROUND_TYPE_", cheader_filename = "globalmenu-server.h")]
	public enum BackgroundType {
		NONE,
		COLOR,
		PIXMAP
	}
	[CCode (cprefix = "GNOMENU_GRAVITY_", cheader_filename = "globalmenu-server.h")]
	public enum Gravity {
		DOWN,
		UP,
		LEFT,
		RIGHT
	}
	[CCode (cprefix = "GNOMENU_ITEM_STATE_", cheader_filename = "globalmenu-server.h")]
	public enum ItemState {
		UNTOGGLED,
		TOGGLED,
		TRISTATE
	}
	[CCode (cprefix = "GNOMENU_ITEM_TYPE_", cheader_filename = "globalmenu-server.h")]
	public enum ItemType {
		NORMAL,
		CHECK,
		RADIO,
		IMAGE,
		SEPARATOR,
		ARROW,
		ICON
	}
	[CCode (cheader_filename = "globalmenu-server.h")]
	public const string NET_GLOBALMENU_MENU_CONTEXT;
	[CCode (cheader_filename = "globalmenu-server.h")]
	public const string NET_GLOBALMENU_MENU_DESELECT;
	[CCode (cheader_filename = "globalmenu-server.h")]
	public const string NET_GLOBALMENU_MENU_EVENT;
	[CCode (cheader_filename = "globalmenu-server.h")]
	public const string NET_GLOBALMENU_MENU_SELECT;
}
