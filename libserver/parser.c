/* parser.c generated by valac, the Vala compiler
 * generated from parser.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define GNOMENU_TYPE_PARSER (gnomenu_parser_get_type ())
#define GNOMENU_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_PARSER, GnomenuParser))
#define GNOMENU_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMENU_TYPE_PARSER, GnomenuParserClass))
#define GNOMENU_IS_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_PARSER))
#define GNOMENU_IS_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMENU_TYPE_PARSER))
#define GNOMENU_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMENU_TYPE_PARSER, GnomenuParserClass))

typedef struct _GnomenuParser GnomenuParser;
typedef struct _GnomenuParserClass GnomenuParserClass;
typedef struct _GnomenuParserPrivate GnomenuParserPrivate;

#define GNOMENU_PARSER_TYPE_STATE (gnomenu_parser_state_get_type ())
#define GNOMENU_PARSER_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_PARSER_TYPE_STATE, GnomenuParserState))
#define GNOMENU_PARSER_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOMENU_PARSER_TYPE_STATE, GnomenuParserStateClass))
#define GNOMENU_PARSER_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_PARSER_TYPE_STATE))
#define GNOMENU_PARSER_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOMENU_PARSER_TYPE_STATE))
#define GNOMENU_PARSER_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOMENU_PARSER_TYPE_STATE, GnomenuParserStateClass))

typedef struct _GnomenuParserState GnomenuParserState;
typedef struct _GnomenuParserStateClass GnomenuParserStateClass;
#define _g_queue_free0(var) ((var == NULL) ? NULL : (var = (g_queue_free (var), NULL)))

#define GNOMENU_TYPE_SHELL (gnomenu_shell_get_type ())
#define GNOMENU_SHELL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_SHELL, GnomenuShell))
#define GNOMENU_IS_SHELL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_SHELL))
#define GNOMENU_SHELL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GNOMENU_TYPE_SHELL, GnomenuShellIface))

typedef struct _GnomenuShell GnomenuShell;
typedef struct _GnomenuShellIface GnomenuShellIface;

#define GNOMENU_TYPE_ITEM (gnomenu_item_get_type ())
#define GNOMENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOMENU_TYPE_ITEM, GnomenuItem))
#define GNOMENU_IS_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOMENU_TYPE_ITEM))
#define GNOMENU_ITEM_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GNOMENU_TYPE_ITEM, GnomenuItemIface))

typedef struct _GnomenuItem GnomenuItem;
typedef struct _GnomenuItemIface GnomenuItemIface;

#define GNOMENU_TYPE_ITEM_TYPE (gnomenu_item_type_get_type ())

#define GNOMENU_TYPE_ITEM_STATE (gnomenu_item_state_get_type ())
#define _g_markup_parse_context_free0(var) ((var == NULL) ? NULL : (var = (g_markup_parse_context_free (var), NULL)))
#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))
#define _gnomenu_parser_unref0(var) ((var == NULL) ? NULL : (var = (gnomenu_parser_unref (var), NULL)))
#define _gnomenu_parser_state_unref0(var) ((var == NULL) ? NULL : (var = (gnomenu_parser_state_unref (var), NULL)))
typedef struct _GnomenuParserStatePrivate GnomenuParserStatePrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _GnomenuParserParamSpecState GnomenuParserParamSpecState;
typedef struct _GnomenuParamSpecParser GnomenuParamSpecParser;

struct _GnomenuParser {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GnomenuParserPrivate * priv;
};

struct _GnomenuParserClass {
	GTypeClass parent_class;
	void (*finalize) (GnomenuParser *self);
};

struct _GnomenuParserPrivate {
	GQueue* stack;
	gboolean is_bootstrapping;
};

typedef enum  {
	GNOMENU_ITEM_TYPE_NORMAL = 0,
	GNOMENU_ITEM_TYPE_CHECK = 1,
	GNOMENU_ITEM_TYPE_RADIO = 2,
	GNOMENU_ITEM_TYPE_IMAGE = 3,
	GNOMENU_ITEM_TYPE_SEPARATOR = 4,
	GNOMENU_ITEM_TYPE_ARROW = 5,
	GNOMENU_ITEM_TYPE_ICON = 6
} GnomenuItemType;

typedef enum  {
	GNOMENU_ITEM_STATE_UNTOGGLED = 0,
	GNOMENU_ITEM_STATE_TOGGLED = 1,
	GNOMENU_ITEM_STATE_TRISTATE = 2
} GnomenuItemState;

struct _GnomenuItemIface {
	GTypeInterface parent_iface;
	GnomenuShell* (*get_shell) (GnomenuItem* self);
	GnomenuShell* (*get_sub_shell) (GnomenuItem* self);
	gboolean (*get_has_sub_shell) (GnomenuItem* self);
	void (*set_has_sub_shell) (GnomenuItem* self, gboolean value);
	gboolean (*get_client_side_sub_shell) (GnomenuItem* self);
	void (*set_client_side_sub_shell) (GnomenuItem* self, gboolean value);
	const char* (*get_item_id) (GnomenuItem* self);
	void (*set_item_id) (GnomenuItem* self, const char* value);
	GnomenuItemType (*get_item_type) (GnomenuItem* self);
	void (*set_item_type) (GnomenuItem* self, GnomenuItemType value);
	gboolean (*get_item_use_underline) (GnomenuItem* self);
	void (*set_item_use_underline) (GnomenuItem* self, gboolean value);
	gboolean (*get_item_sensitive) (GnomenuItem* self);
	void (*set_item_sensitive) (GnomenuItem* self, gboolean value);
	gboolean (*get_item_visible) (GnomenuItem* self);
	void (*set_item_visible) (GnomenuItem* self, gboolean value);
	GnomenuItemState (*get_item_state) (GnomenuItem* self);
	void (*set_item_state) (GnomenuItem* self, GnomenuItemState value);
	const char* (*get_item_label) (GnomenuItem* self);
	void (*set_item_label) (GnomenuItem* self, const char* value);
	const char* (*get_item_icon) (GnomenuItem* self);
	void (*set_item_icon) (GnomenuItem* self, const char* value);
	const char* (*get_item_accel_text) (GnomenuItem* self);
	void (*set_item_accel_text) (GnomenuItem* self, const char* value);
	const char* (*get_item_font) (GnomenuItem* self);
	void (*set_item_font) (GnomenuItem* self, const char* value);
};

struct _GnomenuShellIface {
	GTypeInterface parent_iface;
	GnomenuItem* (*get_item) (GnomenuShell* self, gint position);
	GnomenuItem* (*get_item_by_id) (GnomenuShell* self, const char* id);
	gint (*get_item_position) (GnomenuShell* self, GnomenuItem* item);
	GnomenuItem* (*get_owner) (GnomenuShell* self);
	gint (*get_length) (GnomenuShell* self);
	void (*set_length) (GnomenuShell* self, gint value);
};

struct _GnomenuParserState {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GnomenuParserStatePrivate * priv;
	GnomenuShell* shell;
	gboolean item_has_sub_shell;
};

struct _GnomenuParserStateClass {
	GTypeClass parent_class;
	void (*finalize) (GnomenuParserState *self);
};

struct _GnomenuParserStatePrivate {
	gint _position;
};

struct _GnomenuParserParamSpecState {
	GParamSpec parent_instance;
};

struct _GnomenuParamSpecParser {
	GParamSpec parent_instance;
};


static gpointer gnomenu_parser_state_parent_class = NULL;
static gpointer gnomenu_parser_parent_class = NULL;

gpointer gnomenu_parser_ref (gpointer instance);
void gnomenu_parser_unref (gpointer instance);
GParamSpec* gnomenu_param_spec_parser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void gnomenu_value_set_parser (GValue* value, gpointer v_object);
void gnomenu_value_take_parser (GValue* value, gpointer v_object);
gpointer gnomenu_value_get_parser (const GValue* value);
GType gnomenu_parser_get_type (void) G_GNUC_CONST;
static gpointer gnomenu_parser_state_ref (gpointer instance);
static void gnomenu_parser_state_unref (gpointer instance);
static GParamSpec* gnomenu_parser_param_spec_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void gnomenu_parser_value_set_state (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void gnomenu_parser_value_take_state (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer gnomenu_parser_value_get_state (const GValue* value) G_GNUC_UNUSED;
static GType gnomenu_parser_state_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define GNOMENU_PARSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GNOMENU_TYPE_PARSER, GnomenuParserPrivate))
enum  {
	GNOMENU_PARSER_DUMMY_PROPERTY
};
static void gnomenu_parser_start_element (GnomenuParser* self, GMarkupParseContext* context, const char* element_name, char** attribute_names, int attribute_names_length1, char** attribute_values, int attribute_values_length1, GError** error);
static void _gnomenu_parser_start_element_gmarkup_parser_start_element_func (GMarkupParseContext* context, const char* element_name, char** attribute_names, char** attribute_values, gpointer self, GError** error);
static void gnomenu_parser_end_element (GnomenuParser* self, GMarkupParseContext* context, const char* element_name, GError** error);
static void _gnomenu_parser_end_element_gmarkup_parser_end_element_func (GMarkupParseContext* context, const char* element_name, gpointer self, GError** error);
GType gnomenu_item_type_get_type (void) G_GNUC_CONST;
GType gnomenu_item_state_get_type (void) G_GNUC_CONST;
GType gnomenu_item_get_type (void) G_GNUC_CONST;
GType gnomenu_shell_get_type (void) G_GNUC_CONST;
static GnomenuParser* gnomenu_parser_new (GnomenuShell* shell);
static GnomenuParser* gnomenu_parser_construct (GType object_type, GnomenuShell* shell);
void gnomenu_parser_parse (GnomenuShell* shell, const char* description, GError** error);
static GnomenuParserState* gnomenu_parser_state_new (GnomenuShell* shell);
static GnomenuParserState* gnomenu_parser_state_construct (GType object_type, GnomenuShell* shell);
static GnomenuParserState* gnomenu_parser_get_state (GnomenuParser* self);
static GnomenuItem* gnomenu_parser_state_get_item (GnomenuParserState* self);
GnomenuShell* gnomenu_item_get_sub_shell (GnomenuItem* self);
static void gnomenu_parser_setup_item (GnomenuParser* self, GnomenuItem* item, char** attr_names, int attr_names_length1, char** attr_vals, int attr_vals_length1, GError** error);
void gnomenu_item_set_item_id (GnomenuItem* self, const char* value);
void gnomenu_item_set_item_visible (GnomenuItem* self, gboolean value);
void gnomenu_item_set_item_use_underline (GnomenuItem* self, gboolean value);
void gnomenu_item_set_item_sensitive (GnomenuItem* self, gboolean value);
GnomenuItemType gnomenu_item_type_from_string (const char* str);
void gnomenu_item_set_item_type (GnomenuItem* self, GnomenuItemType value);
void gnomenu_item_set_item_accel_text (GnomenuItem* self, const char* value);
void gnomenu_item_set_item_label (GnomenuItem* self, const char* value);
void gnomenu_item_set_item_icon (GnomenuItem* self, const char* value);
GnomenuItemState gnomenu_item_state_from_string (const char* str);
void gnomenu_item_set_item_state (GnomenuItem* self, GnomenuItemState value);
void gnomenu_item_set_item_font (GnomenuItem* self, const char* value);
void gnomenu_item_set_client_side_sub_shell (GnomenuItem* self, gboolean value);
static gint gnomenu_parser_state_get_position (GnomenuParserState* self);
void gnomenu_shell_set_length (GnomenuShell* self, gint value);
void gnomenu_item_set_has_sub_shell (GnomenuItem* self, gboolean value);
static void gnomenu_parser_state_advance (GnomenuParserState* self);
#define GNOMENU_PARSER_STATE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GNOMENU_PARSER_TYPE_STATE, GnomenuParserStatePrivate))
enum  {
	GNOMENU_PARSER_STATE_DUMMY_PROPERTY
};
GnomenuItem* gnomenu_shell_get_item (GnomenuShell* self, gint position);
static void gnomenu_parser_state_finalize (GnomenuParserState* obj);
static void gnomenu_parser_finalize (GnomenuParser* obj);
static gint _vala_array_length (gpointer array);

static const GMarkupParser GNOMENU_PARSER_parser_functions = {_gnomenu_parser_start_element_gmarkup_parser_start_element_func, _gnomenu_parser_end_element_gmarkup_parser_end_element_func, NULL, NULL, NULL};


static void _gnomenu_parser_start_element_gmarkup_parser_start_element_func (GMarkupParseContext* context, const char* element_name, char** attribute_names, char** attribute_values, gpointer self, GError** error) {
	gnomenu_parser_start_element (self, context, element_name, attribute_names, _vala_array_length (attribute_names), attribute_values, _vala_array_length (attribute_values), error);
}


static void _gnomenu_parser_end_element_gmarkup_parser_end_element_func (GMarkupParseContext* context, const char* element_name, gpointer self, GError** error) {
	gnomenu_parser_end_element (self, context, element_name, error);
}


void gnomenu_parser_parse (GnomenuShell* shell, const char* description, GError** error) {
	GError * _inner_error_;
	GnomenuParser* parser;
	GTimer* timer;
	GMarkupParseContext* context;
	g_return_if_fail (shell != NULL);
	g_return_if_fail (description != NULL);
	_inner_error_ = NULL;
	parser = gnomenu_parser_new (shell);
	timer = g_timer_new ();
	context = g_markup_parse_context_new (&GNOMENU_PARSER_parser_functions, 0, parser, NULL);
	g_markup_parse_context_parse (context, description, (gssize) (-1), &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_markup_parse_context_free0 (context);
		_g_timer_destroy0 (timer);
		_gnomenu_parser_unref0 (parser);
		return;
	}
	g_debug ("parser.vala:13: Parser consumed: %lf for %lu bytes", g_timer_elapsed (timer, NULL), (gulong) strlen (description));
	_g_markup_parse_context_free0 (context);
	_g_timer_destroy0 (timer);
	_gnomenu_parser_unref0 (parser);
}


static gpointer _gnomenu_parser_state_ref0 (gpointer self) {
	return self ? gnomenu_parser_state_ref (self) : NULL;
}


static GnomenuParser* gnomenu_parser_construct (GType object_type, GnomenuShell* shell) {
	GnomenuParser* self;
	GQueue* _tmp0_;
	GnomenuParserState* bootstrap;
	g_return_val_if_fail (shell != NULL, NULL);
	self = (GnomenuParser*) g_type_create_instance (object_type);
	self->priv->stack = (_tmp0_ = g_queue_new (), _g_queue_free0 (self->priv->stack), _tmp0_);
	bootstrap = gnomenu_parser_state_new (shell);
	self->priv->is_bootstrapping = TRUE;
	g_queue_push_tail (self->priv->stack, _gnomenu_parser_state_ref0 (bootstrap));
	_gnomenu_parser_state_unref0 (bootstrap);
	return self;
}


static GnomenuParser* gnomenu_parser_new (GnomenuShell* shell) {
	return gnomenu_parser_construct (GNOMENU_TYPE_PARSER, shell);
}


static void gnomenu_parser_start_element (GnomenuParser* self, GMarkupParseContext* context, const char* element_name, char** attribute_names, int attribute_names_length1, char** attribute_values, int attribute_values_length1, GError** error) {
	GError * _inner_error_;
	GQuark _tmp1_;
	const char* _tmp0_;
	static GQuark _tmp1__label0 = 0;
	static GQuark _tmp1__label1 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	g_return_if_fail (element_name != NULL);
	_inner_error_ = NULL;
	_tmp0_ = element_name;
	_tmp1_ = (NULL == _tmp0_) ? 0 : g_quark_from_string (_tmp0_);
	if (_tmp1_ == ((0 != _tmp1__label0) ? _tmp1__label0 : (_tmp1__label0 = g_quark_from_static_string ("menu"))))
	switch (0) {
		default:
		{
			if (!self->priv->is_bootstrapping) {
				GnomenuItem* item;
				item = gnomenu_parser_state_get_item (gnomenu_parser_get_state (self));
				gnomenu_parser_get_state (self)->item_has_sub_shell = TRUE;
				g_queue_push_tail (self->priv->stack, gnomenu_parser_state_new (gnomenu_item_get_sub_shell (item)));
				_g_object_unref0 (item);
			}
			break;
		}
	} else if (_tmp1_ == ((0 != _tmp1__label1) ? _tmp1__label1 : (_tmp1__label1 = g_quark_from_static_string ("item"))))
	switch (0) {
		default:
		{
			GnomenuItem* item;
			self->priv->is_bootstrapping = FALSE;
			item = gnomenu_parser_state_get_item (gnomenu_parser_get_state (self));
			gnomenu_parser_setup_item (self, item, attribute_names, attribute_names_length1, attribute_values, attribute_values_length1, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_MARKUP_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_object_unref0 (item);
					return;
				} else {
					_g_object_unref0 (item);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			gnomenu_parser_get_state (self)->item_has_sub_shell = FALSE;
			_g_object_unref0 (item);
			break;
		}
	} else
	switch (0) {
		default:
		{
			_inner_error_ = g_error_new_literal (G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT, "unkown element");
			{
				if (_inner_error_->domain == G_MARKUP_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


static void gnomenu_parser_setup_item (GnomenuParser* self, GnomenuItem* item, char** attr_names, int attr_names_length1, char** attr_vals, int attr_vals_length1, GError** error) {
	GError * _inner_error_;
	const char* label;
	const char* icon;
	const char* type;
	const char* state;
	const char* font;
	const char* id;
	const char* accel;
	gboolean sensitive;
	gboolean visible;
	gboolean underline;
	gboolean client_side;
	g_return_if_fail (self != NULL);
	g_return_if_fail (item != NULL);
	_inner_error_ = NULL;
	label = NULL;
	icon = NULL;
	type = NULL;
	state = NULL;
	font = NULL;
	id = NULL;
	accel = NULL;
	sensitive = TRUE;
	visible = TRUE;
	underline = TRUE;
	client_side = FALSE;
	g_markup_collect_attributes ("item", attr_names, attr_vals, &_inner_error_, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "label", &label, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "type", &type, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "state", &state, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "font", &font, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "id", &id, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "icon", &icon, G_MARKUP_COLLECT_STRING | G_MARKUP_COLLECT_OPTIONAL, "accel", &accel, G_MARKUP_COLLECT_TRISTATE, "visible", &visible, G_MARKUP_COLLECT_TRISTATE, "underline", &underline, G_MARKUP_COLLECT_TRISTATE, "sensitive", &sensitive, G_MARKUP_COLLECT_TRISTATE, "client-side", &client_side, G_MARKUP_COLLECT_INVALID);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	if (visible != FALSE) {
		visible = TRUE;
	}
	if (sensitive != FALSE) {
		sensitive = TRUE;
	}
	if (underline != FALSE) {
		underline = TRUE;
	}
	if (client_side != TRUE) {
		client_side = FALSE;
	}
	gnomenu_item_set_item_id (item, id);
	gnomenu_item_set_item_visible (item, visible);
	gnomenu_item_set_item_use_underline (item, underline);
	gnomenu_item_set_item_sensitive (item, sensitive);
	gnomenu_item_set_item_type (item, gnomenu_item_type_from_string (type));
	gnomenu_item_set_item_accel_text (item, accel);
	gnomenu_item_set_item_label (item, label);
	gnomenu_item_set_item_icon (item, icon);
	gnomenu_item_set_item_state (item, gnomenu_item_state_from_string (state));
	gnomenu_item_set_item_font (item, font);
	gnomenu_item_set_client_side_sub_shell (item, client_side);
}


static void gnomenu_parser_end_element (GnomenuParser* self, GMarkupParseContext* context, const char* element_name, GError** error) {
	GQuark _tmp4_;
	const char* _tmp3_;
	static GQuark _tmp4__label0 = 0;
	static GQuark _tmp4__label1 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	g_return_if_fail (element_name != NULL);
	_tmp3_ = element_name;
	_tmp4_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
	if (_tmp4_ == ((0 != _tmp4__label0) ? _tmp4__label0 : (_tmp4__label0 = g_quark_from_static_string ("menu"))))
	switch (0) {
		default:
		{
			GnomenuParserState* _tmp0_;
			gnomenu_shell_set_length (gnomenu_parser_get_state (self)->shell, gnomenu_parser_state_get_position (gnomenu_parser_get_state (self)));
			_tmp0_ = (GnomenuParserState*) g_queue_pop_tail (self->priv->stack);
			_gnomenu_parser_state_unref0 (_tmp0_);
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label1) ? _tmp4__label1 : (_tmp4__label1 = g_quark_from_static_string ("item"))))
	switch (0) {
		default:
		{
			if (!gnomenu_parser_get_state (self)->item_has_sub_shell) {
				GnomenuItem* _tmp1_;
				gnomenu_item_set_has_sub_shell (_tmp1_ = gnomenu_parser_state_get_item (gnomenu_parser_get_state (self)), FALSE);
				_g_object_unref0 (_tmp1_);
			} else {
				GnomenuItem* _tmp2_;
				gnomenu_item_set_has_sub_shell (_tmp2_ = gnomenu_parser_state_get_item (gnomenu_parser_get_state (self)), TRUE);
				_g_object_unref0 (_tmp2_);
			}
			gnomenu_parser_state_advance (gnomenu_parser_get_state (self));
			break;
		}
	}
}


static GnomenuParserState* gnomenu_parser_get_state (GnomenuParser* self) {
	GnomenuParserState* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = (GnomenuParserState*) g_queue_peek_tail (self->priv->stack);
	return result;
}


static void gnomenu_parser_state_advance (GnomenuParserState* self) {
	g_return_if_fail (self != NULL);
	self->priv->_position++;
}


static GnomenuItem* gnomenu_parser_state_get_item (GnomenuParserState* self) {
	GnomenuItem* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = gnomenu_shell_get_item (self->shell, gnomenu_parser_state_get_position (self));
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static GnomenuParserState* gnomenu_parser_state_construct (GType object_type, GnomenuShell* shell) {
	GnomenuParserState* self;
	GnomenuShell* _tmp0_;
	g_return_val_if_fail (shell != NULL, NULL);
	self = (GnomenuParserState*) g_type_create_instance (object_type);
	self->shell = (_tmp0_ = _g_object_ref0 (shell), _g_object_unref0 (self->shell), _tmp0_);
	return self;
}


static GnomenuParserState* gnomenu_parser_state_new (GnomenuShell* shell) {
	return gnomenu_parser_state_construct (GNOMENU_PARSER_TYPE_STATE, shell);
}


static gint gnomenu_parser_state_get_position (GnomenuParserState* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_position;
	return result;
}


static void gnomenu_parser_value_state_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void gnomenu_parser_value_state_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gnomenu_parser_state_unref (value->data[0].v_pointer);
	}
}


static void gnomenu_parser_value_state_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gnomenu_parser_state_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer gnomenu_parser_value_state_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* gnomenu_parser_value_state_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GnomenuParserState* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gnomenu_parser_state_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* gnomenu_parser_value_state_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GnomenuParserState** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gnomenu_parser_state_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* gnomenu_parser_param_spec_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	GnomenuParserParamSpecState* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GNOMENU_PARSER_TYPE_STATE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer gnomenu_parser_value_get_state (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GNOMENU_PARSER_TYPE_STATE), NULL);
	return value->data[0].v_pointer;
}


static void gnomenu_parser_value_set_state (GValue* value, gpointer v_object) {
	GnomenuParserState* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GNOMENU_PARSER_TYPE_STATE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GNOMENU_PARSER_TYPE_STATE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gnomenu_parser_state_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gnomenu_parser_state_unref (old);
	}
}


static void gnomenu_parser_value_take_state (GValue* value, gpointer v_object) {
	GnomenuParserState* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GNOMENU_PARSER_TYPE_STATE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GNOMENU_PARSER_TYPE_STATE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gnomenu_parser_state_unref (old);
	}
}


static void gnomenu_parser_state_class_init (GnomenuParserStateClass * klass) {
	gnomenu_parser_state_parent_class = g_type_class_peek_parent (klass);
	GNOMENU_PARSER_STATE_CLASS (klass)->finalize = gnomenu_parser_state_finalize;
	g_type_class_add_private (klass, sizeof (GnomenuParserStatePrivate));
}


static void gnomenu_parser_state_instance_init (GnomenuParserState * self) {
	self->priv = GNOMENU_PARSER_STATE_GET_PRIVATE (self);
	self->priv->_position = 0;
	self->item_has_sub_shell = FALSE;
	self->ref_count = 1;
}


static void gnomenu_parser_state_finalize (GnomenuParserState* obj) {
	GnomenuParserState * self;
	self = GNOMENU_PARSER_STATE (obj);
	_g_object_unref0 (self->shell);
}


static GType gnomenu_parser_state_get_type (void) {
	static volatile gsize gnomenu_parser_state_type_id__volatile = 0;
	if (g_once_init_enter (&gnomenu_parser_state_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { gnomenu_parser_value_state_init, gnomenu_parser_value_state_free_value, gnomenu_parser_value_state_copy_value, gnomenu_parser_value_state_peek_pointer, "p", gnomenu_parser_value_state_collect_value, "p", gnomenu_parser_value_state_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GnomenuParserStateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnomenu_parser_state_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GnomenuParserState), 0, (GInstanceInitFunc) gnomenu_parser_state_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gnomenu_parser_state_type_id;
		gnomenu_parser_state_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GnomenuParserState", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gnomenu_parser_state_type_id__volatile, gnomenu_parser_state_type_id);
	}
	return gnomenu_parser_state_type_id__volatile;
}


static gpointer gnomenu_parser_state_ref (gpointer instance) {
	GnomenuParserState* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void gnomenu_parser_state_unref (gpointer instance) {
	GnomenuParserState* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GNOMENU_PARSER_STATE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void gnomenu_value_parser_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void gnomenu_value_parser_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gnomenu_parser_unref (value->data[0].v_pointer);
	}
}


static void gnomenu_value_parser_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gnomenu_parser_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer gnomenu_value_parser_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* gnomenu_value_parser_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GnomenuParser* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gnomenu_parser_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* gnomenu_value_parser_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GnomenuParser** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gnomenu_parser_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* gnomenu_param_spec_parser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	GnomenuParamSpecParser* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GNOMENU_TYPE_PARSER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer gnomenu_value_get_parser (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GNOMENU_TYPE_PARSER), NULL);
	return value->data[0].v_pointer;
}


void gnomenu_value_set_parser (GValue* value, gpointer v_object) {
	GnomenuParser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GNOMENU_TYPE_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GNOMENU_TYPE_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gnomenu_parser_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gnomenu_parser_unref (old);
	}
}


void gnomenu_value_take_parser (GValue* value, gpointer v_object) {
	GnomenuParser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GNOMENU_TYPE_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GNOMENU_TYPE_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gnomenu_parser_unref (old);
	}
}


static void gnomenu_parser_class_init (GnomenuParserClass * klass) {
	gnomenu_parser_parent_class = g_type_class_peek_parent (klass);
	GNOMENU_PARSER_CLASS (klass)->finalize = gnomenu_parser_finalize;
	g_type_class_add_private (klass, sizeof (GnomenuParserPrivate));
}


static void gnomenu_parser_instance_init (GnomenuParser * self) {
	self->priv = GNOMENU_PARSER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void gnomenu_parser_finalize (GnomenuParser* obj) {
	GnomenuParser * self;
	self = GNOMENU_PARSER (obj);
	{
		GnomenuParserState* s;
		s = NULL;
		while (TRUE) {
			GnomenuParserState* _tmp0_;
			if (!((s = (_tmp0_ = (GnomenuParserState*) g_queue_pop_tail (self->priv->stack), _gnomenu_parser_state_unref0 (s), _tmp0_)) != NULL)) {
				break;
			}
			continue;
		}
		_gnomenu_parser_state_unref0 (s);
	}
	_g_queue_free0 (self->priv->stack);
}


GType gnomenu_parser_get_type (void) {
	static volatile gsize gnomenu_parser_type_id__volatile = 0;
	if (g_once_init_enter (&gnomenu_parser_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { gnomenu_value_parser_init, gnomenu_value_parser_free_value, gnomenu_value_parser_copy_value, gnomenu_value_parser_peek_pointer, "p", gnomenu_value_parser_collect_value, "p", gnomenu_value_parser_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GnomenuParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnomenu_parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GnomenuParser), 0, (GInstanceInitFunc) gnomenu_parser_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gnomenu_parser_type_id;
		gnomenu_parser_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GnomenuParser", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gnomenu_parser_type_id__volatile, gnomenu_parser_type_id);
	}
	return gnomenu_parser_type_id__volatile;
}


gpointer gnomenu_parser_ref (gpointer instance) {
	GnomenuParser* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void gnomenu_parser_unref (gpointer instance) {
	GnomenuParser* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GNOMENU_PARSER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




